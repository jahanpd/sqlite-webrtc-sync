# Syncable SQLite - API Reference for LLMs

This document describes the Syncable SQLite API, a browser-based SQLite database with OPFS persistence and WebRTC peer-to-peer syncing.

## Overview

Syncable SQLite provides:
- SQLite database running in browser via WebAssembly
- Persistent storage using OPFS (Origin Private File System)
- Peer-to-peer database syncing via WebRTC
- Automatic conflict resolution using last-write-wins strategy
- Soft deletes for proper sync behavior

## Core Concepts

### Database Modes
- `local`: Standalone database, no peer connectivity
- `syncing`: Database with WebRTC peer-to-peer capabilities

### Automatic Columns
Every table automatically receives these columns:
- `id` (TEXT PRIMARY KEY): Auto-generated UUID for each row
- `updated_at` (INTEGER): Unix timestamp in milliseconds, auto-updated on INSERT/UPDATE
- `deleted` (INTEGER): 0=active, 1=soft-deleted

### SQL Rewriting
The library automatically rewrites SQL statements:
- INSERT: Generates id, updated_at, sets deleted=0
- UPDATE: Updates updated_at timestamp
- DELETE: Converts to UPDATE setting deleted=1
- SELECT: Filters out rows where deleted=1

## API

### Creating a Database

```javascript
import { createDatabase } from 'syncable-sqlite';

// Local mode (no syncing)
const localDb = await createDatabase('my-local-db', { mode: 'local' });

// Syncing mode with custom peer server
const syncDb = await createDatabase('my-sync-db', {
  mode: 'syncing',
  peerServer: {
    host: 'localhost',
    port: 9000,
    path: '/',
    secure: false
  }
});
```

### Database Methods

#### exec(sql: string, params?: unknown[]): Promise<QueryResult>
Execute SQL statement. Returns { rows: object[], columns: string[] }.

```javascript
await db.exec('CREATE TABLE users (name TEXT, email TEXT)');
await db.exec("INSERT INTO users (name, email) VALUES ('Alice', 'alice@test.com')");
const result = await db.exec('SELECT * FROM users WHERE name = ?', ['Alice']);
// result.rows = [{ id: 'uuid', name: 'Alice', email: 'alice@test.com', updated_at: 1234567890, deleted: 0 }]
```

#### export(): Promise<Uint8Array>
Export database as SQL dump (CREATE TABLE + INSERT statements).

```javascript
const data = await db.export();
```

#### import(data: Uint8Array): Promise<void>
Import SQL dump into database. Uses INSERT OR REPLACE for existing rows.

```javascript
await db.import(data);
```

#### merge(remoteData: Uint8Array): Promise<void>
Merge remote data with last-write-wins conflict resolution.
- Rows matched by id
- Higher updated_at timestamp wins
- Deleted rows excluded from results

```javascript
const remoteData = await remoteDb.export();
await localDb.merge(remoteData);
```

#### close(): Promise<void>
Close database, terminate worker, destroy peer connections.

```javascript
await db.close();
```

### Peer Syncing Methods (syncing mode only)

#### getPeerId(): string | null
Get this database's peer ID for sharing with other peers.

```javascript
const myPeerId = db.getPeerId();
```

#### connectToPeer(peerId: string): Promise<void>
Establish WebRTC connection to remote peer.

```javascript
await db.connectToPeer('remote-peer-id');
```

#### disconnectFromPeer(peerId: string): Promise<void>
Close connection to peer.

```javascript
await db.disconnectFromPeer('remote-peer-id');
```

#### getConnectedPeers(): PeerInfo[]
List connected peers. Returns [{ id: string, status: 'connected' | 'disconnected' }].

```javascript
const peers = db.getConnectedPeers();
```

#### exportToPeer(peerId: string): Promise<void>
Request remote peer's data and import it locally (pull).

```javascript
await db.exportToPeer('remote-peer-id');
```

#### importFromPeer(peerId: string): Promise<void>
Send local data to remote peer (push).

```javascript
await db.importFromPeer('remote-peer-id');
```

#### exportToAllPeers(): Promise<void>
Pull data from all connected peers.

#### importFromAllPeers(): Promise<void>
Push data to all connected peers.

### Auto-Discovery Methods (syncing mode only)

#### discoverPeers(): Promise<void>
Manually trigger peer discovery. Queries PeerJS server for peers with same database name prefix.

```javascript
await db.discoverPeers();
```

#### isConnected(): boolean
Check if connected to any peers.

```javascript
if (db.isConnected()) {
  console.log('Has peer connections');
}
```

### Offline Queue Methods (syncing mode only)

#### getQueuedOperations(): SyncOperation[]
Get operations queued while offline.

```javascript
const queue = db.getQueuedOperations();
```

#### pushQueuedOperations(): Promise<void>
Send queued operations to all connected peers. Throws if no peers connected.

```javascript
await db.pushQueuedOperations();
```

#### clearQueue(): void
Discard all queued operations.

```javascript
db.clearQueue();
```

### Event Callbacks (syncing mode only)

#### onPeerConnected(callback: (peerId: string) => void): void
Register callback for peer connection events.

```javascript
db.onPeerConnected((peerId) => console.log('Connected:', peerId));
```

#### onPeerDisconnected(callback: (peerId: string) => void): void
Register callback for peer disconnection events.

```javascript
db.onPeerDisconnected((peerId) => console.log('Disconnected:', peerId));
```

#### onSyncReceived(callback: (operation: SyncOperation) => void): void
Register callback for incoming sync operations.

```javascript
db.onSyncReceived((op) => console.log('Sync received:', op.table, op.rowId));
```

## Type Definitions

```typescript
type DatabaseMode = 'syncing' | 'local';

interface PeerServerConfig {
  host?: string;
  port?: number;
  path?: string;
  secure?: boolean;
}

interface DatabaseConfig {
  mode: DatabaseMode;
  peerServer?: PeerServerConfig;
  discoveryInterval?: number;  // ms, default 5000
}

interface QueryResult {
  rows: Record<string, unknown>[];
  columns: string[];
}

interface PeerInfo {
  id: string;
  status: 'connecting' | 'connected' | 'disconnected';
}

interface SyncOperation {
  id: string;           // Unique operation ID
  timestamp: number;    // For ordering
  sql: string;          // The processed SQL statement
  table: string;        // Affected table
  rowId: string;        // Affected row ID
}
```

## Example: Auto-Discovery and Real-Time Sync

```javascript
// Both peers use the SAME database name - they auto-discover each other
const dbA = await createDatabase('shared-app', {
  mode: 'syncing',
  peerServer: { host: 'localhost', port: 9000, path: '/', secure: false }
});

const dbB = await createDatabase('shared-app', {
  mode: 'syncing',
  peerServer: { host: 'localhost', port: 9000, path: '/', secure: false }
});

// Create same table on both
await dbA.exec('CREATE TABLE IF NOT EXISTS items (name TEXT)');
await dbB.exec('CREATE TABLE IF NOT EXISTS items (name TEXT)');

// Register event callbacks
dbB.onSyncReceived((op) => {
  console.log('B received sync:', op.sql);
});

// Wait for auto-discovery (~5 seconds)
await new Promise(r => setTimeout(r, 6000));

// Now they're connected
console.log(dbA.isConnected()); // true
console.log(dbB.isConnected()); // true

// Real-time sync: INSERT on A automatically appears on B
await dbA.exec("INSERT INTO items (name) VALUES ('from-a')");

// B gets the data automatically (onSyncReceived callback fires)
await new Promise(r => setTimeout(r, 1000));
const result = await dbB.exec('SELECT * FROM items');
// result.rows includes 'from-a'

await dbA.close();
await dbB.close();
```

## Example: Two-Way Sync Between Peers (Manual)

```javascript
// Peer A creates database and inserts data
const dbA = await createDatabase('peer-a-db', { 
  mode: 'syncing',
  peerServer: { host: 'localhost', port: 9000, path: '/', secure: false }
});
await dbA.exec('CREATE TABLE items (name TEXT)');
await dbA.exec("INSERT INTO items (name) VALUES ('item-from-a')");
const peerIdA = dbA.getPeerId();

// Peer B creates database and inserts different data
const dbB = await createDatabase('peer-b-db', {
  mode: 'syncing', 
  peerServer: { host: 'localhost', port: 9000, path: '/', secure: false }
});
await dbB.exec('CREATE TABLE items (name TEXT)');
await dbB.exec("INSERT INTO items (name) VALUES ('item-from-b')");
const peerIdB = dbB.getPeerId();

// Connect B to A
await dbB.connectToPeer(peerIdA);

// B pulls A's data
await dbB.exportToPeer(peerIdA);

// A pulls B's data
await dbA.exportToPeer(peerIdB);

// Both databases now have both items
const resultA = await dbA.exec('SELECT * FROM items');
const resultB = await dbB.exec('SELECT * FROM items');
// Both have: 'item-from-a' and 'item-from-b'

// Cleanup
await dbA.close();
await dbB.close();
```

## Example: Conflict Resolution

```javascript
// Both peers have same row (same id), different values
// Peer A updates row at time T1
// Peer B updates same row at time T2 where T2 > T1

// After merge, the row with T2 (Peer B's version) wins
// because T2 > T1 (last-write-wins)
```

## Architecture Notes

- Main thread: SyncableDatabase class handles API and peer connections
- Web Worker: Runs SQLite WASM, handles all database operations
- OPFS: Each database stored as separate file in Origin Private File System
- PeerJS: Handles WebRTC signaling and data channels for peer communication
- Export format: SQL text (CREATE TABLE + INSERT statements), not binary SQLite file
- Auto-discovery: Peer IDs use format `{dbName}-{uuid}` for prefix-based discovery
- Real-time sync: Mutations broadcast to all connected peers immediately
- Offline queue: Operations queued in-memory when no peers connected

## Common Patterns

### Initialize with error handling
```javascript
try {
  const db = await createDatabase('my-db', { mode: 'syncing', peerServer: config });
} catch (err) {
  console.error('Failed to create database:', err);
}
```

### Sync on connect
```javascript
await db.connectToPeer(remotePeerId);
await db.exportToPeer(remotePeerId); // Pull their data
await db.importFromPeer(remotePeerId); // Push our data
```

### Check connection status
```javascript
const peers = db.getConnectedPeers();
const isConnected = peers.some(p => p.id === targetPeerId && p.status === 'connected');
```

### Handle offline operations
```javascript
// Perform operations while offline (they get queued)
await db.exec("INSERT INTO items (name) VALUES ('offline-item')");

// Later, when reconnected
if (db.isConnected()) {
  await db.pushQueuedOperations();  // Send queued ops to peers
}
```

### React to sync events
```javascript
db.onPeerConnected((peerId) => {
  console.log('New peer connected');
});

db.onSyncReceived((operation) => {
  // Update UI when remote changes arrive
  refreshUI();
});
```
