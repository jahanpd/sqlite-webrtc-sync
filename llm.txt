# Syncable SQLite - LLM Reference

Browser SQLite with OPFS persistence and WebRTC P2P sync.

## Imports

```javascript
import { createDatabase, SyncableDatabase } from 'syncable-sqlite';
import { defineSchema, defineTable, column } from 'syncable-sqlite/schema';
import { DatabaseProvider, useQuery, useSQL, useMutation, useSyncStatus, usePeers, useDatabase, useIsDatabaseReady } from 'syncable-sqlite/react';
```

## Core API

### createDatabase(name: string, config: DatabaseConfig): Promise<SyncableDatabase>

```typescript
interface DatabaseConfig {
  mode: 'local' | 'syncing';
  peerServer?: { host?: string; port?: number; path?: string; secure?: boolean };
  discoveryInterval?: number;  // ms, default 5000
}
```

### SyncableDatabase Methods

```typescript
// SQL execution
exec(sql: string, params?: unknown[]): Promise<QueryResult>
// QueryResult = { rows: Record<string, unknown>[], columns: string[], affectedRows?: { id: string, table: string }[] }

// Export/Import - SQL dump format (text encoded as bytes)
export(): Promise<Uint8Array>
import(data: Uint8Array): Promise<void>
merge(data: Uint8Array): Promise<void>  // last-write-wins by updated_at

// Export/Import - Native SQLite binary format
exportBinary(): Promise<Uint8Array>
importBinary(data: Uint8Array): Promise<void>  // replaces entire DB
mergeBinary(data: Uint8Array): Promise<void>   // last-write-wins by updated_at

// File download (browser only)
saveToFile(filename?: string): Promise<void>

// Peer management (syncing mode)
getPeerId(): string | null
connectToPeer(peerId: string): Promise<void>
disconnectFromPeer(peerId: string): Promise<void>
getConnectedPeers(): PeerInfo[]  // { id: string, status: 'connecting' | 'connected' | 'disconnected' }
isConnected(): boolean

// Peer sync - one-way (replace)
exportToPeer(peerId: string): Promise<void>    // pull from peer
importFromPeer(peerId: string): Promise<void>  // push to peer
exportToAllPeers(): Promise<void>
importFromAllPeers(): Promise<void>

// Peer sync - merge (last-write-wins)
mergeFromPeer(peerId: string): Promise<void>   // pull and merge from peer
mergeToPeer(peerId: string): Promise<void>     // push to peer for merging
mergeFromAllPeers(): Promise<void>             // merge from all peers
mergeToAllPeers(): Promise<void>               // push merge to all peers
syncWithPeer(peerId: string): Promise<void>    // bidirectional merge
syncWithAllPeers(): Promise<void>              // bidirectional merge with all

// Auto-discovery
discoverPeers(): Promise<void>

// Offline queue
getQueuedOperations(): SyncOperation[]
pushQueuedOperations(): Promise<void>
clearQueue(): void

// Events
onPeerConnected(cb: (peerId: string) => void): void
onPeerDisconnected(cb: (peerId: string) => void): void
onSyncReceived(cb: (op: SyncOperation) => void): void
onMutation(cb: (tables: string[]) => void): void
onDataChanged(cb: () => void): void  // fires on merge/import operations

// Cleanup
close(): Promise<void>
```

## Automatic Schema

All tables get these columns automatically:
- `id` TEXT PRIMARY KEY - auto-generated UUID
- `updated_at` INTEGER - Unix ms timestamp, auto-updated
- `deleted` INTEGER - 0=active, 1=soft-deleted

SQL rewriting:
- INSERT: adds id, updated_at, deleted=0
- UPDATE: updates updated_at
- DELETE: becomes UPDATE SET deleted=1
- SELECT: adds WHERE deleted=0

## Schema Definition

```typescript
const schema = defineSchema({
  users: defineTable({
    name: column.text(),
    email: column.text(),
    age: column.integer().optional(),
    active: column.boolean(),
  }),
});

// Column types:
column.text()     // string
column.integer()  // number
column.real()     // number
column.boolean()  // boolean (INTEGER 0/1)
column.blob()     // Uint8Array
.optional()       // nullable

// Schema methods:
schema.toSQL(): string[]           // CREATE TABLE statements
schema.getTableSQL(name): string   // single table SQL
```

## React API

### DatabaseProvider

```tsx
<DatabaseProvider
  name="my-app"
  schema={schema}
  mode="syncing"
  peerServer={{ host: 'localhost', port: 9000, path: '/', secure: false }}
  discoveryInterval={5000}
>
  {children}
</DatabaseProvider>
```

### useQuery(dbName, tableName)

Builder pattern for simple queries. Returns `QueryResult<Row>`.

```tsx
const { data, isLoading, error, refetch } = useQuery('my-app', 'todos')
  .where('completed', '=', false)     // operators: = != > < >= <= LIKE IN
  .where('priority', '>=', 1)         // multiple = AND
  .orderBy('updated_at', 'desc')
  .limit(10)
  .exec();

// data: Row[] | undefined
```

### useSQL<T>(dbName, sql, options?)

Raw SQL for complex queries.

```tsx
interface Options {
  params?: unknown[];   // SQL params, query re-runs on change
  tables?: string[];    // tables for reactivity
}

const { data, isLoading, error, refetch } = useSQL<Stats>(
  'my-app',
  'SELECT category, COUNT(*) as count FROM products GROUP BY category',
  { tables: ['products'] }
);

// Parameterized:
const { data } = useSQL<User>('db', 'SELECT * FROM users WHERE id = ?', {
  params: [userId],
  tables: ['users'],
});
```

### useMutation(dbName, tableName)

```tsx
const { insert, update, remove, isLoading, error } = useMutation('my-app', 'todos');

const row = await insert({ title: 'Test', completed: false });  // returns full row with id
const updated = await update(id, { completed: true });
const removed = await remove(id);  // soft delete, returns row
```

### useSyncStatus(dbName)

```tsx
const {
  isConnected,        // boolean
  peerCount,          // number
  pendingOperations,  // number (queue size)
  peerId,             // string | null
  mode,               // 'syncing' | 'local'
} = useSyncStatus('my-app');
```

### usePeers(dbName)

```tsx
const {
  peers,              // PeerInfo[]
  connectToPeer,      // (peerId: string) => Promise<void>
  disconnectFromPeer, // (peerId: string) => Promise<void>
  pushQueue,          // () => Promise<void>
  clearQueue,         // () => void
} = usePeers('my-app');
```

### useDatabase(dbName)

```tsx
const db = useDatabase('my-app');  // SyncableDatabase | null
await db?.export();
```

### useIsDatabaseReady(dbName)

```tsx
const isReady = useIsDatabaseReady('my-app');  // boolean
```

## Vite Config

```javascript
import { syncableSqliteVitePlugin } from 'syncable-sqlite';

export default defineConfig({
  plugins: [syncableSqliteVitePlugin()],
  server: {
    headers: {
      'Cross-Origin-Opener-Policy': 'same-origin',
      'Cross-Origin-Embedder-Policy': 'require-corp',
    },
  },
  optimizeDeps: { exclude: ['syncable-sqlite'] },
});
```

Production: copy `sqlite3.wasm` and `sqlite3-opfs-async-proxy.js` from `node_modules/syncable-sqlite/dist` to build output.

## PeerJS Server

```bash
npx peerjs --port 9000 --allow_discovery
```

Peer IDs format: `{dbName}-{uuid}` for auto-discovery.

## Types

```typescript
interface QueryResult {
  rows: Record<string, unknown>[];
  columns: string[];
  affectedRows?: AffectedRow[];
}

interface AffectedRow {
  id: string;
  table: string;
}

interface PeerInfo {
  id: string;
  status: 'connecting' | 'connected' | 'disconnected';
}

interface SyncOperation {
  id: string;
  timestamp: number;
  sql: string;
  params?: unknown[];  // bound parameters for the SQL
  table: string;
  rowId: string;
}

// React hook returns
interface QueryResult<T> {
  data: T[] | undefined;
  isLoading: boolean;
  error: Error | null;
  refetch: () => Promise<void>;
}

interface MutationResult<Row, Table> {
  insert: (data: InsertData<Table>) => Promise<Row | null>;
  update: (id: string, data: UpdateData<Table>) => Promise<Row | null>;
  remove: (id: string) => Promise<Row | null>;
  isLoading: boolean;
  error: Error | null;
}
```
