export declare const workerCode = "// node_modules/@sqlite.org/sqlite-wasm/sqlite-wasm/jswasm/sqlite3.mjs\nasync function sqlite3InitModule(moduleArg = {}) {\n  var moduleRtn;\n  var Module = moduleArg;\n  var ENVIRONMENT_IS_WEB = !!globalThis.window;\n  var ENVIRONMENT_IS_WORKER = !!globalThis.WorkerGlobalScope;\n  var ENVIRONMENT_IS_NODE = globalThis.process?.versions?.node && globalThis.process?.type != \"renderer\";\n  var ENVIRONMENT_IS_SHELL = !ENVIRONMENT_IS_WEB && !ENVIRONMENT_IS_NODE && !ENVIRONMENT_IS_WORKER;\n  (function(Module2) {\n    const sIMS = globalThis.sqlite3InitModuleState || Object.assign(/* @__PURE__ */ Object.create(null), {\n      debugModule: () => {\n        console.warn(\"globalThis.sqlite3InitModuleState is missing\");\n      }\n    });\n    delete globalThis.sqlite3InitModuleState;\n    sIMS.debugModule(\"pre-js.js sqlite3InitModuleState =\", sIMS);\n    Module2[\"locateFile\"] = function(path, prefix) {\n      return new URL(path, import.meta.url).href;\n    }.bind(sIMS);\n    Module2[\"instantiateWasm\"] = function callee3(imports, onSuccess) {\n      const sims = this;\n      const uri = Module2.locateFile(\n        sims.wasmFilename,\n        \"undefined\" === typeof scriptDirectory ? \"\" : scriptDirectory\n      );\n      sims.debugModule(\"instantiateWasm() uri =\", uri, \"sIMS =\", this);\n      const wfetch = () => fetch(uri, { credentials: \"same-origin\" });\n      const finalThen = (arg) => {\n        arg.imports = imports;\n        sims.instantiateWasm = arg;\n        onSuccess(arg.instance, arg.module);\n      };\n      const loadWasm = WebAssembly.instantiateStreaming ? async () => WebAssembly.instantiateStreaming(wfetch(), imports).then(finalThen) : async () => wfetch().then((response) => response.arrayBuffer()).then((bytes) => WebAssembly.instantiate(bytes, imports)).then(finalThen);\n      return loadWasm();\n    }.bind(sIMS);\n  })(Module);\n  var arguments_ = [];\n  var thisProgram = \"./this.program\";\n  var quit_ = (status, toThrow) => {\n    throw toThrow;\n  };\n  var _scriptName = import.meta.url;\n  var scriptDirectory = \"\";\n  function locateFile(path) {\n    if (Module[\"locateFile\"]) {\n      return Module[\"locateFile\"](path, scriptDirectory);\n    }\n    return scriptDirectory + path;\n  }\n  var readAsync, readBinary;\n  if (ENVIRONMENT_IS_WEB || ENVIRONMENT_IS_WORKER) {\n    try {\n      scriptDirectory = new URL(\".\", _scriptName).href;\n    } catch {\n    }\n    {\n      if (ENVIRONMENT_IS_WORKER) {\n        readBinary = (url) => {\n          var xhr = new XMLHttpRequest();\n          xhr.open(\"GET\", url, false);\n          xhr.responseType = \"arraybuffer\";\n          xhr.send(null);\n          return new Uint8Array(xhr.response);\n        };\n      }\n      readAsync = async (url) => {\n        var response = await fetch(url, { credentials: \"same-origin\" });\n        if (response.ok) {\n          return response.arrayBuffer();\n        }\n        throw new Error(response.status + \" : \" + response.url);\n      };\n    }\n  } else {\n  }\n  var out = console.log.bind(console);\n  var err = console.error.bind(console);\n  var wasmBinary;\n  var ABORT = false;\n  var EXITSTATUS;\n  function assert(condition, text) {\n    if (!condition) {\n      abort(text);\n    }\n  }\n  var isFileURI = (filename) => filename.startsWith(\"file://\");\n  var readyPromiseResolve, readyPromiseReject;\n  var HEAP8, HEAPU8, HEAP16, HEAPU16, HEAP32, HEAPU32, HEAPF32, HEAPF64;\n  var HEAP64, HEAPU64;\n  var runtimeInitialized = false;\n  function updateMemoryViews() {\n    var b = wasmMemory.buffer;\n    HEAP8 = new Int8Array(b);\n    HEAP16 = new Int16Array(b);\n    HEAPU8 = new Uint8Array(b);\n    HEAPU16 = new Uint16Array(b);\n    HEAP32 = new Int32Array(b);\n    HEAPU32 = new Uint32Array(b);\n    HEAPF32 = new Float32Array(b);\n    HEAPF64 = new Float64Array(b);\n    HEAP64 = new BigInt64Array(b);\n    HEAPU64 = new BigUint64Array(b);\n  }\n  function initMemory() {\n    if (Module[\"wasmMemory\"]) {\n      wasmMemory = Module[\"wasmMemory\"];\n    } else {\n      var INITIAL_MEMORY = Module[\"INITIAL_MEMORY\"] || 8388608;\n      wasmMemory = new WebAssembly.Memory({\n        initial: INITIAL_MEMORY / 65536,\n        maximum: 32768\n      });\n    }\n    updateMemoryViews();\n  }\n  function preRun() {\n    if (Module[\"preRun\"]) {\n      if (typeof Module[\"preRun\"] == \"function\")\n        Module[\"preRun\"] = [Module[\"preRun\"]];\n      while (Module[\"preRun\"].length) {\n        addOnPreRun(Module[\"preRun\"].shift());\n      }\n    }\n    callRuntimeCallbacks(onPreRuns);\n  }\n  function initRuntime() {\n    runtimeInitialized = true;\n    if (!Module[\"noFSInit\"] && !FS.initialized) FS.init();\n    TTY.init();\n    wasmExports[\"__wasm_call_ctors\"]();\n    FS.ignorePermissions = false;\n  }\n  function postRun() {\n    if (Module[\"postRun\"]) {\n      if (typeof Module[\"postRun\"] == \"function\")\n        Module[\"postRun\"] = [Module[\"postRun\"]];\n      while (Module[\"postRun\"].length) {\n        addOnPostRun(Module[\"postRun\"].shift());\n      }\n    }\n    callRuntimeCallbacks(onPostRuns);\n  }\n  function abort(what) {\n    Module[\"onAbort\"]?.(what);\n    what = \"Aborted(\" + what + \")\";\n    err(what);\n    ABORT = true;\n    what += \". Build with -sASSERTIONS for more info.\";\n    var e = new WebAssembly.RuntimeError(what);\n    readyPromiseReject?.(e);\n    throw e;\n  }\n  var wasmBinaryFile;\n  function findWasmBinary() {\n    if (Module[\"locateFile\"]) {\n      return locateFile(\"sqlite3.wasm\");\n    }\n    return new URL(\"sqlite3.wasm\", import.meta.url).href;\n  }\n  function getBinarySync(file) {\n    if (file == wasmBinaryFile && wasmBinary) {\n      return new Uint8Array(wasmBinary);\n    }\n    if (readBinary) {\n      return readBinary(file);\n    }\n    throw \"both async and sync fetching of the wasm failed\";\n  }\n  async function getWasmBinary(binaryFile) {\n    if (!wasmBinary) {\n      try {\n        var response = await readAsync(binaryFile);\n        return new Uint8Array(response);\n      } catch {\n      }\n    }\n    return getBinarySync(binaryFile);\n  }\n  async function instantiateArrayBuffer(binaryFile, imports) {\n    try {\n      var binary = await getWasmBinary(binaryFile);\n      var instance = await WebAssembly.instantiate(binary, imports);\n      return instance;\n    } catch (reason) {\n      err(`failed to asynchronously prepare wasm: ${reason}`);\n      abort(reason);\n    }\n  }\n  async function instantiateAsync(binary, binaryFile, imports) {\n    if (!binary) {\n      try {\n        var response = fetch(binaryFile, { credentials: \"same-origin\" });\n        var instantiationResult = await WebAssembly.instantiateStreaming(\n          response,\n          imports\n        );\n        return instantiationResult;\n      } catch (reason) {\n        err(`wasm streaming compile failed: ${reason}`);\n        err(\"falling back to ArrayBuffer instantiation\");\n      }\n    }\n    return instantiateArrayBuffer(binaryFile, imports);\n  }\n  function getWasmImports() {\n    var imports = {\n      env: wasmImports,\n      wasi_snapshot_preview1: wasmImports\n    };\n    return imports;\n  }\n  async function createWasm() {\n    function receiveInstance(instance, module) {\n      wasmExports = instance.exports;\n      assignWasmExports(wasmExports);\n      return wasmExports;\n    }\n    function receiveInstantiationResult(result2) {\n      return receiveInstance(result2[\"instance\"]);\n    }\n    var info = getWasmImports();\n    if (Module[\"instantiateWasm\"]) {\n      return new Promise((resolve, reject) => {\n        Module[\"instantiateWasm\"](info, (inst, mod) => {\n          resolve(receiveInstance(inst, mod));\n        });\n      });\n    }\n    wasmBinaryFile ??= findWasmBinary();\n    var result = await instantiateAsync(wasmBinary, wasmBinaryFile, info);\n    var exports = receiveInstantiationResult(result);\n    return exports;\n  }\n  class ExitStatus {\n    name = \"ExitStatus\";\n    constructor(status) {\n      this.message = `Program terminated with exit(${status})`;\n      this.status = status;\n    }\n  }\n  var callRuntimeCallbacks = (callbacks) => {\n    while (callbacks.length > 0) {\n      callbacks.shift()(Module);\n    }\n  };\n  var onPostRuns = [];\n  var addOnPostRun = (cb) => onPostRuns.push(cb);\n  var onPreRuns = [];\n  var addOnPreRun = (cb) => onPreRuns.push(cb);\n  function getValue(ptr, type = \"i8\") {\n    if (type.endsWith(\"*\")) type = \"*\";\n    switch (type) {\n      case \"i1\":\n        return HEAP8[ptr];\n      case \"i8\":\n        return HEAP8[ptr];\n      case \"i16\":\n        return HEAP16[ptr >> 1];\n      case \"i32\":\n        return HEAP32[ptr >> 2];\n      case \"i64\":\n        return HEAP64[ptr >> 3];\n      case \"float\":\n        return HEAPF32[ptr >> 2];\n      case \"double\":\n        return HEAPF64[ptr >> 3];\n      case \"*\":\n        return HEAPU32[ptr >> 2];\n      default:\n        abort(`invalid type for getValue: ${type}`);\n    }\n  }\n  var noExitRuntime = true;\n  function setValue(ptr, value, type = \"i8\") {\n    if (type.endsWith(\"*\")) type = \"*\";\n    switch (type) {\n      case \"i1\":\n        HEAP8[ptr] = value;\n        break;\n      case \"i8\":\n        HEAP8[ptr] = value;\n        break;\n      case \"i16\":\n        HEAP16[ptr >> 1] = value;\n        break;\n      case \"i32\":\n        HEAP32[ptr >> 2] = value;\n        break;\n      case \"i64\":\n        HEAP64[ptr >> 3] = BigInt(value);\n        break;\n      case \"float\":\n        HEAPF32[ptr >> 2] = value;\n        break;\n      case \"double\":\n        HEAPF64[ptr >> 3] = value;\n        break;\n      case \"*\":\n        HEAPU32[ptr >> 2] = value;\n        break;\n      default:\n        abort(`invalid type for setValue: ${type}`);\n    }\n  }\n  var stackRestore = (val) => __emscripten_stack_restore(val);\n  var stackSave = () => _emscripten_stack_get_current();\n  var wasmMemory;\n  var PATH = {\n    isAbs: (path) => path.charAt(0) === \"/\",\n    splitPath: (filename) => {\n      var splitPathRe = /^(\\/?|)([\\s\\S]*?)((?:\\.{1,2}|[^\\/]+?|)(\\.[^.\\/]*|))(?:[\\/]*)$/;\n      return splitPathRe.exec(filename).slice(1);\n    },\n    normalizeArray: (parts, allowAboveRoot) => {\n      var up = 0;\n      for (var i = parts.length - 1; i >= 0; i--) {\n        var last = parts[i];\n        if (last === \".\") {\n          parts.splice(i, 1);\n        } else if (last === \"..\") {\n          parts.splice(i, 1);\n          up++;\n        } else if (up) {\n          parts.splice(i, 1);\n          up--;\n        }\n      }\n      if (allowAboveRoot) {\n        for (; up; up--) {\n          parts.unshift(\"..\");\n        }\n      }\n      return parts;\n    },\n    normalize: (path) => {\n      var isAbsolute = PATH.isAbs(path), trailingSlash = path.slice(-1) === \"/\";\n      path = PATH.normalizeArray(\n        path.split(\"/\").filter((p) => !!p),\n        !isAbsolute\n      ).join(\"/\");\n      if (!path && !isAbsolute) {\n        path = \".\";\n      }\n      if (path && trailingSlash) {\n        path += \"/\";\n      }\n      return (isAbsolute ? \"/\" : \"\") + path;\n    },\n    dirname: (path) => {\n      var result = PATH.splitPath(path), root = result[0], dir = result[1];\n      if (!root && !dir) {\n        return \".\";\n      }\n      if (dir) {\n        dir = dir.slice(0, -1);\n      }\n      return root + dir;\n    },\n    basename: (path) => path && path.match(/([^\\/]+|\\/)\\/*$/)[1],\n    join: (...paths) => PATH.normalize(paths.join(\"/\")),\n    join2: (l, r) => PATH.normalize(l + \"/\" + r)\n  };\n  var initRandomFill = () => {\n    return (view) => crypto.getRandomValues(view);\n  };\n  var randomFill = (view) => {\n    (randomFill = initRandomFill())(view);\n  };\n  var PATH_FS = {\n    resolve: (...args) => {\n      var resolvedPath = \"\", resolvedAbsolute = false;\n      for (var i = args.length - 1; i >= -1 && !resolvedAbsolute; i--) {\n        var path = i >= 0 ? args[i] : FS.cwd();\n        if (typeof path != \"string\") {\n          throw new TypeError(\"Arguments to path.resolve must be strings\");\n        } else if (!path) {\n          return \"\";\n        }\n        resolvedPath = path + \"/\" + resolvedPath;\n        resolvedAbsolute = PATH.isAbs(path);\n      }\n      resolvedPath = PATH.normalizeArray(\n        resolvedPath.split(\"/\").filter((p) => !!p),\n        !resolvedAbsolute\n      ).join(\"/\");\n      return (resolvedAbsolute ? \"/\" : \"\") + resolvedPath || \".\";\n    },\n    relative: (from, to) => {\n      from = PATH_FS.resolve(from).slice(1);\n      to = PATH_FS.resolve(to).slice(1);\n      function trim(arr) {\n        var start = 0;\n        for (; start < arr.length; start++) {\n          if (arr[start] !== \"\") break;\n        }\n        var end = arr.length - 1;\n        for (; end >= 0; end--) {\n          if (arr[end] !== \"\") break;\n        }\n        if (start > end) return [];\n        return arr.slice(start, end - start + 1);\n      }\n      var fromParts = trim(from.split(\"/\"));\n      var toParts = trim(to.split(\"/\"));\n      var length = Math.min(fromParts.length, toParts.length);\n      var samePartsLength = length;\n      for (var i = 0; i < length; i++) {\n        if (fromParts[i] !== toParts[i]) {\n          samePartsLength = i;\n          break;\n        }\n      }\n      var outputParts = [];\n      for (var i = samePartsLength; i < fromParts.length; i++) {\n        outputParts.push(\"..\");\n      }\n      outputParts = outputParts.concat(toParts.slice(samePartsLength));\n      return outputParts.join(\"/\");\n    }\n  };\n  var UTF8Decoder = new TextDecoder();\n  var findStringEnd = (heapOrArray, idx, maxBytesToRead, ignoreNul) => {\n    var maxIdx = idx + maxBytesToRead;\n    if (ignoreNul) return maxIdx;\n    while (heapOrArray[idx] && !(idx >= maxIdx)) ++idx;\n    return idx;\n  };\n  var UTF8ArrayToString = (heapOrArray, idx = 0, maxBytesToRead, ignoreNul) => {\n    var endPtr = findStringEnd(heapOrArray, idx, maxBytesToRead, ignoreNul);\n    return UTF8Decoder.decode(\n      heapOrArray.buffer ? heapOrArray.subarray(idx, endPtr) : new Uint8Array(heapOrArray.slice(idx, endPtr))\n    );\n  };\n  var FS_stdin_getChar_buffer = [];\n  var lengthBytesUTF8 = (str) => {\n    var len = 0;\n    for (var i = 0; i < str.length; ++i) {\n      var c = str.charCodeAt(i);\n      if (c <= 127) {\n        len++;\n      } else if (c <= 2047) {\n        len += 2;\n      } else if (c >= 55296 && c <= 57343) {\n        len += 4;\n        ++i;\n      } else {\n        len += 3;\n      }\n    }\n    return len;\n  };\n  var stringToUTF8Array = (str, heap, outIdx, maxBytesToWrite) => {\n    if (!(maxBytesToWrite > 0)) return 0;\n    var startIdx = outIdx;\n    var endIdx = outIdx + maxBytesToWrite - 1;\n    for (var i = 0; i < str.length; ++i) {\n      var u = str.codePointAt(i);\n      if (u <= 127) {\n        if (outIdx >= endIdx) break;\n        heap[outIdx++] = u;\n      } else if (u <= 2047) {\n        if (outIdx + 1 >= endIdx) break;\n        heap[outIdx++] = 192 | u >> 6;\n        heap[outIdx++] = 128 | u & 63;\n      } else if (u <= 65535) {\n        if (outIdx + 2 >= endIdx) break;\n        heap[outIdx++] = 224 | u >> 12;\n        heap[outIdx++] = 128 | u >> 6 & 63;\n        heap[outIdx++] = 128 | u & 63;\n      } else {\n        if (outIdx + 3 >= endIdx) break;\n        heap[outIdx++] = 240 | u >> 18;\n        heap[outIdx++] = 128 | u >> 12 & 63;\n        heap[outIdx++] = 128 | u >> 6 & 63;\n        heap[outIdx++] = 128 | u & 63;\n        i++;\n      }\n    }\n    heap[outIdx] = 0;\n    return outIdx - startIdx;\n  };\n  var intArrayFromString = (stringy, dontAddNull, length) => {\n    var len = length > 0 ? length : lengthBytesUTF8(stringy) + 1;\n    var u8array = new Array(len);\n    var numBytesWritten = stringToUTF8Array(\n      stringy,\n      u8array,\n      0,\n      u8array.length\n    );\n    if (dontAddNull) u8array.length = numBytesWritten;\n    return u8array;\n  };\n  var FS_stdin_getChar = () => {\n    if (!FS_stdin_getChar_buffer.length) {\n      var result = null;\n      if (globalThis.window?.prompt) {\n        result = window.prompt(\"Input: \");\n        if (result !== null) {\n          result += \"\\n\";\n        }\n      } else {\n      }\n      if (!result) {\n        return null;\n      }\n      FS_stdin_getChar_buffer = intArrayFromString(result, true);\n    }\n    return FS_stdin_getChar_buffer.shift();\n  };\n  var TTY = {\n    ttys: [],\n    init() {\n    },\n    shutdown() {\n    },\n    register(dev, ops) {\n      TTY.ttys[dev] = { input: [], output: [], ops };\n      FS.registerDevice(dev, TTY.stream_ops);\n    },\n    stream_ops: {\n      open(stream) {\n        var tty = TTY.ttys[stream.node.rdev];\n        if (!tty) {\n          throw new FS.ErrnoError(43);\n        }\n        stream.tty = tty;\n        stream.seekable = false;\n      },\n      close(stream) {\n        stream.tty.ops.fsync(stream.tty);\n      },\n      fsync(stream) {\n        stream.tty.ops.fsync(stream.tty);\n      },\n      read(stream, buffer, offset, length, pos) {\n        if (!stream.tty || !stream.tty.ops.get_char) {\n          throw new FS.ErrnoError(60);\n        }\n        var bytesRead = 0;\n        for (var i = 0; i < length; i++) {\n          var result;\n          try {\n            result = stream.tty.ops.get_char(stream.tty);\n          } catch (e) {\n            throw new FS.ErrnoError(29);\n          }\n          if (result === void 0 && bytesRead === 0) {\n            throw new FS.ErrnoError(6);\n          }\n          if (result === null || result === void 0) break;\n          bytesRead++;\n          buffer[offset + i] = result;\n        }\n        if (bytesRead) {\n          stream.node.atime = Date.now();\n        }\n        return bytesRead;\n      },\n      write(stream, buffer, offset, length, pos) {\n        if (!stream.tty || !stream.tty.ops.put_char) {\n          throw new FS.ErrnoError(60);\n        }\n        try {\n          for (var i = 0; i < length; i++) {\n            stream.tty.ops.put_char(stream.tty, buffer[offset + i]);\n          }\n        } catch (e) {\n          throw new FS.ErrnoError(29);\n        }\n        if (length) {\n          stream.node.mtime = stream.node.ctime = Date.now();\n        }\n        return i;\n      }\n    },\n    default_tty_ops: {\n      get_char(tty) {\n        return FS_stdin_getChar();\n      },\n      put_char(tty, val) {\n        if (val === null || val === 10) {\n          out(UTF8ArrayToString(tty.output));\n          tty.output = [];\n        } else {\n          if (val != 0) tty.output.push(val);\n        }\n      },\n      fsync(tty) {\n        if (tty.output?.length > 0) {\n          out(UTF8ArrayToString(tty.output));\n          tty.output = [];\n        }\n      },\n      ioctl_tcgets(tty) {\n        return {\n          c_iflag: 25856,\n          c_oflag: 5,\n          c_cflag: 191,\n          c_lflag: 35387,\n          c_cc: [\n            3,\n            28,\n            127,\n            21,\n            4,\n            0,\n            1,\n            0,\n            17,\n            19,\n            26,\n            0,\n            18,\n            15,\n            23,\n            22,\n            0,\n            0,\n            0,\n            0,\n            0,\n            0,\n            0,\n            0,\n            0,\n            0,\n            0,\n            0,\n            0,\n            0,\n            0,\n            0\n          ]\n        };\n      },\n      ioctl_tcsets(tty, optional_actions, data) {\n        return 0;\n      },\n      ioctl_tiocgwinsz(tty) {\n        return [24, 80];\n      }\n    },\n    default_tty1_ops: {\n      put_char(tty, val) {\n        if (val === null || val === 10) {\n          err(UTF8ArrayToString(tty.output));\n          tty.output = [];\n        } else {\n          if (val != 0) tty.output.push(val);\n        }\n      },\n      fsync(tty) {\n        if (tty.output?.length > 0) {\n          err(UTF8ArrayToString(tty.output));\n          tty.output = [];\n        }\n      }\n    }\n  };\n  var zeroMemory = (ptr, size) => HEAPU8.fill(0, ptr, ptr + size);\n  var alignMemory = (size, alignment) => {\n    return Math.ceil(size / alignment) * alignment;\n  };\n  var mmapAlloc = (size) => {\n    size = alignMemory(size, 65536);\n    var ptr = _emscripten_builtin_memalign(65536, size);\n    if (ptr) zeroMemory(ptr, size);\n    return ptr;\n  };\n  var MEMFS = {\n    ops_table: null,\n    mount(mount) {\n      return MEMFS.createNode(null, \"/\", 16895, 0);\n    },\n    createNode(parent, name, mode, dev) {\n      if (FS.isBlkdev(mode) || FS.isFIFO(mode)) {\n        throw new FS.ErrnoError(63);\n      }\n      MEMFS.ops_table ||= {\n        dir: {\n          node: {\n            getattr: MEMFS.node_ops.getattr,\n            setattr: MEMFS.node_ops.setattr,\n            lookup: MEMFS.node_ops.lookup,\n            mknod: MEMFS.node_ops.mknod,\n            rename: MEMFS.node_ops.rename,\n            unlink: MEMFS.node_ops.unlink,\n            rmdir: MEMFS.node_ops.rmdir,\n            readdir: MEMFS.node_ops.readdir,\n            symlink: MEMFS.node_ops.symlink\n          },\n          stream: {\n            llseek: MEMFS.stream_ops.llseek\n          }\n        },\n        file: {\n          node: {\n            getattr: MEMFS.node_ops.getattr,\n            setattr: MEMFS.node_ops.setattr\n          },\n          stream: {\n            llseek: MEMFS.stream_ops.llseek,\n            read: MEMFS.stream_ops.read,\n            write: MEMFS.stream_ops.write,\n            mmap: MEMFS.stream_ops.mmap,\n            msync: MEMFS.stream_ops.msync\n          }\n        },\n        link: {\n          node: {\n            getattr: MEMFS.node_ops.getattr,\n            setattr: MEMFS.node_ops.setattr,\n            readlink: MEMFS.node_ops.readlink\n          },\n          stream: {}\n        },\n        chrdev: {\n          node: {\n            getattr: MEMFS.node_ops.getattr,\n            setattr: MEMFS.node_ops.setattr\n          },\n          stream: FS.chrdev_stream_ops\n        }\n      };\n      var node = FS.createNode(parent, name, mode, dev);\n      if (FS.isDir(node.mode)) {\n        node.node_ops = MEMFS.ops_table.dir.node;\n        node.stream_ops = MEMFS.ops_table.dir.stream;\n        node.contents = {};\n      } else if (FS.isFile(node.mode)) {\n        node.node_ops = MEMFS.ops_table.file.node;\n        node.stream_ops = MEMFS.ops_table.file.stream;\n        node.usedBytes = 0;\n        node.contents = null;\n      } else if (FS.isLink(node.mode)) {\n        node.node_ops = MEMFS.ops_table.link.node;\n        node.stream_ops = MEMFS.ops_table.link.stream;\n      } else if (FS.isChrdev(node.mode)) {\n        node.node_ops = MEMFS.ops_table.chrdev.node;\n        node.stream_ops = MEMFS.ops_table.chrdev.stream;\n      }\n      node.atime = node.mtime = node.ctime = Date.now();\n      if (parent) {\n        parent.contents[name] = node;\n        parent.atime = parent.mtime = parent.ctime = node.atime;\n      }\n      return node;\n    },\n    getFileDataAsTypedArray(node) {\n      if (!node.contents) return new Uint8Array(0);\n      if (node.contents.subarray)\n        return node.contents.subarray(0, node.usedBytes);\n      return new Uint8Array(node.contents);\n    },\n    expandFileStorage(node, newCapacity) {\n      var prevCapacity = node.contents ? node.contents.length : 0;\n      if (prevCapacity >= newCapacity) return;\n      var CAPACITY_DOUBLING_MAX = 1024 * 1024;\n      newCapacity = Math.max(\n        newCapacity,\n        prevCapacity * (prevCapacity < CAPACITY_DOUBLING_MAX ? 2 : 1.125) >>> 0\n      );\n      if (prevCapacity != 0) newCapacity = Math.max(newCapacity, 256);\n      var oldContents = node.contents;\n      node.contents = new Uint8Array(newCapacity);\n      if (node.usedBytes > 0)\n        node.contents.set(oldContents.subarray(0, node.usedBytes), 0);\n    },\n    resizeFileStorage(node, newSize) {\n      if (node.usedBytes == newSize) return;\n      if (newSize == 0) {\n        node.contents = null;\n        node.usedBytes = 0;\n      } else {\n        var oldContents = node.contents;\n        node.contents = new Uint8Array(newSize);\n        if (oldContents) {\n          node.contents.set(\n            oldContents.subarray(0, Math.min(newSize, node.usedBytes))\n          );\n        }\n        node.usedBytes = newSize;\n      }\n    },\n    node_ops: {\n      getattr(node) {\n        var attr = {};\n        attr.dev = FS.isChrdev(node.mode) ? node.id : 1;\n        attr.ino = node.id;\n        attr.mode = node.mode;\n        attr.nlink = 1;\n        attr.uid = 0;\n        attr.gid = 0;\n        attr.rdev = node.rdev;\n        if (FS.isDir(node.mode)) {\n          attr.size = 4096;\n        } else if (FS.isFile(node.mode)) {\n          attr.size = node.usedBytes;\n        } else if (FS.isLink(node.mode)) {\n          attr.size = node.link.length;\n        } else {\n          attr.size = 0;\n        }\n        attr.atime = new Date(node.atime);\n        attr.mtime = new Date(node.mtime);\n        attr.ctime = new Date(node.ctime);\n        attr.blksize = 4096;\n        attr.blocks = Math.ceil(attr.size / attr.blksize);\n        return attr;\n      },\n      setattr(node, attr) {\n        for (const key of [\"mode\", \"atime\", \"mtime\", \"ctime\"]) {\n          if (attr[key] != null) {\n            node[key] = attr[key];\n          }\n        }\n        if (attr.size !== void 0) {\n          MEMFS.resizeFileStorage(node, attr.size);\n        }\n      },\n      lookup(parent, name) {\n        if (!MEMFS.doesNotExistError) {\n          MEMFS.doesNotExistError = new FS.ErrnoError(44);\n          MEMFS.doesNotExistError.stack = \"<generic error, no stack>\";\n        }\n        throw MEMFS.doesNotExistError;\n      },\n      mknod(parent, name, mode, dev) {\n        return MEMFS.createNode(parent, name, mode, dev);\n      },\n      rename(old_node, new_dir, new_name) {\n        var new_node;\n        try {\n          new_node = FS.lookupNode(new_dir, new_name);\n        } catch (e) {\n        }\n        if (new_node) {\n          if (FS.isDir(old_node.mode)) {\n            for (var i in new_node.contents) {\n              throw new FS.ErrnoError(55);\n            }\n          }\n          FS.hashRemoveNode(new_node);\n        }\n        delete old_node.parent.contents[old_node.name];\n        new_dir.contents[new_name] = old_node;\n        old_node.name = new_name;\n        new_dir.ctime = new_dir.mtime = old_node.parent.ctime = old_node.parent.mtime = Date.now();\n      },\n      unlink(parent, name) {\n        delete parent.contents[name];\n        parent.ctime = parent.mtime = Date.now();\n      },\n      rmdir(parent, name) {\n        var node = FS.lookupNode(parent, name);\n        for (var i in node.contents) {\n          throw new FS.ErrnoError(55);\n        }\n        delete parent.contents[name];\n        parent.ctime = parent.mtime = Date.now();\n      },\n      readdir(node) {\n        return [\".\", \"..\", ...Object.keys(node.contents)];\n      },\n      symlink(parent, newname, oldpath) {\n        var node = MEMFS.createNode(parent, newname, 511 | 40960, 0);\n        node.link = oldpath;\n        return node;\n      },\n      readlink(node) {\n        if (!FS.isLink(node.mode)) {\n          throw new FS.ErrnoError(28);\n        }\n        return node.link;\n      }\n    },\n    stream_ops: {\n      read(stream, buffer, offset, length, position) {\n        var contents = stream.node.contents;\n        if (position >= stream.node.usedBytes) return 0;\n        var size = Math.min(stream.node.usedBytes - position, length);\n        if (size > 8 && contents.subarray) {\n          buffer.set(contents.subarray(position, position + size), offset);\n        } else {\n          for (var i = 0; i < size; i++)\n            buffer[offset + i] = contents[position + i];\n        }\n        return size;\n      },\n      write(stream, buffer, offset, length, position, canOwn) {\n        if (buffer.buffer === HEAP8.buffer) {\n          canOwn = false;\n        }\n        if (!length) return 0;\n        var node = stream.node;\n        node.mtime = node.ctime = Date.now();\n        if (buffer.subarray && (!node.contents || node.contents.subarray)) {\n          if (canOwn) {\n            node.contents = buffer.subarray(offset, offset + length);\n            node.usedBytes = length;\n            return length;\n          } else if (node.usedBytes === 0 && position === 0) {\n            node.contents = buffer.slice(offset, offset + length);\n            node.usedBytes = length;\n            return length;\n          } else if (position + length <= node.usedBytes) {\n            node.contents.set(\n              buffer.subarray(offset, offset + length),\n              position\n            );\n            return length;\n          }\n        }\n        MEMFS.expandFileStorage(node, position + length);\n        if (node.contents.subarray && buffer.subarray) {\n          node.contents.set(buffer.subarray(offset, offset + length), position);\n        } else {\n          for (var i = 0; i < length; i++) {\n            node.contents[position + i] = buffer[offset + i];\n          }\n        }\n        node.usedBytes = Math.max(node.usedBytes, position + length);\n        return length;\n      },\n      llseek(stream, offset, whence) {\n        var position = offset;\n        if (whence === 1) {\n          position += stream.position;\n        } else if (whence === 2) {\n          if (FS.isFile(stream.node.mode)) {\n            position += stream.node.usedBytes;\n          }\n        }\n        if (position < 0) {\n          throw new FS.ErrnoError(28);\n        }\n        return position;\n      },\n      mmap(stream, length, position, prot, flags) {\n        if (!FS.isFile(stream.node.mode)) {\n          throw new FS.ErrnoError(43);\n        }\n        var ptr;\n        var allocated;\n        var contents = stream.node.contents;\n        if (!(flags & 2) && contents && contents.buffer === HEAP8.buffer) {\n          allocated = false;\n          ptr = contents.byteOffset;\n        } else {\n          allocated = true;\n          ptr = mmapAlloc(length);\n          if (!ptr) {\n            throw new FS.ErrnoError(48);\n          }\n          if (contents) {\n            if (position > 0 || position + length < contents.length) {\n              if (contents.subarray) {\n                contents = contents.subarray(position, position + length);\n              } else {\n                contents = Array.prototype.slice.call(\n                  contents,\n                  position,\n                  position + length\n                );\n              }\n            }\n            HEAP8.set(contents, ptr);\n          }\n        }\n        return { ptr, allocated };\n      },\n      msync(stream, buffer, offset, length, mmapFlags) {\n        MEMFS.stream_ops.write(stream, buffer, 0, length, offset, false);\n        return 0;\n      }\n    }\n  };\n  var FS_modeStringToFlags = (str) => {\n    var flagModes = {\n      r: 0,\n      \"r+\": 2,\n      w: 512 | 64 | 1,\n      \"w+\": 512 | 64 | 2,\n      a: 1024 | 64 | 1,\n      \"a+\": 1024 | 64 | 2\n    };\n    var flags = flagModes[str];\n    if (typeof flags == \"undefined\") {\n      throw new Error(`Unknown file open mode: ${str}`);\n    }\n    return flags;\n  };\n  var FS_getMode = (canRead, canWrite) => {\n    var mode = 0;\n    if (canRead) mode |= 292 | 73;\n    if (canWrite) mode |= 146;\n    return mode;\n  };\n  var asyncLoad = async (url) => {\n    var arrayBuffer = await readAsync(url);\n    return new Uint8Array(arrayBuffer);\n  };\n  var FS_createDataFile = (...args) => FS.createDataFile(...args);\n  var getUniqueRunDependency = (id) => {\n    return id;\n  };\n  var runDependencies = 0;\n  var dependenciesFulfilled = null;\n  var removeRunDependency = (id) => {\n    runDependencies--;\n    Module[\"monitorRunDependencies\"]?.(runDependencies);\n    if (runDependencies == 0) {\n      if (dependenciesFulfilled) {\n        var callback = dependenciesFulfilled;\n        dependenciesFulfilled = null;\n        callback();\n      }\n    }\n  };\n  var addRunDependency = (id) => {\n    runDependencies++;\n    Module[\"monitorRunDependencies\"]?.(runDependencies);\n  };\n  var preloadPlugins = [];\n  var FS_handledByPreloadPlugin = async (byteArray, fullname) => {\n    if (typeof Browser != \"undefined\") Browser.init();\n    for (var plugin of preloadPlugins) {\n      if (plugin[\"canHandle\"](fullname)) {\n        return plugin[\"handle\"](byteArray, fullname);\n      }\n    }\n    return byteArray;\n  };\n  var FS_preloadFile = async (parent, name, url, canRead, canWrite, dontCreateFile, canOwn, preFinish) => {\n    var fullname = name ? PATH_FS.resolve(PATH.join2(parent, name)) : parent;\n    var dep = getUniqueRunDependency(`cp ${fullname}`);\n    addRunDependency(dep);\n    try {\n      var byteArray = url;\n      if (typeof url == \"string\") {\n        byteArray = await asyncLoad(url);\n      }\n      byteArray = await FS_handledByPreloadPlugin(byteArray, fullname);\n      preFinish?.();\n      if (!dontCreateFile) {\n        FS_createDataFile(parent, name, byteArray, canRead, canWrite, canOwn);\n      }\n    } finally {\n      removeRunDependency(dep);\n    }\n  };\n  var FS_createPreloadedFile = (parent, name, url, canRead, canWrite, onload, onerror, dontCreateFile, canOwn, preFinish) => {\n    FS_preloadFile(\n      parent,\n      name,\n      url,\n      canRead,\n      canWrite,\n      dontCreateFile,\n      canOwn,\n      preFinish\n    ).then(onload).catch(onerror);\n  };\n  var FS = {\n    root: null,\n    mounts: [],\n    devices: {},\n    streams: [],\n    nextInode: 1,\n    nameTable: null,\n    currentPath: \"/\",\n    initialized: false,\n    ignorePermissions: true,\n    filesystems: null,\n    syncFSRequests: 0,\n    readFiles: {},\n    ErrnoError: class {\n      name = \"ErrnoError\";\n      constructor(errno) {\n        this.errno = errno;\n      }\n    },\n    FSStream: class {\n      shared = {};\n      get object() {\n        return this.node;\n      }\n      set object(val) {\n        this.node = val;\n      }\n      get isRead() {\n        return (this.flags & 2097155) !== 1;\n      }\n      get isWrite() {\n        return (this.flags & 2097155) !== 0;\n      }\n      get isAppend() {\n        return this.flags & 1024;\n      }\n      get flags() {\n        return this.shared.flags;\n      }\n      set flags(val) {\n        this.shared.flags = val;\n      }\n      get position() {\n        return this.shared.position;\n      }\n      set position(val) {\n        this.shared.position = val;\n      }\n    },\n    FSNode: class {\n      node_ops = {};\n      stream_ops = {};\n      readMode = 292 | 73;\n      writeMode = 146;\n      mounted = null;\n      constructor(parent, name, mode, rdev) {\n        if (!parent) {\n          parent = this;\n        }\n        this.parent = parent;\n        this.mount = parent.mount;\n        this.id = FS.nextInode++;\n        this.name = name;\n        this.mode = mode;\n        this.rdev = rdev;\n        this.atime = this.mtime = this.ctime = Date.now();\n      }\n      get read() {\n        return (this.mode & this.readMode) === this.readMode;\n      }\n      set read(val) {\n        val ? this.mode |= this.readMode : this.mode &= ~this.readMode;\n      }\n      get write() {\n        return (this.mode & this.writeMode) === this.writeMode;\n      }\n      set write(val) {\n        val ? this.mode |= this.writeMode : this.mode &= ~this.writeMode;\n      }\n      get isFolder() {\n        return FS.isDir(this.mode);\n      }\n      get isDevice() {\n        return FS.isChrdev(this.mode);\n      }\n    },\n    lookupPath(path, opts = {}) {\n      if (!path) {\n        throw new FS.ErrnoError(44);\n      }\n      opts.follow_mount ??= true;\n      if (!PATH.isAbs(path)) {\n        path = FS.cwd() + \"/\" + path;\n      }\n      linkloop: for (var nlinks = 0; nlinks < 40; nlinks++) {\n        var parts = path.split(\"/\").filter((p) => !!p);\n        var current = FS.root;\n        var current_path = \"/\";\n        for (var i = 0; i < parts.length; i++) {\n          var islast = i === parts.length - 1;\n          if (islast && opts.parent) {\n            break;\n          }\n          if (parts[i] === \".\") {\n            continue;\n          }\n          if (parts[i] === \"..\") {\n            current_path = PATH.dirname(current_path);\n            if (FS.isRoot(current)) {\n              path = current_path + \"/\" + parts.slice(i + 1).join(\"/\");\n              nlinks--;\n              continue linkloop;\n            } else {\n              current = current.parent;\n            }\n            continue;\n          }\n          current_path = PATH.join2(current_path, parts[i]);\n          try {\n            current = FS.lookupNode(current, parts[i]);\n          } catch (e) {\n            if (e?.errno === 44 && islast && opts.noent_okay) {\n              return { path: current_path };\n            }\n            throw e;\n          }\n          if (FS.isMountpoint(current) && (!islast || opts.follow_mount)) {\n            current = current.mounted.root;\n          }\n          if (FS.isLink(current.mode) && (!islast || opts.follow)) {\n            if (!current.node_ops.readlink) {\n              throw new FS.ErrnoError(52);\n            }\n            var link = current.node_ops.readlink(current);\n            if (!PATH.isAbs(link)) {\n              link = PATH.dirname(current_path) + \"/\" + link;\n            }\n            path = link + \"/\" + parts.slice(i + 1).join(\"/\");\n            continue linkloop;\n          }\n        }\n        return { path: current_path, node: current };\n      }\n      throw new FS.ErrnoError(32);\n    },\n    getPath(node) {\n      var path;\n      while (true) {\n        if (FS.isRoot(node)) {\n          var mount = node.mount.mountpoint;\n          if (!path) return mount;\n          return mount[mount.length - 1] !== \"/\" ? `${mount}/${path}` : mount + path;\n        }\n        path = path ? `${node.name}/${path}` : node.name;\n        node = node.parent;\n      }\n    },\n    hashName(parentid, name) {\n      var hash = 0;\n      for (var i = 0; i < name.length; i++) {\n        hash = (hash << 5) - hash + name.charCodeAt(i) | 0;\n      }\n      return (parentid + hash >>> 0) % FS.nameTable.length;\n    },\n    hashAddNode(node) {\n      var hash = FS.hashName(node.parent.id, node.name);\n      node.name_next = FS.nameTable[hash];\n      FS.nameTable[hash] = node;\n    },\n    hashRemoveNode(node) {\n      var hash = FS.hashName(node.parent.id, node.name);\n      if (FS.nameTable[hash] === node) {\n        FS.nameTable[hash] = node.name_next;\n      } else {\n        var current = FS.nameTable[hash];\n        while (current) {\n          if (current.name_next === node) {\n            current.name_next = node.name_next;\n            break;\n          }\n          current = current.name_next;\n        }\n      }\n    },\n    lookupNode(parent, name) {\n      var errCode = FS.mayLookup(parent);\n      if (errCode) {\n        throw new FS.ErrnoError(errCode);\n      }\n      var hash = FS.hashName(parent.id, name);\n      for (var node = FS.nameTable[hash]; node; node = node.name_next) {\n        var nodeName = node.name;\n        if (node.parent.id === parent.id && nodeName === name) {\n          return node;\n        }\n      }\n      return FS.lookup(parent, name);\n    },\n    createNode(parent, name, mode, rdev) {\n      var node = new FS.FSNode(parent, name, mode, rdev);\n      FS.hashAddNode(node);\n      return node;\n    },\n    destroyNode(node) {\n      FS.hashRemoveNode(node);\n    },\n    isRoot(node) {\n      return node === node.parent;\n    },\n    isMountpoint(node) {\n      return !!node.mounted;\n    },\n    isFile(mode) {\n      return (mode & 61440) === 32768;\n    },\n    isDir(mode) {\n      return (mode & 61440) === 16384;\n    },\n    isLink(mode) {\n      return (mode & 61440) === 40960;\n    },\n    isChrdev(mode) {\n      return (mode & 61440) === 8192;\n    },\n    isBlkdev(mode) {\n      return (mode & 61440) === 24576;\n    },\n    isFIFO(mode) {\n      return (mode & 61440) === 4096;\n    },\n    isSocket(mode) {\n      return (mode & 49152) === 49152;\n    },\n    flagsToPermissionString(flag) {\n      var perms = [\"r\", \"w\", \"rw\"][flag & 3];\n      if (flag & 512) {\n        perms += \"w\";\n      }\n      return perms;\n    },\n    nodePermissions(node, perms) {\n      if (FS.ignorePermissions) {\n        return 0;\n      }\n      if (perms.includes(\"r\") && !(node.mode & 292)) {\n        return 2;\n      } else if (perms.includes(\"w\") && !(node.mode & 146)) {\n        return 2;\n      } else if (perms.includes(\"x\") && !(node.mode & 73)) {\n        return 2;\n      }\n      return 0;\n    },\n    mayLookup(dir) {\n      if (!FS.isDir(dir.mode)) return 54;\n      var errCode = FS.nodePermissions(dir, \"x\");\n      if (errCode) return errCode;\n      if (!dir.node_ops.lookup) return 2;\n      return 0;\n    },\n    mayCreate(dir, name) {\n      if (!FS.isDir(dir.mode)) {\n        return 54;\n      }\n      try {\n        var node = FS.lookupNode(dir, name);\n        return 20;\n      } catch (e) {\n      }\n      return FS.nodePermissions(dir, \"wx\");\n    },\n    mayDelete(dir, name, isdir) {\n      var node;\n      try {\n        node = FS.lookupNode(dir, name);\n      } catch (e) {\n        return e.errno;\n      }\n      var errCode = FS.nodePermissions(dir, \"wx\");\n      if (errCode) {\n        return errCode;\n      }\n      if (isdir) {\n        if (!FS.isDir(node.mode)) {\n          return 54;\n        }\n        if (FS.isRoot(node) || FS.getPath(node) === FS.cwd()) {\n          return 10;\n        }\n      } else {\n        if (FS.isDir(node.mode)) {\n          return 31;\n        }\n      }\n      return 0;\n    },\n    mayOpen(node, flags) {\n      if (!node) {\n        return 44;\n      }\n      if (FS.isLink(node.mode)) {\n        return 32;\n      } else if (FS.isDir(node.mode)) {\n        if (FS.flagsToPermissionString(flags) !== \"r\" || flags & (512 | 64)) {\n          return 31;\n        }\n      }\n      return FS.nodePermissions(node, FS.flagsToPermissionString(flags));\n    },\n    checkOpExists(op, err2) {\n      if (!op) {\n        throw new FS.ErrnoError(err2);\n      }\n      return op;\n    },\n    MAX_OPEN_FDS: 4096,\n    nextfd() {\n      for (var fd = 0; fd <= FS.MAX_OPEN_FDS; fd++) {\n        if (!FS.streams[fd]) {\n          return fd;\n        }\n      }\n      throw new FS.ErrnoError(33);\n    },\n    getStreamChecked(fd) {\n      var stream = FS.getStream(fd);\n      if (!stream) {\n        throw new FS.ErrnoError(8);\n      }\n      return stream;\n    },\n    getStream: (fd) => FS.streams[fd],\n    createStream(stream, fd = -1) {\n      stream = Object.assign(new FS.FSStream(), stream);\n      if (fd == -1) {\n        fd = FS.nextfd();\n      }\n      stream.fd = fd;\n      FS.streams[fd] = stream;\n      return stream;\n    },\n    closeStream(fd) {\n      FS.streams[fd] = null;\n    },\n    dupStream(origStream, fd = -1) {\n      var stream = FS.createStream(origStream, fd);\n      stream.stream_ops?.dup?.(stream);\n      return stream;\n    },\n    doSetAttr(stream, node, attr) {\n      var setattr = stream?.stream_ops.setattr;\n      var arg = setattr ? stream : node;\n      setattr ??= node.node_ops.setattr;\n      FS.checkOpExists(setattr, 63);\n      setattr(arg, attr);\n    },\n    chrdev_stream_ops: {\n      open(stream) {\n        var device = FS.getDevice(stream.node.rdev);\n        stream.stream_ops = device.stream_ops;\n        stream.stream_ops.open?.(stream);\n      },\n      llseek() {\n        throw new FS.ErrnoError(70);\n      }\n    },\n    major: (dev) => dev >> 8,\n    minor: (dev) => dev & 255,\n    makedev: (ma, mi) => ma << 8 | mi,\n    registerDevice(dev, ops) {\n      FS.devices[dev] = { stream_ops: ops };\n    },\n    getDevice: (dev) => FS.devices[dev],\n    getMounts(mount) {\n      var mounts = [];\n      var check = [mount];\n      while (check.length) {\n        var m = check.pop();\n        mounts.push(m);\n        check.push(...m.mounts);\n      }\n      return mounts;\n    },\n    syncfs(populate, callback) {\n      if (typeof populate == \"function\") {\n        callback = populate;\n        populate = false;\n      }\n      FS.syncFSRequests++;\n      if (FS.syncFSRequests > 1) {\n        err(\n          `warning: ${FS.syncFSRequests} FS.syncfs operations in flight at once, probably just doing extra work`\n        );\n      }\n      var mounts = FS.getMounts(FS.root.mount);\n      var completed = 0;\n      function doCallback(errCode) {\n        FS.syncFSRequests--;\n        return callback(errCode);\n      }\n      function done(errCode) {\n        if (errCode) {\n          if (!done.errored) {\n            done.errored = true;\n            return doCallback(errCode);\n          }\n          return;\n        }\n        if (++completed >= mounts.length) {\n          doCallback(null);\n        }\n      }\n      for (var mount of mounts) {\n        if (mount.type.syncfs) {\n          mount.type.syncfs(mount, populate, done);\n        } else {\n          done(null);\n        }\n      }\n    },\n    mount(type, opts, mountpoint) {\n      var root = mountpoint === \"/\";\n      var pseudo = !mountpoint;\n      var node;\n      if (root && FS.root) {\n        throw new FS.ErrnoError(10);\n      } else if (!root && !pseudo) {\n        var lookup = FS.lookupPath(mountpoint, { follow_mount: false });\n        mountpoint = lookup.path;\n        node = lookup.node;\n        if (FS.isMountpoint(node)) {\n          throw new FS.ErrnoError(10);\n        }\n        if (!FS.isDir(node.mode)) {\n          throw new FS.ErrnoError(54);\n        }\n      }\n      var mount = {\n        type,\n        opts,\n        mountpoint,\n        mounts: []\n      };\n      var mountRoot = type.mount(mount);\n      mountRoot.mount = mount;\n      mount.root = mountRoot;\n      if (root) {\n        FS.root = mountRoot;\n      } else if (node) {\n        node.mounted = mount;\n        if (node.mount) {\n          node.mount.mounts.push(mount);\n        }\n      }\n      return mountRoot;\n    },\n    unmount(mountpoint) {\n      var lookup = FS.lookupPath(mountpoint, { follow_mount: false });\n      if (!FS.isMountpoint(lookup.node)) {\n        throw new FS.ErrnoError(28);\n      }\n      var node = lookup.node;\n      var mount = node.mounted;\n      var mounts = FS.getMounts(mount);\n      for (var [hash, current] of Object.entries(FS.nameTable)) {\n        while (current) {\n          var next = current.name_next;\n          if (mounts.includes(current.mount)) {\n            FS.destroyNode(current);\n          }\n          current = next;\n        }\n      }\n      node.mounted = null;\n      var idx = node.mount.mounts.indexOf(mount);\n      node.mount.mounts.splice(idx, 1);\n    },\n    lookup(parent, name) {\n      return parent.node_ops.lookup(parent, name);\n    },\n    mknod(path, mode, dev) {\n      var lookup = FS.lookupPath(path, { parent: true });\n      var parent = lookup.node;\n      var name = PATH.basename(path);\n      if (!name) {\n        throw new FS.ErrnoError(28);\n      }\n      if (name === \".\" || name === \"..\") {\n        throw new FS.ErrnoError(20);\n      }\n      var errCode = FS.mayCreate(parent, name);\n      if (errCode) {\n        throw new FS.ErrnoError(errCode);\n      }\n      if (!parent.node_ops.mknod) {\n        throw new FS.ErrnoError(63);\n      }\n      return parent.node_ops.mknod(parent, name, mode, dev);\n    },\n    statfs(path) {\n      return FS.statfsNode(FS.lookupPath(path, { follow: true }).node);\n    },\n    statfsStream(stream) {\n      return FS.statfsNode(stream.node);\n    },\n    statfsNode(node) {\n      var rtn = {\n        bsize: 4096,\n        frsize: 4096,\n        blocks: 1e6,\n        bfree: 5e5,\n        bavail: 5e5,\n        files: FS.nextInode,\n        ffree: FS.nextInode - 1,\n        fsid: 42,\n        flags: 2,\n        namelen: 255\n      };\n      if (node.node_ops.statfs) {\n        Object.assign(rtn, node.node_ops.statfs(node.mount.opts.root));\n      }\n      return rtn;\n    },\n    create(path, mode = 438) {\n      mode &= 4095;\n      mode |= 32768;\n      return FS.mknod(path, mode, 0);\n    },\n    mkdir(path, mode = 511) {\n      mode &= 511 | 512;\n      mode |= 16384;\n      return FS.mknod(path, mode, 0);\n    },\n    mkdirTree(path, mode) {\n      var dirs = path.split(\"/\");\n      var d = \"\";\n      for (var dir of dirs) {\n        if (!dir) continue;\n        if (d || PATH.isAbs(path)) d += \"/\";\n        d += dir;\n        try {\n          FS.mkdir(d, mode);\n        } catch (e) {\n          if (e.errno != 20) throw e;\n        }\n      }\n    },\n    mkdev(path, mode, dev) {\n      if (typeof dev == \"undefined\") {\n        dev = mode;\n        mode = 438;\n      }\n      mode |= 8192;\n      return FS.mknod(path, mode, dev);\n    },\n    symlink(oldpath, newpath) {\n      if (!PATH_FS.resolve(oldpath)) {\n        throw new FS.ErrnoError(44);\n      }\n      var lookup = FS.lookupPath(newpath, { parent: true });\n      var parent = lookup.node;\n      if (!parent) {\n        throw new FS.ErrnoError(44);\n      }\n      var newname = PATH.basename(newpath);\n      var errCode = FS.mayCreate(parent, newname);\n      if (errCode) {\n        throw new FS.ErrnoError(errCode);\n      }\n      if (!parent.node_ops.symlink) {\n        throw new FS.ErrnoError(63);\n      }\n      return parent.node_ops.symlink(parent, newname, oldpath);\n    },\n    rename(old_path, new_path) {\n      var old_dirname = PATH.dirname(old_path);\n      var new_dirname = PATH.dirname(new_path);\n      var old_name = PATH.basename(old_path);\n      var new_name = PATH.basename(new_path);\n      var lookup, old_dir, new_dir;\n      lookup = FS.lookupPath(old_path, { parent: true });\n      old_dir = lookup.node;\n      lookup = FS.lookupPath(new_path, { parent: true });\n      new_dir = lookup.node;\n      if (!old_dir || !new_dir) throw new FS.ErrnoError(44);\n      if (old_dir.mount !== new_dir.mount) {\n        throw new FS.ErrnoError(75);\n      }\n      var old_node = FS.lookupNode(old_dir, old_name);\n      var relative = PATH_FS.relative(old_path, new_dirname);\n      if (relative.charAt(0) !== \".\") {\n        throw new FS.ErrnoError(28);\n      }\n      relative = PATH_FS.relative(new_path, old_dirname);\n      if (relative.charAt(0) !== \".\") {\n        throw new FS.ErrnoError(55);\n      }\n      var new_node;\n      try {\n        new_node = FS.lookupNode(new_dir, new_name);\n      } catch (e) {\n      }\n      if (old_node === new_node) {\n        return;\n      }\n      var isdir = FS.isDir(old_node.mode);\n      var errCode = FS.mayDelete(old_dir, old_name, isdir);\n      if (errCode) {\n        throw new FS.ErrnoError(errCode);\n      }\n      errCode = new_node ? FS.mayDelete(new_dir, new_name, isdir) : FS.mayCreate(new_dir, new_name);\n      if (errCode) {\n        throw new FS.ErrnoError(errCode);\n      }\n      if (!old_dir.node_ops.rename) {\n        throw new FS.ErrnoError(63);\n      }\n      if (FS.isMountpoint(old_node) || new_node && FS.isMountpoint(new_node)) {\n        throw new FS.ErrnoError(10);\n      }\n      if (new_dir !== old_dir) {\n        errCode = FS.nodePermissions(old_dir, \"w\");\n        if (errCode) {\n          throw new FS.ErrnoError(errCode);\n        }\n      }\n      FS.hashRemoveNode(old_node);\n      try {\n        old_dir.node_ops.rename(old_node, new_dir, new_name);\n        old_node.parent = new_dir;\n      } catch (e) {\n        throw e;\n      } finally {\n        FS.hashAddNode(old_node);\n      }\n    },\n    rmdir(path) {\n      var lookup = FS.lookupPath(path, { parent: true });\n      var parent = lookup.node;\n      var name = PATH.basename(path);\n      var node = FS.lookupNode(parent, name);\n      var errCode = FS.mayDelete(parent, name, true);\n      if (errCode) {\n        throw new FS.ErrnoError(errCode);\n      }\n      if (!parent.node_ops.rmdir) {\n        throw new FS.ErrnoError(63);\n      }\n      if (FS.isMountpoint(node)) {\n        throw new FS.ErrnoError(10);\n      }\n      parent.node_ops.rmdir(parent, name);\n      FS.destroyNode(node);\n    },\n    readdir(path) {\n      var lookup = FS.lookupPath(path, { follow: true });\n      var node = lookup.node;\n      var readdir = FS.checkOpExists(node.node_ops.readdir, 54);\n      return readdir(node);\n    },\n    unlink(path) {\n      var lookup = FS.lookupPath(path, { parent: true });\n      var parent = lookup.node;\n      if (!parent) {\n        throw new FS.ErrnoError(44);\n      }\n      var name = PATH.basename(path);\n      var node = FS.lookupNode(parent, name);\n      var errCode = FS.mayDelete(parent, name, false);\n      if (errCode) {\n        throw new FS.ErrnoError(errCode);\n      }\n      if (!parent.node_ops.unlink) {\n        throw new FS.ErrnoError(63);\n      }\n      if (FS.isMountpoint(node)) {\n        throw new FS.ErrnoError(10);\n      }\n      parent.node_ops.unlink(parent, name);\n      FS.destroyNode(node);\n    },\n    readlink(path) {\n      var lookup = FS.lookupPath(path);\n      var link = lookup.node;\n      if (!link) {\n        throw new FS.ErrnoError(44);\n      }\n      if (!link.node_ops.readlink) {\n        throw new FS.ErrnoError(28);\n      }\n      return link.node_ops.readlink(link);\n    },\n    stat(path, dontFollow) {\n      var lookup = FS.lookupPath(path, { follow: !dontFollow });\n      var node = lookup.node;\n      var getattr = FS.checkOpExists(node.node_ops.getattr, 63);\n      return getattr(node);\n    },\n    fstat(fd) {\n      var stream = FS.getStreamChecked(fd);\n      var node = stream.node;\n      var getattr = stream.stream_ops.getattr;\n      var arg = getattr ? stream : node;\n      getattr ??= node.node_ops.getattr;\n      FS.checkOpExists(getattr, 63);\n      return getattr(arg);\n    },\n    lstat(path) {\n      return FS.stat(path, true);\n    },\n    doChmod(stream, node, mode, dontFollow) {\n      FS.doSetAttr(stream, node, {\n        mode: mode & 4095 | node.mode & ~4095,\n        ctime: Date.now(),\n        dontFollow\n      });\n    },\n    chmod(path, mode, dontFollow) {\n      var node;\n      if (typeof path == \"string\") {\n        var lookup = FS.lookupPath(path, { follow: !dontFollow });\n        node = lookup.node;\n      } else {\n        node = path;\n      }\n      FS.doChmod(null, node, mode, dontFollow);\n    },\n    lchmod(path, mode) {\n      FS.chmod(path, mode, true);\n    },\n    fchmod(fd, mode) {\n      var stream = FS.getStreamChecked(fd);\n      FS.doChmod(stream, stream.node, mode, false);\n    },\n    doChown(stream, node, dontFollow) {\n      FS.doSetAttr(stream, node, {\n        timestamp: Date.now(),\n        dontFollow\n      });\n    },\n    chown(path, uid, gid, dontFollow) {\n      var node;\n      if (typeof path == \"string\") {\n        var lookup = FS.lookupPath(path, { follow: !dontFollow });\n        node = lookup.node;\n      } else {\n        node = path;\n      }\n      FS.doChown(null, node, dontFollow);\n    },\n    lchown(path, uid, gid) {\n      FS.chown(path, uid, gid, true);\n    },\n    fchown(fd, uid, gid) {\n      var stream = FS.getStreamChecked(fd);\n      FS.doChown(stream, stream.node, false);\n    },\n    doTruncate(stream, node, len) {\n      if (FS.isDir(node.mode)) {\n        throw new FS.ErrnoError(31);\n      }\n      if (!FS.isFile(node.mode)) {\n        throw new FS.ErrnoError(28);\n      }\n      var errCode = FS.nodePermissions(node, \"w\");\n      if (errCode) {\n        throw new FS.ErrnoError(errCode);\n      }\n      FS.doSetAttr(stream, node, {\n        size: len,\n        timestamp: Date.now()\n      });\n    },\n    truncate(path, len) {\n      if (len < 0) {\n        throw new FS.ErrnoError(28);\n      }\n      var node;\n      if (typeof path == \"string\") {\n        var lookup = FS.lookupPath(path, { follow: true });\n        node = lookup.node;\n      } else {\n        node = path;\n      }\n      FS.doTruncate(null, node, len);\n    },\n    ftruncate(fd, len) {\n      var stream = FS.getStreamChecked(fd);\n      if (len < 0 || (stream.flags & 2097155) === 0) {\n        throw new FS.ErrnoError(28);\n      }\n      FS.doTruncate(stream, stream.node, len);\n    },\n    utime(path, atime, mtime) {\n      var lookup = FS.lookupPath(path, { follow: true });\n      var node = lookup.node;\n      var setattr = FS.checkOpExists(node.node_ops.setattr, 63);\n      setattr(node, {\n        atime,\n        mtime\n      });\n    },\n    open(path, flags, mode = 438) {\n      if (path === \"\") {\n        throw new FS.ErrnoError(44);\n      }\n      flags = typeof flags == \"string\" ? FS_modeStringToFlags(flags) : flags;\n      if (flags & 64) {\n        mode = mode & 4095 | 32768;\n      } else {\n        mode = 0;\n      }\n      var node;\n      var isDirPath;\n      if (typeof path == \"object\") {\n        node = path;\n      } else {\n        isDirPath = path.endsWith(\"/\");\n        var lookup = FS.lookupPath(path, {\n          follow: !(flags & 131072),\n          noent_okay: true\n        });\n        node = lookup.node;\n        path = lookup.path;\n      }\n      var created = false;\n      if (flags & 64) {\n        if (node) {\n          if (flags & 128) {\n            throw new FS.ErrnoError(20);\n          }\n        } else if (isDirPath) {\n          throw new FS.ErrnoError(31);\n        } else {\n          node = FS.mknod(path, mode | 511, 0);\n          created = true;\n        }\n      }\n      if (!node) {\n        throw new FS.ErrnoError(44);\n      }\n      if (FS.isChrdev(node.mode)) {\n        flags &= ~512;\n      }\n      if (flags & 65536 && !FS.isDir(node.mode)) {\n        throw new FS.ErrnoError(54);\n      }\n      if (!created) {\n        var errCode = FS.mayOpen(node, flags);\n        if (errCode) {\n          throw new FS.ErrnoError(errCode);\n        }\n      }\n      if (flags & 512 && !created) {\n        FS.truncate(node, 0);\n      }\n      flags &= ~(128 | 512 | 131072);\n      var stream = FS.createStream({\n        node,\n        path: FS.getPath(node),\n        flags,\n        seekable: true,\n        position: 0,\n        stream_ops: node.stream_ops,\n        ungotten: [],\n        error: false\n      });\n      if (stream.stream_ops.open) {\n        stream.stream_ops.open(stream);\n      }\n      if (created) {\n        FS.chmod(node, mode & 511);\n      }\n      if (Module[\"logReadFiles\"] && !(flags & 1)) {\n        if (!(path in FS.readFiles)) {\n          FS.readFiles[path] = 1;\n        }\n      }\n      return stream;\n    },\n    close(stream) {\n      if (FS.isClosed(stream)) {\n        throw new FS.ErrnoError(8);\n      }\n      if (stream.getdents) stream.getdents = null;\n      try {\n        if (stream.stream_ops.close) {\n          stream.stream_ops.close(stream);\n        }\n      } catch (e) {\n        throw e;\n      } finally {\n        FS.closeStream(stream.fd);\n      }\n      stream.fd = null;\n    },\n    isClosed(stream) {\n      return stream.fd === null;\n    },\n    llseek(stream, offset, whence) {\n      if (FS.isClosed(stream)) {\n        throw new FS.ErrnoError(8);\n      }\n      if (!stream.seekable || !stream.stream_ops.llseek) {\n        throw new FS.ErrnoError(70);\n      }\n      if (whence != 0 && whence != 1 && whence != 2) {\n        throw new FS.ErrnoError(28);\n      }\n      stream.position = stream.stream_ops.llseek(stream, offset, whence);\n      stream.ungotten = [];\n      return stream.position;\n    },\n    read(stream, buffer, offset, length, position) {\n      if (length < 0 || position < 0) {\n        throw new FS.ErrnoError(28);\n      }\n      if (FS.isClosed(stream)) {\n        throw new FS.ErrnoError(8);\n      }\n      if ((stream.flags & 2097155) === 1) {\n        throw new FS.ErrnoError(8);\n      }\n      if (FS.isDir(stream.node.mode)) {\n        throw new FS.ErrnoError(31);\n      }\n      if (!stream.stream_ops.read) {\n        throw new FS.ErrnoError(28);\n      }\n      var seeking = typeof position != \"undefined\";\n      if (!seeking) {\n        position = stream.position;\n      } else if (!stream.seekable) {\n        throw new FS.ErrnoError(70);\n      }\n      var bytesRead = stream.stream_ops.read(\n        stream,\n        buffer,\n        offset,\n        length,\n        position\n      );\n      if (!seeking) stream.position += bytesRead;\n      return bytesRead;\n    },\n    write(stream, buffer, offset, length, position, canOwn) {\n      if (length < 0 || position < 0) {\n        throw new FS.ErrnoError(28);\n      }\n      if (FS.isClosed(stream)) {\n        throw new FS.ErrnoError(8);\n      }\n      if ((stream.flags & 2097155) === 0) {\n        throw new FS.ErrnoError(8);\n      }\n      if (FS.isDir(stream.node.mode)) {\n        throw new FS.ErrnoError(31);\n      }\n      if (!stream.stream_ops.write) {\n        throw new FS.ErrnoError(28);\n      }\n      if (stream.seekable && stream.flags & 1024) {\n        FS.llseek(stream, 0, 2);\n      }\n      var seeking = typeof position != \"undefined\";\n      if (!seeking) {\n        position = stream.position;\n      } else if (!stream.seekable) {\n        throw new FS.ErrnoError(70);\n      }\n      var bytesWritten = stream.stream_ops.write(\n        stream,\n        buffer,\n        offset,\n        length,\n        position,\n        canOwn\n      );\n      if (!seeking) stream.position += bytesWritten;\n      return bytesWritten;\n    },\n    mmap(stream, length, position, prot, flags) {\n      if ((prot & 2) !== 0 && (flags & 2) === 0 && (stream.flags & 2097155) !== 2) {\n        throw new FS.ErrnoError(2);\n      }\n      if ((stream.flags & 2097155) === 1) {\n        throw new FS.ErrnoError(2);\n      }\n      if (!stream.stream_ops.mmap) {\n        throw new FS.ErrnoError(43);\n      }\n      if (!length) {\n        throw new FS.ErrnoError(28);\n      }\n      return stream.stream_ops.mmap(stream, length, position, prot, flags);\n    },\n    msync(stream, buffer, offset, length, mmapFlags) {\n      if (!stream.stream_ops.msync) {\n        return 0;\n      }\n      return stream.stream_ops.msync(stream, buffer, offset, length, mmapFlags);\n    },\n    ioctl(stream, cmd, arg) {\n      if (!stream.stream_ops.ioctl) {\n        throw new FS.ErrnoError(59);\n      }\n      return stream.stream_ops.ioctl(stream, cmd, arg);\n    },\n    readFile(path, opts = {}) {\n      opts.flags = opts.flags || 0;\n      opts.encoding = opts.encoding || \"binary\";\n      if (opts.encoding !== \"utf8\" && opts.encoding !== \"binary\") {\n        abort(`Invalid encoding type \"${opts.encoding}\"`);\n      }\n      var stream = FS.open(path, opts.flags);\n      var stat = FS.stat(path);\n      var length = stat.size;\n      var buf = new Uint8Array(length);\n      FS.read(stream, buf, 0, length, 0);\n      if (opts.encoding === \"utf8\") {\n        buf = UTF8ArrayToString(buf);\n      }\n      FS.close(stream);\n      return buf;\n    },\n    writeFile(path, data, opts = {}) {\n      opts.flags = opts.flags || 577;\n      var stream = FS.open(path, opts.flags, opts.mode);\n      if (typeof data == \"string\") {\n        data = new Uint8Array(intArrayFromString(data, true));\n      }\n      if (ArrayBuffer.isView(data)) {\n        FS.write(stream, data, 0, data.byteLength, void 0, opts.canOwn);\n      } else {\n        abort(\"Unsupported data type\");\n      }\n      FS.close(stream);\n    },\n    cwd: () => FS.currentPath,\n    chdir(path) {\n      var lookup = FS.lookupPath(path, { follow: true });\n      if (lookup.node === null) {\n        throw new FS.ErrnoError(44);\n      }\n      if (!FS.isDir(lookup.node.mode)) {\n        throw new FS.ErrnoError(54);\n      }\n      var errCode = FS.nodePermissions(lookup.node, \"x\");\n      if (errCode) {\n        throw new FS.ErrnoError(errCode);\n      }\n      FS.currentPath = lookup.path;\n    },\n    createDefaultDirectories() {\n      FS.mkdir(\"/tmp\");\n      FS.mkdir(\"/home\");\n      FS.mkdir(\"/home/web_user\");\n    },\n    createDefaultDevices() {\n      FS.mkdir(\"/dev\");\n      FS.registerDevice(FS.makedev(1, 3), {\n        read: () => 0,\n        write: (stream, buffer, offset, length, pos) => length,\n        llseek: () => 0\n      });\n      FS.mkdev(\"/dev/null\", FS.makedev(1, 3));\n      TTY.register(FS.makedev(5, 0), TTY.default_tty_ops);\n      TTY.register(FS.makedev(6, 0), TTY.default_tty1_ops);\n      FS.mkdev(\"/dev/tty\", FS.makedev(5, 0));\n      FS.mkdev(\"/dev/tty1\", FS.makedev(6, 0));\n      var randomBuffer = new Uint8Array(1024), randomLeft = 0;\n      var randomByte = () => {\n        if (randomLeft === 0) {\n          randomFill(randomBuffer);\n          randomLeft = randomBuffer.byteLength;\n        }\n        return randomBuffer[--randomLeft];\n      };\n      FS.createDevice(\"/dev\", \"random\", randomByte);\n      FS.createDevice(\"/dev\", \"urandom\", randomByte);\n      FS.mkdir(\"/dev/shm\");\n      FS.mkdir(\"/dev/shm/tmp\");\n    },\n    createSpecialDirectories() {\n      FS.mkdir(\"/proc\");\n      var proc_self = FS.mkdir(\"/proc/self\");\n      FS.mkdir(\"/proc/self/fd\");\n      FS.mount(\n        {\n          mount() {\n            var node = FS.createNode(proc_self, \"fd\", 16895, 73);\n            node.stream_ops = {\n              llseek: MEMFS.stream_ops.llseek\n            };\n            node.node_ops = {\n              lookup(parent, name) {\n                var fd = +name;\n                var stream = FS.getStreamChecked(fd);\n                var ret = {\n                  parent: null,\n                  mount: { mountpoint: \"fake\" },\n                  node_ops: { readlink: () => stream.path },\n                  id: fd + 1\n                };\n                ret.parent = ret;\n                return ret;\n              },\n              readdir() {\n                return Array.from(FS.streams.entries()).filter(([k, v2]) => v2).map(([k, v2]) => k.toString());\n              }\n            };\n            return node;\n          }\n        },\n        {},\n        \"/proc/self/fd\"\n      );\n    },\n    createStandardStreams(input, output, error) {\n      if (input) {\n        FS.createDevice(\"/dev\", \"stdin\", input);\n      } else {\n        FS.symlink(\"/dev/tty\", \"/dev/stdin\");\n      }\n      if (output) {\n        FS.createDevice(\"/dev\", \"stdout\", null, output);\n      } else {\n        FS.symlink(\"/dev/tty\", \"/dev/stdout\");\n      }\n      if (error) {\n        FS.createDevice(\"/dev\", \"stderr\", null, error);\n      } else {\n        FS.symlink(\"/dev/tty1\", \"/dev/stderr\");\n      }\n      var stdin = FS.open(\"/dev/stdin\", 0);\n      var stdout = FS.open(\"/dev/stdout\", 1);\n      var stderr = FS.open(\"/dev/stderr\", 1);\n    },\n    staticInit() {\n      FS.nameTable = new Array(4096);\n      FS.mount(MEMFS, {}, \"/\");\n      FS.createDefaultDirectories();\n      FS.createDefaultDevices();\n      FS.createSpecialDirectories();\n      FS.filesystems = {\n        MEMFS\n      };\n    },\n    init(input, output, error) {\n      FS.initialized = true;\n      input ??= Module[\"stdin\"];\n      output ??= Module[\"stdout\"];\n      error ??= Module[\"stderr\"];\n      FS.createStandardStreams(input, output, error);\n    },\n    quit() {\n      FS.initialized = false;\n      for (var stream of FS.streams) {\n        if (stream) {\n          FS.close(stream);\n        }\n      }\n    },\n    findObject(path, dontResolveLastLink) {\n      var ret = FS.analyzePath(path, dontResolveLastLink);\n      if (!ret.exists) {\n        return null;\n      }\n      return ret.object;\n    },\n    analyzePath(path, dontResolveLastLink) {\n      try {\n        var lookup = FS.lookupPath(path, { follow: !dontResolveLastLink });\n        path = lookup.path;\n      } catch (e) {\n      }\n      var ret = {\n        isRoot: false,\n        exists: false,\n        error: 0,\n        name: null,\n        path: null,\n        object: null,\n        parentExists: false,\n        parentPath: null,\n        parentObject: null\n      };\n      try {\n        var lookup = FS.lookupPath(path, { parent: true });\n        ret.parentExists = true;\n        ret.parentPath = lookup.path;\n        ret.parentObject = lookup.node;\n        ret.name = PATH.basename(path);\n        lookup = FS.lookupPath(path, { follow: !dontResolveLastLink });\n        ret.exists = true;\n        ret.path = lookup.path;\n        ret.object = lookup.node;\n        ret.name = lookup.node.name;\n        ret.isRoot = lookup.path === \"/\";\n      } catch (e) {\n        ret.error = e.errno;\n      }\n      return ret;\n    },\n    createPath(parent, path, canRead, canWrite) {\n      parent = typeof parent == \"string\" ? parent : FS.getPath(parent);\n      var parts = path.split(\"/\").reverse();\n      while (parts.length) {\n        var part = parts.pop();\n        if (!part) continue;\n        var current = PATH.join2(parent, part);\n        try {\n          FS.mkdir(current);\n        } catch (e) {\n          if (e.errno != 20) throw e;\n        }\n        parent = current;\n      }\n      return current;\n    },\n    createFile(parent, name, properties, canRead, canWrite) {\n      var path = PATH.join2(\n        typeof parent == \"string\" ? parent : FS.getPath(parent),\n        name\n      );\n      var mode = FS_getMode(canRead, canWrite);\n      return FS.create(path, mode);\n    },\n    createDataFile(parent, name, data, canRead, canWrite, canOwn) {\n      var path = name;\n      if (parent) {\n        parent = typeof parent == \"string\" ? parent : FS.getPath(parent);\n        path = name ? PATH.join2(parent, name) : parent;\n      }\n      var mode = FS_getMode(canRead, canWrite);\n      var node = FS.create(path, mode);\n      if (data) {\n        if (typeof data == \"string\") {\n          var arr = new Array(data.length);\n          for (var i = 0, len = data.length; i < len; ++i)\n            arr[i] = data.charCodeAt(i);\n          data = arr;\n        }\n        FS.chmod(node, mode | 146);\n        var stream = FS.open(node, 577);\n        FS.write(stream, data, 0, data.length, 0, canOwn);\n        FS.close(stream);\n        FS.chmod(node, mode);\n      }\n    },\n    createDevice(parent, name, input, output) {\n      var path = PATH.join2(\n        typeof parent == \"string\" ? parent : FS.getPath(parent),\n        name\n      );\n      var mode = FS_getMode(!!input, !!output);\n      FS.createDevice.major ??= 64;\n      var dev = FS.makedev(FS.createDevice.major++, 0);\n      FS.registerDevice(dev, {\n        open(stream) {\n          stream.seekable = false;\n        },\n        close(stream) {\n          if (output?.buffer?.length) {\n            output(10);\n          }\n        },\n        read(stream, buffer, offset, length, pos) {\n          var bytesRead = 0;\n          for (var i = 0; i < length; i++) {\n            var result;\n            try {\n              result = input();\n            } catch (e) {\n              throw new FS.ErrnoError(29);\n            }\n            if (result === void 0 && bytesRead === 0) {\n              throw new FS.ErrnoError(6);\n            }\n            if (result === null || result === void 0) break;\n            bytesRead++;\n            buffer[offset + i] = result;\n          }\n          if (bytesRead) {\n            stream.node.atime = Date.now();\n          }\n          return bytesRead;\n        },\n        write(stream, buffer, offset, length, pos) {\n          for (var i = 0; i < length; i++) {\n            try {\n              output(buffer[offset + i]);\n            } catch (e) {\n              throw new FS.ErrnoError(29);\n            }\n          }\n          if (length) {\n            stream.node.mtime = stream.node.ctime = Date.now();\n          }\n          return i;\n        }\n      });\n      return FS.mkdev(path, mode, dev);\n    },\n    forceLoadFile(obj) {\n      if (obj.isDevice || obj.isFolder || obj.link || obj.contents) return true;\n      if (globalThis.XMLHttpRequest) {\n        abort(\n          \"Lazy loading should have been performed (contents set) in createLazyFile, but it was not. Lazy loading only works in web workers. Use --embed-file or --preload-file in emcc on the main thread.\"\n        );\n      } else {\n        try {\n          obj.contents = readBinary(obj.url);\n        } catch (e) {\n          throw new FS.ErrnoError(29);\n        }\n      }\n    },\n    createLazyFile(parent, name, url, canRead, canWrite) {\n      class LazyUint8Array {\n        lengthKnown = false;\n        chunks = [];\n        get(idx) {\n          if (idx > this.length - 1 || idx < 0) {\n            return void 0;\n          }\n          var chunkOffset = idx % this.chunkSize;\n          var chunkNum = idx / this.chunkSize | 0;\n          return this.getter(chunkNum)[chunkOffset];\n        }\n        setDataGetter(getter) {\n          this.getter = getter;\n        }\n        cacheLength() {\n          var xhr = new XMLHttpRequest();\n          xhr.open(\"HEAD\", url, false);\n          xhr.send(null);\n          if (!(xhr.status >= 200 && xhr.status < 300 || xhr.status === 304))\n            abort(\"Couldn't load \" + url + \". Status: \" + xhr.status);\n          var datalength = Number(xhr.getResponseHeader(\"Content-length\"));\n          var header;\n          var hasByteServing = (header = xhr.getResponseHeader(\"Accept-Ranges\")) && header === \"bytes\";\n          var usesGzip = (header = xhr.getResponseHeader(\"Content-Encoding\")) && header === \"gzip\";\n          var chunkSize = 1024 * 1024;\n          if (!hasByteServing) chunkSize = datalength;\n          var doXHR = (from, to) => {\n            if (from > to)\n              abort(\n                \"invalid range (\" + from + \", \" + to + \") or no bytes requested!\"\n              );\n            if (to > datalength - 1)\n              abort(\n                \"only \" + datalength + \" bytes available! programmer error!\"\n              );\n            var xhr2 = new XMLHttpRequest();\n            xhr2.open(\"GET\", url, false);\n            if (datalength !== chunkSize)\n              xhr2.setRequestHeader(\"Range\", \"bytes=\" + from + \"-\" + to);\n            xhr2.responseType = \"arraybuffer\";\n            if (xhr2.overrideMimeType) {\n              xhr2.overrideMimeType(\"text/plain; charset=x-user-defined\");\n            }\n            xhr2.send(null);\n            if (!(xhr2.status >= 200 && xhr2.status < 300 || xhr2.status === 304))\n              abort(\"Couldn't load \" + url + \". Status: \" + xhr2.status);\n            if (xhr2.response !== void 0) {\n              return new Uint8Array(xhr2.response || []);\n            }\n            return intArrayFromString(xhr2.responseText || \"\", true);\n          };\n          var lazyArray2 = this;\n          lazyArray2.setDataGetter((chunkNum) => {\n            var start = chunkNum * chunkSize;\n            var end = (chunkNum + 1) * chunkSize - 1;\n            end = Math.min(end, datalength - 1);\n            if (typeof lazyArray2.chunks[chunkNum] == \"undefined\") {\n              lazyArray2.chunks[chunkNum] = doXHR(start, end);\n            }\n            if (typeof lazyArray2.chunks[chunkNum] == \"undefined\")\n              abort(\"doXHR failed!\");\n            return lazyArray2.chunks[chunkNum];\n          });\n          if (usesGzip || !datalength) {\n            chunkSize = datalength = 1;\n            datalength = this.getter(0).length;\n            chunkSize = datalength;\n            out(\n              \"LazyFiles on gzip forces download of the whole file when length is accessed\"\n            );\n          }\n          this._length = datalength;\n          this._chunkSize = chunkSize;\n          this.lengthKnown = true;\n        }\n        get length() {\n          if (!this.lengthKnown) {\n            this.cacheLength();\n          }\n          return this._length;\n        }\n        get chunkSize() {\n          if (!this.lengthKnown) {\n            this.cacheLength();\n          }\n          return this._chunkSize;\n        }\n      }\n      if (globalThis.XMLHttpRequest) {\n        if (!ENVIRONMENT_IS_WORKER)\n          abort(\n            \"Cannot do synchronous binary XHRs outside webworkers in modern browsers. Use --embed-file or --preload-file in emcc\"\n          );\n        var lazyArray = new LazyUint8Array();\n        var properties = { isDevice: false, contents: lazyArray };\n      } else {\n        var properties = { isDevice: false, url };\n      }\n      var node = FS.createFile(parent, name, properties, canRead, canWrite);\n      if (properties.contents) {\n        node.contents = properties.contents;\n      } else if (properties.url) {\n        node.contents = null;\n        node.url = properties.url;\n      }\n      Object.defineProperties(node, {\n        usedBytes: {\n          get: function() {\n            return this.contents.length;\n          }\n        }\n      });\n      var stream_ops = {};\n      for (const [key, fn] of Object.entries(node.stream_ops)) {\n        stream_ops[key] = (...args) => {\n          FS.forceLoadFile(node);\n          return fn(...args);\n        };\n      }\n      function writeChunks(stream, buffer, offset, length, position) {\n        var contents = stream.node.contents;\n        if (position >= contents.length) return 0;\n        var size = Math.min(contents.length - position, length);\n        if (contents.slice) {\n          for (var i = 0; i < size; i++) {\n            buffer[offset + i] = contents[position + i];\n          }\n        } else {\n          for (var i = 0; i < size; i++) {\n            buffer[offset + i] = contents.get(position + i);\n          }\n        }\n        return size;\n      }\n      stream_ops.read = (stream, buffer, offset, length, position) => {\n        FS.forceLoadFile(node);\n        return writeChunks(stream, buffer, offset, length, position);\n      };\n      stream_ops.mmap = (stream, length, position, prot, flags) => {\n        FS.forceLoadFile(node);\n        var ptr = mmapAlloc(length);\n        if (!ptr) {\n          throw new FS.ErrnoError(48);\n        }\n        writeChunks(stream, HEAP8, ptr, length, position);\n        return { ptr, allocated: true };\n      };\n      node.stream_ops = stream_ops;\n      return node;\n    }\n  };\n  var UTF8ToString = (ptr, maxBytesToRead, ignoreNul) => {\n    if (!ptr) return \"\";\n    var end = findStringEnd(HEAPU8, ptr, maxBytesToRead, ignoreNul);\n    return UTF8Decoder.decode(HEAPU8.subarray(ptr, end));\n  };\n  var SYSCALLS = {\n    DEFAULT_POLLMASK: 5,\n    calculateAt(dirfd, path, allowEmpty) {\n      if (PATH.isAbs(path)) {\n        return path;\n      }\n      var dir;\n      if (dirfd === -100) {\n        dir = FS.cwd();\n      } else {\n        var dirstream = SYSCALLS.getStreamFromFD(dirfd);\n        dir = dirstream.path;\n      }\n      if (path.length == 0) {\n        if (!allowEmpty) {\n          throw new FS.ErrnoError(44);\n        }\n        return dir;\n      }\n      return dir + \"/\" + path;\n    },\n    writeStat(buf, stat) {\n      HEAPU32[buf >> 2] = stat.dev;\n      HEAPU32[buf + 4 >> 2] = stat.mode;\n      HEAPU32[buf + 8 >> 2] = stat.nlink;\n      HEAPU32[buf + 12 >> 2] = stat.uid;\n      HEAPU32[buf + 16 >> 2] = stat.gid;\n      HEAPU32[buf + 20 >> 2] = stat.rdev;\n      HEAP64[buf + 24 >> 3] = BigInt(stat.size);\n      HEAP32[buf + 32 >> 2] = 4096;\n      HEAP32[buf + 36 >> 2] = stat.blocks;\n      var atime = stat.atime.getTime();\n      var mtime = stat.mtime.getTime();\n      var ctime = stat.ctime.getTime();\n      HEAP64[buf + 40 >> 3] = BigInt(Math.floor(atime / 1e3));\n      HEAPU32[buf + 48 >> 2] = atime % 1e3 * 1e3 * 1e3;\n      HEAP64[buf + 56 >> 3] = BigInt(Math.floor(mtime / 1e3));\n      HEAPU32[buf + 64 >> 2] = mtime % 1e3 * 1e3 * 1e3;\n      HEAP64[buf + 72 >> 3] = BigInt(Math.floor(ctime / 1e3));\n      HEAPU32[buf + 80 >> 2] = ctime % 1e3 * 1e3 * 1e3;\n      HEAP64[buf + 88 >> 3] = BigInt(stat.ino);\n      return 0;\n    },\n    writeStatFs(buf, stats) {\n      HEAPU32[buf + 4 >> 2] = stats.bsize;\n      HEAPU32[buf + 60 >> 2] = stats.bsize;\n      HEAP64[buf + 8 >> 3] = BigInt(stats.blocks);\n      HEAP64[buf + 16 >> 3] = BigInt(stats.bfree);\n      HEAP64[buf + 24 >> 3] = BigInt(stats.bavail);\n      HEAP64[buf + 32 >> 3] = BigInt(stats.files);\n      HEAP64[buf + 40 >> 3] = BigInt(stats.ffree);\n      HEAPU32[buf + 48 >> 2] = stats.fsid;\n      HEAPU32[buf + 64 >> 2] = stats.flags;\n      HEAPU32[buf + 56 >> 2] = stats.namelen;\n    },\n    doMsync(addr, stream, len, flags, offset) {\n      if (!FS.isFile(stream.node.mode)) {\n        throw new FS.ErrnoError(43);\n      }\n      if (flags & 2) {\n        return 0;\n      }\n      var buffer = HEAPU8.slice(addr, addr + len);\n      FS.msync(stream, buffer, offset, len, flags);\n    },\n    getStreamFromFD(fd) {\n      var stream = FS.getStreamChecked(fd);\n      return stream;\n    },\n    varargs: void 0,\n    getStr(ptr) {\n      var ret = UTF8ToString(ptr);\n      return ret;\n    }\n  };\n  function ___syscall_chmod(path, mode) {\n    try {\n      path = SYSCALLS.getStr(path);\n      FS.chmod(path, mode);\n      return 0;\n    } catch (e) {\n      if (typeof FS == \"undefined\" || !(e.name === \"ErrnoError\")) throw e;\n      return -e.errno;\n    }\n  }\n  function ___syscall_faccessat(dirfd, path, amode, flags) {\n    try {\n      path = SYSCALLS.getStr(path);\n      path = SYSCALLS.calculateAt(dirfd, path);\n      if (amode & ~7) {\n        return -28;\n      }\n      var lookup = FS.lookupPath(path, { follow: true });\n      var node = lookup.node;\n      if (!node) {\n        return -44;\n      }\n      var perms = \"\";\n      if (amode & 4) perms += \"r\";\n      if (amode & 2) perms += \"w\";\n      if (amode & 1) perms += \"x\";\n      if (perms && FS.nodePermissions(node, perms)) {\n        return -2;\n      }\n      return 0;\n    } catch (e) {\n      if (typeof FS == \"undefined\" || !(e.name === \"ErrnoError\")) throw e;\n      return -e.errno;\n    }\n  }\n  function ___syscall_fchmod(fd, mode) {\n    try {\n      FS.fchmod(fd, mode);\n      return 0;\n    } catch (e) {\n      if (typeof FS == \"undefined\" || !(e.name === \"ErrnoError\")) throw e;\n      return -e.errno;\n    }\n  }\n  function ___syscall_fchown32(fd, owner, group) {\n    try {\n      FS.fchown(fd, owner, group);\n      return 0;\n    } catch (e) {\n      if (typeof FS == \"undefined\" || !(e.name === \"ErrnoError\")) throw e;\n      return -e.errno;\n    }\n  }\n  var syscallGetVarargI = () => {\n    var ret = HEAP32[+SYSCALLS.varargs >> 2];\n    SYSCALLS.varargs += 4;\n    return ret;\n  };\n  var syscallGetVarargP = syscallGetVarargI;\n  function ___syscall_fcntl64(fd, cmd, varargs) {\n    SYSCALLS.varargs = varargs;\n    try {\n      var stream = SYSCALLS.getStreamFromFD(fd);\n      switch (cmd) {\n        case 0: {\n          var arg = syscallGetVarargI();\n          if (arg < 0) {\n            return -28;\n          }\n          while (FS.streams[arg]) {\n            arg++;\n          }\n          var newStream;\n          newStream = FS.dupStream(stream, arg);\n          return newStream.fd;\n        }\n        case 1:\n        case 2:\n          return 0;\n        case 3:\n          return stream.flags;\n        case 4: {\n          var arg = syscallGetVarargI();\n          stream.flags |= arg;\n          return 0;\n        }\n        case 12: {\n          var arg = syscallGetVarargP();\n          var offset = 0;\n          HEAP16[arg + offset >> 1] = 2;\n          return 0;\n        }\n        case 13:\n        case 14:\n          return 0;\n      }\n      return -28;\n    } catch (e) {\n      if (typeof FS == \"undefined\" || !(e.name === \"ErrnoError\")) throw e;\n      return -e.errno;\n    }\n  }\n  function ___syscall_fstat64(fd, buf) {\n    try {\n      return SYSCALLS.writeStat(buf, FS.fstat(fd));\n    } catch (e) {\n      if (typeof FS == \"undefined\" || !(e.name === \"ErrnoError\")) throw e;\n      return -e.errno;\n    }\n  }\n  var INT53_MAX = 9007199254740992;\n  var INT53_MIN = -9007199254740992;\n  var bigintToI53Checked = (num) => num < INT53_MIN || num > INT53_MAX ? NaN : Number(num);\n  function ___syscall_ftruncate64(fd, length) {\n    length = bigintToI53Checked(length);\n    try {\n      if (isNaN(length)) return -61;\n      FS.ftruncate(fd, length);\n      return 0;\n    } catch (e) {\n      if (typeof FS == \"undefined\" || !(e.name === \"ErrnoError\")) throw e;\n      return -e.errno;\n    }\n  }\n  var stringToUTF8 = (str, outPtr, maxBytesToWrite) => {\n    return stringToUTF8Array(str, HEAPU8, outPtr, maxBytesToWrite);\n  };\n  function ___syscall_getcwd(buf, size) {\n    try {\n      if (size === 0) return -28;\n      var cwd = FS.cwd();\n      var cwdLengthInBytes = lengthBytesUTF8(cwd) + 1;\n      if (size < cwdLengthInBytes) return -68;\n      stringToUTF8(cwd, buf, size);\n      return cwdLengthInBytes;\n    } catch (e) {\n      if (typeof FS == \"undefined\" || !(e.name === \"ErrnoError\")) throw e;\n      return -e.errno;\n    }\n  }\n  function ___syscall_ioctl(fd, op, varargs) {\n    SYSCALLS.varargs = varargs;\n    try {\n      var stream = SYSCALLS.getStreamFromFD(fd);\n      switch (op) {\n        case 21509: {\n          if (!stream.tty) return -59;\n          return 0;\n        }\n        case 21505: {\n          if (!stream.tty) return -59;\n          if (stream.tty.ops.ioctl_tcgets) {\n            var termios = stream.tty.ops.ioctl_tcgets(stream);\n            var argp = syscallGetVarargP();\n            HEAP32[argp >> 2] = termios.c_iflag || 0;\n            HEAP32[argp + 4 >> 2] = termios.c_oflag || 0;\n            HEAP32[argp + 8 >> 2] = termios.c_cflag || 0;\n            HEAP32[argp + 12 >> 2] = termios.c_lflag || 0;\n            for (var i = 0; i < 32; i++) {\n              HEAP8[argp + i + 17] = termios.c_cc[i] || 0;\n            }\n            return 0;\n          }\n          return 0;\n        }\n        case 21510:\n        case 21511:\n        case 21512: {\n          if (!stream.tty) return -59;\n          return 0;\n        }\n        case 21506:\n        case 21507:\n        case 21508: {\n          if (!stream.tty) return -59;\n          if (stream.tty.ops.ioctl_tcsets) {\n            var argp = syscallGetVarargP();\n            var c_iflag = HEAP32[argp >> 2];\n            var c_oflag = HEAP32[argp + 4 >> 2];\n            var c_cflag = HEAP32[argp + 8 >> 2];\n            var c_lflag = HEAP32[argp + 12 >> 2];\n            var c_cc = [];\n            for (var i = 0; i < 32; i++) {\n              c_cc.push(HEAP8[argp + i + 17]);\n            }\n            return stream.tty.ops.ioctl_tcsets(stream.tty, op, {\n              c_iflag,\n              c_oflag,\n              c_cflag,\n              c_lflag,\n              c_cc\n            });\n          }\n          return 0;\n        }\n        case 21519: {\n          if (!stream.tty) return -59;\n          var argp = syscallGetVarargP();\n          HEAP32[argp >> 2] = 0;\n          return 0;\n        }\n        case 21520: {\n          if (!stream.tty) return -59;\n          return -28;\n        }\n        case 21537:\n        case 21531: {\n          var argp = syscallGetVarargP();\n          return FS.ioctl(stream, op, argp);\n        }\n        case 21523: {\n          if (!stream.tty) return -59;\n          if (stream.tty.ops.ioctl_tiocgwinsz) {\n            var winsize = stream.tty.ops.ioctl_tiocgwinsz(stream.tty);\n            var argp = syscallGetVarargP();\n            HEAP16[argp >> 1] = winsize[0];\n            HEAP16[argp + 2 >> 1] = winsize[1];\n          }\n          return 0;\n        }\n        case 21524: {\n          if (!stream.tty) return -59;\n          return 0;\n        }\n        case 21515: {\n          if (!stream.tty) return -59;\n          return 0;\n        }\n        default:\n          return -28;\n      }\n    } catch (e) {\n      if (typeof FS == \"undefined\" || !(e.name === \"ErrnoError\")) throw e;\n      return -e.errno;\n    }\n  }\n  function ___syscall_lstat64(path, buf) {\n    try {\n      path = SYSCALLS.getStr(path);\n      return SYSCALLS.writeStat(buf, FS.lstat(path));\n    } catch (e) {\n      if (typeof FS == \"undefined\" || !(e.name === \"ErrnoError\")) throw e;\n      return -e.errno;\n    }\n  }\n  function ___syscall_mkdirat(dirfd, path, mode) {\n    try {\n      path = SYSCALLS.getStr(path);\n      path = SYSCALLS.calculateAt(dirfd, path);\n      FS.mkdir(path, mode, 0);\n      return 0;\n    } catch (e) {\n      if (typeof FS == \"undefined\" || !(e.name === \"ErrnoError\")) throw e;\n      return -e.errno;\n    }\n  }\n  function ___syscall_newfstatat(dirfd, path, buf, flags) {\n    try {\n      path = SYSCALLS.getStr(path);\n      var nofollow = flags & 256;\n      var allowEmpty = flags & 4096;\n      flags = flags & ~6400;\n      path = SYSCALLS.calculateAt(dirfd, path, allowEmpty);\n      return SYSCALLS.writeStat(buf, nofollow ? FS.lstat(path) : FS.stat(path));\n    } catch (e) {\n      if (typeof FS == \"undefined\" || !(e.name === \"ErrnoError\")) throw e;\n      return -e.errno;\n    }\n  }\n  function ___syscall_openat(dirfd, path, flags, varargs) {\n    SYSCALLS.varargs = varargs;\n    try {\n      path = SYSCALLS.getStr(path);\n      path = SYSCALLS.calculateAt(dirfd, path);\n      var mode = varargs ? syscallGetVarargI() : 0;\n      return FS.open(path, flags, mode).fd;\n    } catch (e) {\n      if (typeof FS == \"undefined\" || !(e.name === \"ErrnoError\")) throw e;\n      return -e.errno;\n    }\n  }\n  function ___syscall_readlinkat(dirfd, path, buf, bufsize) {\n    try {\n      path = SYSCALLS.getStr(path);\n      path = SYSCALLS.calculateAt(dirfd, path);\n      if (bufsize <= 0) return -28;\n      var ret = FS.readlink(path);\n      var len = Math.min(bufsize, lengthBytesUTF8(ret));\n      var endChar = HEAP8[buf + len];\n      stringToUTF8(ret, buf, bufsize + 1);\n      HEAP8[buf + len] = endChar;\n      return len;\n    } catch (e) {\n      if (typeof FS == \"undefined\" || !(e.name === \"ErrnoError\")) throw e;\n      return -e.errno;\n    }\n  }\n  function ___syscall_rmdir(path) {\n    try {\n      path = SYSCALLS.getStr(path);\n      FS.rmdir(path);\n      return 0;\n    } catch (e) {\n      if (typeof FS == \"undefined\" || !(e.name === \"ErrnoError\")) throw e;\n      return -e.errno;\n    }\n  }\n  function ___syscall_stat64(path, buf) {\n    try {\n      path = SYSCALLS.getStr(path);\n      return SYSCALLS.writeStat(buf, FS.stat(path));\n    } catch (e) {\n      if (typeof FS == \"undefined\" || !(e.name === \"ErrnoError\")) throw e;\n      return -e.errno;\n    }\n  }\n  function ___syscall_unlinkat(dirfd, path, flags) {\n    try {\n      path = SYSCALLS.getStr(path);\n      path = SYSCALLS.calculateAt(dirfd, path);\n      if (!flags) {\n        FS.unlink(path);\n      } else if (flags === 512) {\n        FS.rmdir(path);\n      } else {\n        return -28;\n      }\n      return 0;\n    } catch (e) {\n      if (typeof FS == \"undefined\" || !(e.name === \"ErrnoError\")) throw e;\n      return -e.errno;\n    }\n  }\n  var readI53FromI64 = (ptr) => {\n    return HEAPU32[ptr >> 2] + HEAP32[ptr + 4 >> 2] * 4294967296;\n  };\n  function ___syscall_utimensat(dirfd, path, times, flags) {\n    try {\n      path = SYSCALLS.getStr(path);\n      path = SYSCALLS.calculateAt(dirfd, path, true);\n      var now = Date.now(), atime, mtime;\n      if (!times) {\n        atime = now;\n        mtime = now;\n      } else {\n        var seconds = readI53FromI64(times);\n        var nanoseconds = HEAP32[times + 8 >> 2];\n        if (nanoseconds == 1073741823) {\n          atime = now;\n        } else if (nanoseconds == 1073741822) {\n          atime = null;\n        } else {\n          atime = seconds * 1e3 + nanoseconds / (1e3 * 1e3);\n        }\n        times += 16;\n        seconds = readI53FromI64(times);\n        nanoseconds = HEAP32[times + 8 >> 2];\n        if (nanoseconds == 1073741823) {\n          mtime = now;\n        } else if (nanoseconds == 1073741822) {\n          mtime = null;\n        } else {\n          mtime = seconds * 1e3 + nanoseconds / (1e3 * 1e3);\n        }\n      }\n      if ((mtime ?? atime) !== null) {\n        FS.utime(path, atime, mtime);\n      }\n      return 0;\n    } catch (e) {\n      if (typeof FS == \"undefined\" || !(e.name === \"ErrnoError\")) throw e;\n      return -e.errno;\n    }\n  }\n  var isLeapYear = (year) => year % 4 === 0 && (year % 100 !== 0 || year % 400 === 0);\n  var MONTH_DAYS_LEAP_CUMULATIVE = [\n    0,\n    31,\n    60,\n    91,\n    121,\n    152,\n    182,\n    213,\n    244,\n    274,\n    305,\n    335\n  ];\n  var MONTH_DAYS_REGULAR_CUMULATIVE = [\n    0,\n    31,\n    59,\n    90,\n    120,\n    151,\n    181,\n    212,\n    243,\n    273,\n    304,\n    334\n  ];\n  var ydayFromDate = (date) => {\n    var leap = isLeapYear(date.getFullYear());\n    var monthDaysCumulative = leap ? MONTH_DAYS_LEAP_CUMULATIVE : MONTH_DAYS_REGULAR_CUMULATIVE;\n    var yday = monthDaysCumulative[date.getMonth()] + date.getDate() - 1;\n    return yday;\n  };\n  function __localtime_js(time, tmPtr) {\n    time = bigintToI53Checked(time);\n    var date = new Date(time * 1e3);\n    HEAP32[tmPtr >> 2] = date.getSeconds();\n    HEAP32[tmPtr + 4 >> 2] = date.getMinutes();\n    HEAP32[tmPtr + 8 >> 2] = date.getHours();\n    HEAP32[tmPtr + 12 >> 2] = date.getDate();\n    HEAP32[tmPtr + 16 >> 2] = date.getMonth();\n    HEAP32[tmPtr + 20 >> 2] = date.getFullYear() - 1900;\n    HEAP32[tmPtr + 24 >> 2] = date.getDay();\n    var yday = ydayFromDate(date) | 0;\n    HEAP32[tmPtr + 28 >> 2] = yday;\n    HEAP32[tmPtr + 36 >> 2] = -(date.getTimezoneOffset() * 60);\n    var start = new Date(date.getFullYear(), 0, 1);\n    var summerOffset = new Date(date.getFullYear(), 6, 1).getTimezoneOffset();\n    var winterOffset = start.getTimezoneOffset();\n    var dst = (summerOffset != winterOffset && date.getTimezoneOffset() == Math.min(winterOffset, summerOffset)) | 0;\n    HEAP32[tmPtr + 32 >> 2] = dst;\n  }\n  function __mmap_js(len, prot, flags, fd, offset, allocated, addr) {\n    offset = bigintToI53Checked(offset);\n    try {\n      var stream = SYSCALLS.getStreamFromFD(fd);\n      var res = FS.mmap(stream, len, offset, prot, flags);\n      var ptr = res.ptr;\n      HEAP32[allocated >> 2] = res.allocated;\n      HEAPU32[addr >> 2] = ptr;\n      return 0;\n    } catch (e) {\n      if (typeof FS == \"undefined\" || !(e.name === \"ErrnoError\")) throw e;\n      return -e.errno;\n    }\n  }\n  function __munmap_js(addr, len, prot, flags, fd, offset) {\n    offset = bigintToI53Checked(offset);\n    try {\n      var stream = SYSCALLS.getStreamFromFD(fd);\n      if (prot & 2) {\n        SYSCALLS.doMsync(addr, stream, len, flags, offset);\n      }\n    } catch (e) {\n      if (typeof FS == \"undefined\" || !(e.name === \"ErrnoError\")) throw e;\n      return -e.errno;\n    }\n  }\n  var __tzset_js = (timezone, daylight, std_name, dst_name) => {\n    var currentYear = (/* @__PURE__ */ new Date()).getFullYear();\n    var winter = new Date(currentYear, 0, 1);\n    var summer = new Date(currentYear, 6, 1);\n    var winterOffset = winter.getTimezoneOffset();\n    var summerOffset = summer.getTimezoneOffset();\n    var stdTimezoneOffset = Math.max(winterOffset, summerOffset);\n    HEAPU32[timezone >> 2] = stdTimezoneOffset * 60;\n    HEAP32[daylight >> 2] = Number(winterOffset != summerOffset);\n    var extractZone = (timezoneOffset) => {\n      var sign = timezoneOffset >= 0 ? \"-\" : \"+\";\n      var absOffset = Math.abs(timezoneOffset);\n      var hours = String(Math.floor(absOffset / 60)).padStart(2, \"0\");\n      var minutes = String(absOffset % 60).padStart(2, \"0\");\n      return `UTC${sign}${hours}${minutes}`;\n    };\n    var winterName = extractZone(winterOffset);\n    var summerName = extractZone(summerOffset);\n    if (summerOffset < winterOffset) {\n      stringToUTF8(winterName, std_name, 17);\n      stringToUTF8(summerName, dst_name, 17);\n    } else {\n      stringToUTF8(winterName, dst_name, 17);\n      stringToUTF8(summerName, std_name, 17);\n    }\n  };\n  var _emscripten_get_now = () => performance.now();\n  var _emscripten_date_now = () => Date.now();\n  var nowIsMonotonic = 1;\n  var checkWasiClock = (clock_id) => clock_id >= 0 && clock_id <= 3;\n  function _clock_time_get(clk_id, ignored_precision, ptime) {\n    ignored_precision = bigintToI53Checked(ignored_precision);\n    if (!checkWasiClock(clk_id)) {\n      return 28;\n    }\n    var now;\n    if (clk_id === 0) {\n      now = _emscripten_date_now();\n    } else if (nowIsMonotonic) {\n      now = _emscripten_get_now();\n    } else {\n      return 52;\n    }\n    var nsec = Math.round(now * 1e3 * 1e3);\n    HEAP64[ptime >> 3] = BigInt(nsec);\n    return 0;\n  }\n  var getHeapMax = () => 2147483648;\n  var _emscripten_get_heap_max = () => getHeapMax();\n  var growMemory = (size) => {\n    var oldHeapSize = wasmMemory.buffer.byteLength;\n    var pages = (size - oldHeapSize + 65535) / 65536 | 0;\n    try {\n      wasmMemory.grow(pages);\n      updateMemoryViews();\n      return 1;\n    } catch (e) {\n    }\n  };\n  var _emscripten_resize_heap = (requestedSize) => {\n    var oldSize = HEAPU8.length;\n    requestedSize >>>= 0;\n    var maxHeapSize = getHeapMax();\n    if (requestedSize > maxHeapSize) {\n      return false;\n    }\n    for (var cutDown = 1; cutDown <= 4; cutDown *= 2) {\n      var overGrownHeapSize = oldSize * (1 + 0.2 / cutDown);\n      overGrownHeapSize = Math.min(\n        overGrownHeapSize,\n        requestedSize + 100663296\n      );\n      var newSize = Math.min(\n        maxHeapSize,\n        alignMemory(Math.max(requestedSize, overGrownHeapSize), 65536)\n      );\n      var replacement = growMemory(newSize);\n      if (replacement) {\n        return true;\n      }\n    }\n    return false;\n  };\n  var ENV = {};\n  var getExecutableName = () => thisProgram || \"./this.program\";\n  var getEnvStrings = () => {\n    if (!getEnvStrings.strings) {\n      var lang = (typeof navigator == \"object\" && navigator.language || \"C\").replace(\n        \"-\",\n        \"_\"\n      ) + \".UTF-8\";\n      var env = {\n        USER: \"web_user\",\n        LOGNAME: \"web_user\",\n        PATH: \"/\",\n        PWD: \"/\",\n        HOME: \"/home/web_user\",\n        LANG: lang,\n        _: getExecutableName()\n      };\n      for (var x in ENV) {\n        if (ENV[x] === void 0) delete env[x];\n        else env[x] = ENV[x];\n      }\n      var strings = [];\n      for (var x in env) {\n        strings.push(`${x}=${env[x]}`);\n      }\n      getEnvStrings.strings = strings;\n    }\n    return getEnvStrings.strings;\n  };\n  var _environ_get = (__environ, environ_buf) => {\n    var bufSize = 0;\n    var envp = 0;\n    for (var string of getEnvStrings()) {\n      var ptr = environ_buf + bufSize;\n      HEAPU32[__environ + envp >> 2] = ptr;\n      bufSize += stringToUTF8(string, ptr, Infinity) + 1;\n      envp += 4;\n    }\n    return 0;\n  };\n  var _environ_sizes_get = (penviron_count, penviron_buf_size) => {\n    var strings = getEnvStrings();\n    HEAPU32[penviron_count >> 2] = strings.length;\n    var bufSize = 0;\n    for (var string of strings) {\n      bufSize += lengthBytesUTF8(string) + 1;\n    }\n    HEAPU32[penviron_buf_size >> 2] = bufSize;\n    return 0;\n  };\n  function _fd_close(fd) {\n    try {\n      var stream = SYSCALLS.getStreamFromFD(fd);\n      FS.close(stream);\n      return 0;\n    } catch (e) {\n      if (typeof FS == \"undefined\" || !(e.name === \"ErrnoError\")) throw e;\n      return e.errno;\n    }\n  }\n  function _fd_fdstat_get(fd, pbuf) {\n    try {\n      var rightsBase = 0;\n      var rightsInheriting = 0;\n      var flags = 0;\n      {\n        var stream = SYSCALLS.getStreamFromFD(fd);\n        var type = stream.tty ? 2 : FS.isDir(stream.mode) ? 3 : FS.isLink(stream.mode) ? 7 : 4;\n      }\n      HEAP8[pbuf] = type;\n      HEAP16[pbuf + 2 >> 1] = flags;\n      HEAP64[pbuf + 8 >> 3] = BigInt(rightsBase);\n      HEAP64[pbuf + 16 >> 3] = BigInt(rightsInheriting);\n      return 0;\n    } catch (e) {\n      if (typeof FS == \"undefined\" || !(e.name === \"ErrnoError\")) throw e;\n      return e.errno;\n    }\n  }\n  var doReadv = (stream, iov, iovcnt, offset) => {\n    var ret = 0;\n    for (var i = 0; i < iovcnt; i++) {\n      var ptr = HEAPU32[iov >> 2];\n      var len = HEAPU32[iov + 4 >> 2];\n      iov += 8;\n      var curr = FS.read(stream, HEAP8, ptr, len, offset);\n      if (curr < 0) return -1;\n      ret += curr;\n      if (curr < len) break;\n      if (typeof offset != \"undefined\") {\n        offset += curr;\n      }\n    }\n    return ret;\n  };\n  function _fd_read(fd, iov, iovcnt, pnum) {\n    try {\n      var stream = SYSCALLS.getStreamFromFD(fd);\n      var num = doReadv(stream, iov, iovcnt);\n      HEAPU32[pnum >> 2] = num;\n      return 0;\n    } catch (e) {\n      if (typeof FS == \"undefined\" || !(e.name === \"ErrnoError\")) throw e;\n      return e.errno;\n    }\n  }\n  function _fd_seek(fd, offset, whence, newOffset) {\n    offset = bigintToI53Checked(offset);\n    try {\n      if (isNaN(offset)) return 61;\n      var stream = SYSCALLS.getStreamFromFD(fd);\n      FS.llseek(stream, offset, whence);\n      HEAP64[newOffset >> 3] = BigInt(stream.position);\n      if (stream.getdents && offset === 0 && whence === 0)\n        stream.getdents = null;\n      return 0;\n    } catch (e) {\n      if (typeof FS == \"undefined\" || !(e.name === \"ErrnoError\")) throw e;\n      return e.errno;\n    }\n  }\n  function _fd_sync(fd) {\n    try {\n      var stream = SYSCALLS.getStreamFromFD(fd);\n      if (stream.stream_ops?.fsync) {\n        return stream.stream_ops.fsync(stream);\n      }\n      return 0;\n    } catch (e) {\n      if (typeof FS == \"undefined\" || !(e.name === \"ErrnoError\")) throw e;\n      return e.errno;\n    }\n  }\n  var doWritev = (stream, iov, iovcnt, offset) => {\n    var ret = 0;\n    for (var i = 0; i < iovcnt; i++) {\n      var ptr = HEAPU32[iov >> 2];\n      var len = HEAPU32[iov + 4 >> 2];\n      iov += 8;\n      var curr = FS.write(stream, HEAP8, ptr, len, offset);\n      if (curr < 0) return -1;\n      ret += curr;\n      if (curr < len) {\n        break;\n      }\n      if (typeof offset != \"undefined\") {\n        offset += curr;\n      }\n    }\n    return ret;\n  };\n  function _fd_write(fd, iov, iovcnt, pnum) {\n    try {\n      var stream = SYSCALLS.getStreamFromFD(fd);\n      var num = doWritev(stream, iov, iovcnt);\n      HEAPU32[pnum >> 2] = num;\n      return 0;\n    } catch (e) {\n      if (typeof FS == \"undefined\" || !(e.name === \"ErrnoError\")) throw e;\n      return e.errno;\n    }\n  }\n  FS.createPreloadedFile = FS_createPreloadedFile;\n  FS.preloadFile = FS_preloadFile;\n  FS.staticInit();\n  {\n    initMemory();\n    if (Module[\"noExitRuntime\"]) noExitRuntime = Module[\"noExitRuntime\"];\n    if (Module[\"preloadPlugins\"]) preloadPlugins = Module[\"preloadPlugins\"];\n    if (Module[\"print\"]) out = Module[\"print\"];\n    if (Module[\"printErr\"]) err = Module[\"printErr\"];\n    if (Module[\"wasmBinary\"]) wasmBinary = Module[\"wasmBinary\"];\n    if (Module[\"arguments\"]) arguments_ = Module[\"arguments\"];\n    if (Module[\"thisProgram\"]) thisProgram = Module[\"thisProgram\"];\n    if (Module[\"preInit\"]) {\n      if (typeof Module[\"preInit\"] == \"function\")\n        Module[\"preInit\"] = [Module[\"preInit\"]];\n      while (Module[\"preInit\"].length > 0) {\n        Module[\"preInit\"].shift()();\n      }\n    }\n  }\n  Module[\"wasmMemory\"] = wasmMemory;\n  var _sqlite3_status64, _sqlite3_status, _sqlite3_db_status64, _sqlite3_msize, _sqlite3_db_status, _sqlite3_vfs_find, _sqlite3_initialize, _sqlite3_malloc, _sqlite3_free, _sqlite3_vfs_register, _sqlite3_vfs_unregister, _sqlite3_malloc64, _sqlite3_realloc, _sqlite3_realloc64, _sqlite3_value_text, _sqlite3_randomness, _sqlite3_stricmp, _sqlite3_strnicmp, _sqlite3_uri_parameter, _sqlite3_uri_boolean, _sqlite3_serialize, _sqlite3_prepare_v2, _sqlite3_step, _sqlite3_column_int64, _sqlite3_reset, _sqlite3_exec, _sqlite3_column_int, _sqlite3_finalize, _sqlite3_file_control, _sqlite3_column_name, _sqlite3_column_text, _sqlite3_column_type, _sqlite3_errmsg, _sqlite3_deserialize, _sqlite3_clear_bindings, _sqlite3_value_blob, _sqlite3_value_bytes, _sqlite3_value_double, _sqlite3_value_int, _sqlite3_value_int64, _sqlite3_value_subtype, _sqlite3_value_pointer, _sqlite3_value_type, _sqlite3_value_nochange, _sqlite3_value_frombind, _sqlite3_value_dup, _sqlite3_value_free, _sqlite3_result_blob, _sqlite3_result_error_toobig, _sqlite3_result_error_nomem, _sqlite3_result_double, _sqlite3_result_error, _sqlite3_result_int, _sqlite3_result_int64, _sqlite3_result_null, _sqlite3_result_pointer, _sqlite3_result_subtype, _sqlite3_result_text, _sqlite3_result_zeroblob, _sqlite3_result_zeroblob64, _sqlite3_result_error_code, _sqlite3_user_data, _sqlite3_context_db_handle, _sqlite3_vtab_nochange, _sqlite3_vtab_in_first, _sqlite3_vtab_in_next, _sqlite3_aggregate_context, _sqlite3_get_auxdata, _sqlite3_set_auxdata, _sqlite3_column_count, _sqlite3_data_count, _sqlite3_column_blob, _sqlite3_column_bytes, _sqlite3_column_double, _sqlite3_column_value, _sqlite3_column_decltype, _sqlite3_column_database_name, _sqlite3_column_table_name, _sqlite3_column_origin_name, _sqlite3_bind_blob, _sqlite3_bind_double, _sqlite3_bind_int, _sqlite3_bind_int64, _sqlite3_bind_null, _sqlite3_bind_pointer, _sqlite3_bind_text, _sqlite3_bind_parameter_count, _sqlite3_bind_parameter_name, _sqlite3_bind_parameter_index, _sqlite3_db_handle, _sqlite3_stmt_readonly, _sqlite3_stmt_isexplain, _sqlite3_stmt_explain, _sqlite3_stmt_busy, _sqlite3_stmt_status, _sqlite3_sql, _sqlite3_expanded_sql, _sqlite3_preupdate_old, _sqlite3_preupdate_count, _sqlite3_preupdate_depth, _sqlite3_preupdate_blobwrite, _sqlite3_preupdate_new, _sqlite3_value_numeric_type, _sqlite3_set_authorizer, _sqlite3_strglob, _sqlite3_strlike, _sqlite3_auto_extension, _sqlite3_cancel_auto_extension, _sqlite3_reset_auto_extension, _sqlite3_prepare_v3, _sqlite3_create_module, _sqlite3_create_module_v2, _sqlite3_drop_modules, _sqlite3_declare_vtab, _sqlite3_vtab_on_conflict, _sqlite3_vtab_collation, _sqlite3_vtab_in, _sqlite3_vtab_rhs_value, _sqlite3_vtab_distinct, _sqlite3_keyword_name, _sqlite3_keyword_count, _sqlite3_keyword_check, _sqlite3_complete, _sqlite3_libversion, _sqlite3_libversion_number, _sqlite3_shutdown, _sqlite3_last_insert_rowid, _sqlite3_set_last_insert_rowid, _sqlite3_changes64, _sqlite3_changes, _sqlite3_total_changes64, _sqlite3_total_changes, _sqlite3_txn_state, _sqlite3_close_v2, _sqlite3_busy_handler, _sqlite3_progress_handler, _sqlite3_busy_timeout, _sqlite3_interrupt, _sqlite3_is_interrupted, _sqlite3_create_function, _sqlite3_create_function_v2, _sqlite3_create_window_function, _sqlite3_overload_function, _sqlite3_trace_v2, _sqlite3_commit_hook, _sqlite3_update_hook, _sqlite3_rollback_hook, _sqlite3_preupdate_hook, _sqlite3_set_errmsg, _sqlite3_error_offset, _sqlite3_errcode, _sqlite3_extended_errcode, _sqlite3_errstr, _sqlite3_limit, _sqlite3_open, _sqlite3_open_v2, _sqlite3_create_collation, _sqlite3_create_collation_v2, _sqlite3_collation_needed, _sqlite3_get_autocommit, _sqlite3_table_column_metadata, _sqlite3_extended_result_codes, _sqlite3_uri_key, _sqlite3_uri_int64, _sqlite3_db_name, _sqlite3_db_filename, _sqlite3_db_readonly, _sqlite3_compileoption_used, _sqlite3_compileoption_get, _sqlite3session_diff, _sqlite3session_attach, _sqlite3session_create, _sqlite3session_delete, _sqlite3session_table_filter, _sqlite3session_changeset, _sqlite3session_changeset_strm, _sqlite3session_patchset_strm, _sqlite3session_patchset, _sqlite3session_enable, _sqlite3session_indirect, _sqlite3session_isempty, _sqlite3session_memory_used, _sqlite3session_object_config, _sqlite3session_changeset_size, _sqlite3changeset_start, _sqlite3changeset_start_v2, _sqlite3changeset_start_strm, _sqlite3changeset_start_v2_strm, _sqlite3changeset_next, _sqlite3changeset_op, _sqlite3changeset_pk, _sqlite3changeset_old, _sqlite3changeset_new, _sqlite3changeset_conflict, _sqlite3changeset_fk_conflicts, _sqlite3changeset_finalize, _sqlite3changeset_invert, _sqlite3changeset_invert_strm, _sqlite3changeset_apply_v2, _sqlite3changeset_apply_v3, _sqlite3changeset_apply, _sqlite3changeset_apply_v3_strm, _sqlite3changeset_apply_v2_strm, _sqlite3changeset_apply_strm, _sqlite3changegroup_new, _sqlite3changegroup_add, _sqlite3changegroup_output, _sqlite3changegroup_add_strm, _sqlite3changegroup_output_strm, _sqlite3changegroup_delete, _sqlite3changeset_concat, _sqlite3changeset_concat_strm, _sqlite3session_config, _sqlite3_sourceid, _sqlite3__wasm_pstack_ptr, _sqlite3__wasm_pstack_restore, _sqlite3__wasm_pstack_alloc, _sqlite3__wasm_pstack_remaining, _sqlite3__wasm_pstack_quota, _sqlite3__wasm_test_struct, _sqlite3__wasm_enum_json, _sqlite3__wasm_vfs_unlink, _sqlite3__wasm_db_vfs, _sqlite3__wasm_db_reset, _sqlite3__wasm_db_export_chunked, _sqlite3__wasm_db_serialize, _sqlite3__wasm_vfs_create_file, _sqlite3__wasm_posix_create_file, _sqlite3__wasm_kvvfsMakeKeyOnPstack, _sqlite3__wasm_kvvfs_methods, _sqlite3__wasm_vtab_config, _sqlite3__wasm_db_config_ip, _sqlite3__wasm_db_config_pii, _sqlite3__wasm_db_config_s, _sqlite3__wasm_config_i, _sqlite3__wasm_config_ii, _sqlite3__wasm_config_j, _sqlite3__wasm_qfmt_token, _sqlite3__wasm_init_wasmfs, _sqlite3__wasm_test_intptr, _sqlite3__wasm_test_voidptr, _sqlite3__wasm_test_int64_max, _sqlite3__wasm_test_int64_min, _sqlite3__wasm_test_int64_times2, _sqlite3__wasm_test_int64_minmax, _sqlite3__wasm_test_int64ptr, _sqlite3__wasm_test_stack_overflow, _sqlite3__wasm_test_str_hello, _sqlite3__wasm_SQLTester_strglob, _malloc, _free, _realloc, _emscripten_builtin_memalign, __emscripten_stack_restore, __emscripten_stack_alloc, _emscripten_stack_get_current, __indirect_function_table;\n  function assignWasmExports(wasmExports2) {\n    _sqlite3_status64 = Module[\"_sqlite3_status64\"] = wasmExports2[\"sqlite3_status64\"];\n    _sqlite3_status = Module[\"_sqlite3_status\"] = wasmExports2[\"sqlite3_status\"];\n    _sqlite3_db_status64 = Module[\"_sqlite3_db_status64\"] = wasmExports2[\"sqlite3_db_status64\"];\n    _sqlite3_msize = Module[\"_sqlite3_msize\"] = wasmExports2[\"sqlite3_msize\"];\n    _sqlite3_db_status = Module[\"_sqlite3_db_status\"] = wasmExports2[\"sqlite3_db_status\"];\n    _sqlite3_vfs_find = Module[\"_sqlite3_vfs_find\"] = wasmExports2[\"sqlite3_vfs_find\"];\n    _sqlite3_initialize = Module[\"_sqlite3_initialize\"] = wasmExports2[\"sqlite3_initialize\"];\n    _sqlite3_malloc = Module[\"_sqlite3_malloc\"] = wasmExports2[\"sqlite3_malloc\"];\n    _sqlite3_free = Module[\"_sqlite3_free\"] = wasmExports2[\"sqlite3_free\"];\n    _sqlite3_vfs_register = Module[\"_sqlite3_vfs_register\"] = wasmExports2[\"sqlite3_vfs_register\"];\n    _sqlite3_vfs_unregister = Module[\"_sqlite3_vfs_unregister\"] = wasmExports2[\"sqlite3_vfs_unregister\"];\n    _sqlite3_malloc64 = Module[\"_sqlite3_malloc64\"] = wasmExports2[\"sqlite3_malloc64\"];\n    _sqlite3_realloc = Module[\"_sqlite3_realloc\"] = wasmExports2[\"sqlite3_realloc\"];\n    _sqlite3_realloc64 = Module[\"_sqlite3_realloc64\"] = wasmExports2[\"sqlite3_realloc64\"];\n    _sqlite3_value_text = Module[\"_sqlite3_value_text\"] = wasmExports2[\"sqlite3_value_text\"];\n    _sqlite3_randomness = Module[\"_sqlite3_randomness\"] = wasmExports2[\"sqlite3_randomness\"];\n    _sqlite3_stricmp = Module[\"_sqlite3_stricmp\"] = wasmExports2[\"sqlite3_stricmp\"];\n    _sqlite3_strnicmp = Module[\"_sqlite3_strnicmp\"] = wasmExports2[\"sqlite3_strnicmp\"];\n    _sqlite3_uri_parameter = Module[\"_sqlite3_uri_parameter\"] = wasmExports2[\"sqlite3_uri_parameter\"];\n    _sqlite3_uri_boolean = Module[\"_sqlite3_uri_boolean\"] = wasmExports2[\"sqlite3_uri_boolean\"];\n    _sqlite3_serialize = Module[\"_sqlite3_serialize\"] = wasmExports2[\"sqlite3_serialize\"];\n    _sqlite3_prepare_v2 = Module[\"_sqlite3_prepare_v2\"] = wasmExports2[\"sqlite3_prepare_v2\"];\n    _sqlite3_step = Module[\"_sqlite3_step\"] = wasmExports2[\"sqlite3_step\"];\n    _sqlite3_column_int64 = Module[\"_sqlite3_column_int64\"] = wasmExports2[\"sqlite3_column_int64\"];\n    _sqlite3_reset = Module[\"_sqlite3_reset\"] = wasmExports2[\"sqlite3_reset\"];\n    _sqlite3_exec = Module[\"_sqlite3_exec\"] = wasmExports2[\"sqlite3_exec\"];\n    _sqlite3_column_int = Module[\"_sqlite3_column_int\"] = wasmExports2[\"sqlite3_column_int\"];\n    _sqlite3_finalize = Module[\"_sqlite3_finalize\"] = wasmExports2[\"sqlite3_finalize\"];\n    _sqlite3_file_control = Module[\"_sqlite3_file_control\"] = wasmExports2[\"sqlite3_file_control\"];\n    _sqlite3_column_name = Module[\"_sqlite3_column_name\"] = wasmExports2[\"sqlite3_column_name\"];\n    _sqlite3_column_text = Module[\"_sqlite3_column_text\"] = wasmExports2[\"sqlite3_column_text\"];\n    _sqlite3_column_type = Module[\"_sqlite3_column_type\"] = wasmExports2[\"sqlite3_column_type\"];\n    _sqlite3_errmsg = Module[\"_sqlite3_errmsg\"] = wasmExports2[\"sqlite3_errmsg\"];\n    _sqlite3_deserialize = Module[\"_sqlite3_deserialize\"] = wasmExports2[\"sqlite3_deserialize\"];\n    _sqlite3_clear_bindings = Module[\"_sqlite3_clear_bindings\"] = wasmExports2[\"sqlite3_clear_bindings\"];\n    _sqlite3_value_blob = Module[\"_sqlite3_value_blob\"] = wasmExports2[\"sqlite3_value_blob\"];\n    _sqlite3_value_bytes = Module[\"_sqlite3_value_bytes\"] = wasmExports2[\"sqlite3_value_bytes\"];\n    _sqlite3_value_double = Module[\"_sqlite3_value_double\"] = wasmExports2[\"sqlite3_value_double\"];\n    _sqlite3_value_int = Module[\"_sqlite3_value_int\"] = wasmExports2[\"sqlite3_value_int\"];\n    _sqlite3_value_int64 = Module[\"_sqlite3_value_int64\"] = wasmExports2[\"sqlite3_value_int64\"];\n    _sqlite3_value_subtype = Module[\"_sqlite3_value_subtype\"] = wasmExports2[\"sqlite3_value_subtype\"];\n    _sqlite3_value_pointer = Module[\"_sqlite3_value_pointer\"] = wasmExports2[\"sqlite3_value_pointer\"];\n    _sqlite3_value_type = Module[\"_sqlite3_value_type\"] = wasmExports2[\"sqlite3_value_type\"];\n    _sqlite3_value_nochange = Module[\"_sqlite3_value_nochange\"] = wasmExports2[\"sqlite3_value_nochange\"];\n    _sqlite3_value_frombind = Module[\"_sqlite3_value_frombind\"] = wasmExports2[\"sqlite3_value_frombind\"];\n    _sqlite3_value_dup = Module[\"_sqlite3_value_dup\"] = wasmExports2[\"sqlite3_value_dup\"];\n    _sqlite3_value_free = Module[\"_sqlite3_value_free\"] = wasmExports2[\"sqlite3_value_free\"];\n    _sqlite3_result_blob = Module[\"_sqlite3_result_blob\"] = wasmExports2[\"sqlite3_result_blob\"];\n    _sqlite3_result_error_toobig = Module[\"_sqlite3_result_error_toobig\"] = wasmExports2[\"sqlite3_result_error_toobig\"];\n    _sqlite3_result_error_nomem = Module[\"_sqlite3_result_error_nomem\"] = wasmExports2[\"sqlite3_result_error_nomem\"];\n    _sqlite3_result_double = Module[\"_sqlite3_result_double\"] = wasmExports2[\"sqlite3_result_double\"];\n    _sqlite3_result_error = Module[\"_sqlite3_result_error\"] = wasmExports2[\"sqlite3_result_error\"];\n    _sqlite3_result_int = Module[\"_sqlite3_result_int\"] = wasmExports2[\"sqlite3_result_int\"];\n    _sqlite3_result_int64 = Module[\"_sqlite3_result_int64\"] = wasmExports2[\"sqlite3_result_int64\"];\n    _sqlite3_result_null = Module[\"_sqlite3_result_null\"] = wasmExports2[\"sqlite3_result_null\"];\n    _sqlite3_result_pointer = Module[\"_sqlite3_result_pointer\"] = wasmExports2[\"sqlite3_result_pointer\"];\n    _sqlite3_result_subtype = Module[\"_sqlite3_result_subtype\"] = wasmExports2[\"sqlite3_result_subtype\"];\n    _sqlite3_result_text = Module[\"_sqlite3_result_text\"] = wasmExports2[\"sqlite3_result_text\"];\n    _sqlite3_result_zeroblob = Module[\"_sqlite3_result_zeroblob\"] = wasmExports2[\"sqlite3_result_zeroblob\"];\n    _sqlite3_result_zeroblob64 = Module[\"_sqlite3_result_zeroblob64\"] = wasmExports2[\"sqlite3_result_zeroblob64\"];\n    _sqlite3_result_error_code = Module[\"_sqlite3_result_error_code\"] = wasmExports2[\"sqlite3_result_error_code\"];\n    _sqlite3_user_data = Module[\"_sqlite3_user_data\"] = wasmExports2[\"sqlite3_user_data\"];\n    _sqlite3_context_db_handle = Module[\"_sqlite3_context_db_handle\"] = wasmExports2[\"sqlite3_context_db_handle\"];\n    _sqlite3_vtab_nochange = Module[\"_sqlite3_vtab_nochange\"] = wasmExports2[\"sqlite3_vtab_nochange\"];\n    _sqlite3_vtab_in_first = Module[\"_sqlite3_vtab_in_first\"] = wasmExports2[\"sqlite3_vtab_in_first\"];\n    _sqlite3_vtab_in_next = Module[\"_sqlite3_vtab_in_next\"] = wasmExports2[\"sqlite3_vtab_in_next\"];\n    _sqlite3_aggregate_context = Module[\"_sqlite3_aggregate_context\"] = wasmExports2[\"sqlite3_aggregate_context\"];\n    _sqlite3_get_auxdata = Module[\"_sqlite3_get_auxdata\"] = wasmExports2[\"sqlite3_get_auxdata\"];\n    _sqlite3_set_auxdata = Module[\"_sqlite3_set_auxdata\"] = wasmExports2[\"sqlite3_set_auxdata\"];\n    _sqlite3_column_count = Module[\"_sqlite3_column_count\"] = wasmExports2[\"sqlite3_column_count\"];\n    _sqlite3_data_count = Module[\"_sqlite3_data_count\"] = wasmExports2[\"sqlite3_data_count\"];\n    _sqlite3_column_blob = Module[\"_sqlite3_column_blob\"] = wasmExports2[\"sqlite3_column_blob\"];\n    _sqlite3_column_bytes = Module[\"_sqlite3_column_bytes\"] = wasmExports2[\"sqlite3_column_bytes\"];\n    _sqlite3_column_double = Module[\"_sqlite3_column_double\"] = wasmExports2[\"sqlite3_column_double\"];\n    _sqlite3_column_value = Module[\"_sqlite3_column_value\"] = wasmExports2[\"sqlite3_column_value\"];\n    _sqlite3_column_decltype = Module[\"_sqlite3_column_decltype\"] = wasmExports2[\"sqlite3_column_decltype\"];\n    _sqlite3_column_database_name = Module[\"_sqlite3_column_database_name\"] = wasmExports2[\"sqlite3_column_database_name\"];\n    _sqlite3_column_table_name = Module[\"_sqlite3_column_table_name\"] = wasmExports2[\"sqlite3_column_table_name\"];\n    _sqlite3_column_origin_name = Module[\"_sqlite3_column_origin_name\"] = wasmExports2[\"sqlite3_column_origin_name\"];\n    _sqlite3_bind_blob = Module[\"_sqlite3_bind_blob\"] = wasmExports2[\"sqlite3_bind_blob\"];\n    _sqlite3_bind_double = Module[\"_sqlite3_bind_double\"] = wasmExports2[\"sqlite3_bind_double\"];\n    _sqlite3_bind_int = Module[\"_sqlite3_bind_int\"] = wasmExports2[\"sqlite3_bind_int\"];\n    _sqlite3_bind_int64 = Module[\"_sqlite3_bind_int64\"] = wasmExports2[\"sqlite3_bind_int64\"];\n    _sqlite3_bind_null = Module[\"_sqlite3_bind_null\"] = wasmExports2[\"sqlite3_bind_null\"];\n    _sqlite3_bind_pointer = Module[\"_sqlite3_bind_pointer\"] = wasmExports2[\"sqlite3_bind_pointer\"];\n    _sqlite3_bind_text = Module[\"_sqlite3_bind_text\"] = wasmExports2[\"sqlite3_bind_text\"];\n    _sqlite3_bind_parameter_count = Module[\"_sqlite3_bind_parameter_count\"] = wasmExports2[\"sqlite3_bind_parameter_count\"];\n    _sqlite3_bind_parameter_name = Module[\"_sqlite3_bind_parameter_name\"] = wasmExports2[\"sqlite3_bind_parameter_name\"];\n    _sqlite3_bind_parameter_index = Module[\"_sqlite3_bind_parameter_index\"] = wasmExports2[\"sqlite3_bind_parameter_index\"];\n    _sqlite3_db_handle = Module[\"_sqlite3_db_handle\"] = wasmExports2[\"sqlite3_db_handle\"];\n    _sqlite3_stmt_readonly = Module[\"_sqlite3_stmt_readonly\"] = wasmExports2[\"sqlite3_stmt_readonly\"];\n    _sqlite3_stmt_isexplain = Module[\"_sqlite3_stmt_isexplain\"] = wasmExports2[\"sqlite3_stmt_isexplain\"];\n    _sqlite3_stmt_explain = Module[\"_sqlite3_stmt_explain\"] = wasmExports2[\"sqlite3_stmt_explain\"];\n    _sqlite3_stmt_busy = Module[\"_sqlite3_stmt_busy\"] = wasmExports2[\"sqlite3_stmt_busy\"];\n    _sqlite3_stmt_status = Module[\"_sqlite3_stmt_status\"] = wasmExports2[\"sqlite3_stmt_status\"];\n    _sqlite3_sql = Module[\"_sqlite3_sql\"] = wasmExports2[\"sqlite3_sql\"];\n    _sqlite3_expanded_sql = Module[\"_sqlite3_expanded_sql\"] = wasmExports2[\"sqlite3_expanded_sql\"];\n    _sqlite3_preupdate_old = Module[\"_sqlite3_preupdate_old\"] = wasmExports2[\"sqlite3_preupdate_old\"];\n    _sqlite3_preupdate_count = Module[\"_sqlite3_preupdate_count\"] = wasmExports2[\"sqlite3_preupdate_count\"];\n    _sqlite3_preupdate_depth = Module[\"_sqlite3_preupdate_depth\"] = wasmExports2[\"sqlite3_preupdate_depth\"];\n    _sqlite3_preupdate_blobwrite = Module[\"_sqlite3_preupdate_blobwrite\"] = wasmExports2[\"sqlite3_preupdate_blobwrite\"];\n    _sqlite3_preupdate_new = Module[\"_sqlite3_preupdate_new\"] = wasmExports2[\"sqlite3_preupdate_new\"];\n    _sqlite3_value_numeric_type = Module[\"_sqlite3_value_numeric_type\"] = wasmExports2[\"sqlite3_value_numeric_type\"];\n    _sqlite3_set_authorizer = Module[\"_sqlite3_set_authorizer\"] = wasmExports2[\"sqlite3_set_authorizer\"];\n    _sqlite3_strglob = Module[\"_sqlite3_strglob\"] = wasmExports2[\"sqlite3_strglob\"];\n    _sqlite3_strlike = Module[\"_sqlite3_strlike\"] = wasmExports2[\"sqlite3_strlike\"];\n    _sqlite3_auto_extension = Module[\"_sqlite3_auto_extension\"] = wasmExports2[\"sqlite3_auto_extension\"];\n    _sqlite3_cancel_auto_extension = Module[\"_sqlite3_cancel_auto_extension\"] = wasmExports2[\"sqlite3_cancel_auto_extension\"];\n    _sqlite3_reset_auto_extension = Module[\"_sqlite3_reset_auto_extension\"] = wasmExports2[\"sqlite3_reset_auto_extension\"];\n    _sqlite3_prepare_v3 = Module[\"_sqlite3_prepare_v3\"] = wasmExports2[\"sqlite3_prepare_v3\"];\n    _sqlite3_create_module = Module[\"_sqlite3_create_module\"] = wasmExports2[\"sqlite3_create_module\"];\n    _sqlite3_create_module_v2 = Module[\"_sqlite3_create_module_v2\"] = wasmExports2[\"sqlite3_create_module_v2\"];\n    _sqlite3_drop_modules = Module[\"_sqlite3_drop_modules\"] = wasmExports2[\"sqlite3_drop_modules\"];\n    _sqlite3_declare_vtab = Module[\"_sqlite3_declare_vtab\"] = wasmExports2[\"sqlite3_declare_vtab\"];\n    _sqlite3_vtab_on_conflict = Module[\"_sqlite3_vtab_on_conflict\"] = wasmExports2[\"sqlite3_vtab_on_conflict\"];\n    _sqlite3_vtab_collation = Module[\"_sqlite3_vtab_collation\"] = wasmExports2[\"sqlite3_vtab_collation\"];\n    _sqlite3_vtab_in = Module[\"_sqlite3_vtab_in\"] = wasmExports2[\"sqlite3_vtab_in\"];\n    _sqlite3_vtab_rhs_value = Module[\"_sqlite3_vtab_rhs_value\"] = wasmExports2[\"sqlite3_vtab_rhs_value\"];\n    _sqlite3_vtab_distinct = Module[\"_sqlite3_vtab_distinct\"] = wasmExports2[\"sqlite3_vtab_distinct\"];\n    _sqlite3_keyword_name = Module[\"_sqlite3_keyword_name\"] = wasmExports2[\"sqlite3_keyword_name\"];\n    _sqlite3_keyword_count = Module[\"_sqlite3_keyword_count\"] = wasmExports2[\"sqlite3_keyword_count\"];\n    _sqlite3_keyword_check = Module[\"_sqlite3_keyword_check\"] = wasmExports2[\"sqlite3_keyword_check\"];\n    _sqlite3_complete = Module[\"_sqlite3_complete\"] = wasmExports2[\"sqlite3_complete\"];\n    _sqlite3_libversion = Module[\"_sqlite3_libversion\"] = wasmExports2[\"sqlite3_libversion\"];\n    _sqlite3_libversion_number = Module[\"_sqlite3_libversion_number\"] = wasmExports2[\"sqlite3_libversion_number\"];\n    _sqlite3_shutdown = Module[\"_sqlite3_shutdown\"] = wasmExports2[\"sqlite3_shutdown\"];\n    _sqlite3_last_insert_rowid = Module[\"_sqlite3_last_insert_rowid\"] = wasmExports2[\"sqlite3_last_insert_rowid\"];\n    _sqlite3_set_last_insert_rowid = Module[\"_sqlite3_set_last_insert_rowid\"] = wasmExports2[\"sqlite3_set_last_insert_rowid\"];\n    _sqlite3_changes64 = Module[\"_sqlite3_changes64\"] = wasmExports2[\"sqlite3_changes64\"];\n    _sqlite3_changes = Module[\"_sqlite3_changes\"] = wasmExports2[\"sqlite3_changes\"];\n    _sqlite3_total_changes64 = Module[\"_sqlite3_total_changes64\"] = wasmExports2[\"sqlite3_total_changes64\"];\n    _sqlite3_total_changes = Module[\"_sqlite3_total_changes\"] = wasmExports2[\"sqlite3_total_changes\"];\n    _sqlite3_txn_state = Module[\"_sqlite3_txn_state\"] = wasmExports2[\"sqlite3_txn_state\"];\n    _sqlite3_close_v2 = Module[\"_sqlite3_close_v2\"] = wasmExports2[\"sqlite3_close_v2\"];\n    _sqlite3_busy_handler = Module[\"_sqlite3_busy_handler\"] = wasmExports2[\"sqlite3_busy_handler\"];\n    _sqlite3_progress_handler = Module[\"_sqlite3_progress_handler\"] = wasmExports2[\"sqlite3_progress_handler\"];\n    _sqlite3_busy_timeout = Module[\"_sqlite3_busy_timeout\"] = wasmExports2[\"sqlite3_busy_timeout\"];\n    _sqlite3_interrupt = Module[\"_sqlite3_interrupt\"] = wasmExports2[\"sqlite3_interrupt\"];\n    _sqlite3_is_interrupted = Module[\"_sqlite3_is_interrupted\"] = wasmExports2[\"sqlite3_is_interrupted\"];\n    _sqlite3_create_function = Module[\"_sqlite3_create_function\"] = wasmExports2[\"sqlite3_create_function\"];\n    _sqlite3_create_function_v2 = Module[\"_sqlite3_create_function_v2\"] = wasmExports2[\"sqlite3_create_function_v2\"];\n    _sqlite3_create_window_function = Module[\"_sqlite3_create_window_function\"] = wasmExports2[\"sqlite3_create_window_function\"];\n    _sqlite3_overload_function = Module[\"_sqlite3_overload_function\"] = wasmExports2[\"sqlite3_overload_function\"];\n    _sqlite3_trace_v2 = Module[\"_sqlite3_trace_v2\"] = wasmExports2[\"sqlite3_trace_v2\"];\n    _sqlite3_commit_hook = Module[\"_sqlite3_commit_hook\"] = wasmExports2[\"sqlite3_commit_hook\"];\n    _sqlite3_update_hook = Module[\"_sqlite3_update_hook\"] = wasmExports2[\"sqlite3_update_hook\"];\n    _sqlite3_rollback_hook = Module[\"_sqlite3_rollback_hook\"] = wasmExports2[\"sqlite3_rollback_hook\"];\n    _sqlite3_preupdate_hook = Module[\"_sqlite3_preupdate_hook\"] = wasmExports2[\"sqlite3_preupdate_hook\"];\n    _sqlite3_set_errmsg = Module[\"_sqlite3_set_errmsg\"] = wasmExports2[\"sqlite3_set_errmsg\"];\n    _sqlite3_error_offset = Module[\"_sqlite3_error_offset\"] = wasmExports2[\"sqlite3_error_offset\"];\n    _sqlite3_errcode = Module[\"_sqlite3_errcode\"] = wasmExports2[\"sqlite3_errcode\"];\n    _sqlite3_extended_errcode = Module[\"_sqlite3_extended_errcode\"] = wasmExports2[\"sqlite3_extended_errcode\"];\n    _sqlite3_errstr = Module[\"_sqlite3_errstr\"] = wasmExports2[\"sqlite3_errstr\"];\n    _sqlite3_limit = Module[\"_sqlite3_limit\"] = wasmExports2[\"sqlite3_limit\"];\n    _sqlite3_open = Module[\"_sqlite3_open\"] = wasmExports2[\"sqlite3_open\"];\n    _sqlite3_open_v2 = Module[\"_sqlite3_open_v2\"] = wasmExports2[\"sqlite3_open_v2\"];\n    _sqlite3_create_collation = Module[\"_sqlite3_create_collation\"] = wasmExports2[\"sqlite3_create_collation\"];\n    _sqlite3_create_collation_v2 = Module[\"_sqlite3_create_collation_v2\"] = wasmExports2[\"sqlite3_create_collation_v2\"];\n    _sqlite3_collation_needed = Module[\"_sqlite3_collation_needed\"] = wasmExports2[\"sqlite3_collation_needed\"];\n    _sqlite3_get_autocommit = Module[\"_sqlite3_get_autocommit\"] = wasmExports2[\"sqlite3_get_autocommit\"];\n    _sqlite3_table_column_metadata = Module[\"_sqlite3_table_column_metadata\"] = wasmExports2[\"sqlite3_table_column_metadata\"];\n    _sqlite3_extended_result_codes = Module[\"_sqlite3_extended_result_codes\"] = wasmExports2[\"sqlite3_extended_result_codes\"];\n    _sqlite3_uri_key = Module[\"_sqlite3_uri_key\"] = wasmExports2[\"sqlite3_uri_key\"];\n    _sqlite3_uri_int64 = Module[\"_sqlite3_uri_int64\"] = wasmExports2[\"sqlite3_uri_int64\"];\n    _sqlite3_db_name = Module[\"_sqlite3_db_name\"] = wasmExports2[\"sqlite3_db_name\"];\n    _sqlite3_db_filename = Module[\"_sqlite3_db_filename\"] = wasmExports2[\"sqlite3_db_filename\"];\n    _sqlite3_db_readonly = Module[\"_sqlite3_db_readonly\"] = wasmExports2[\"sqlite3_db_readonly\"];\n    _sqlite3_compileoption_used = Module[\"_sqlite3_compileoption_used\"] = wasmExports2[\"sqlite3_compileoption_used\"];\n    _sqlite3_compileoption_get = Module[\"_sqlite3_compileoption_get\"] = wasmExports2[\"sqlite3_compileoption_get\"];\n    _sqlite3session_diff = Module[\"_sqlite3session_diff\"] = wasmExports2[\"sqlite3session_diff\"];\n    _sqlite3session_attach = Module[\"_sqlite3session_attach\"] = wasmExports2[\"sqlite3session_attach\"];\n    _sqlite3session_create = Module[\"_sqlite3session_create\"] = wasmExports2[\"sqlite3session_create\"];\n    _sqlite3session_delete = Module[\"_sqlite3session_delete\"] = wasmExports2[\"sqlite3session_delete\"];\n    _sqlite3session_table_filter = Module[\"_sqlite3session_table_filter\"] = wasmExports2[\"sqlite3session_table_filter\"];\n    _sqlite3session_changeset = Module[\"_sqlite3session_changeset\"] = wasmExports2[\"sqlite3session_changeset\"];\n    _sqlite3session_changeset_strm = Module[\"_sqlite3session_changeset_strm\"] = wasmExports2[\"sqlite3session_changeset_strm\"];\n    _sqlite3session_patchset_strm = Module[\"_sqlite3session_patchset_strm\"] = wasmExports2[\"sqlite3session_patchset_strm\"];\n    _sqlite3session_patchset = Module[\"_sqlite3session_patchset\"] = wasmExports2[\"sqlite3session_patchset\"];\n    _sqlite3session_enable = Module[\"_sqlite3session_enable\"] = wasmExports2[\"sqlite3session_enable\"];\n    _sqlite3session_indirect = Module[\"_sqlite3session_indirect\"] = wasmExports2[\"sqlite3session_indirect\"];\n    _sqlite3session_isempty = Module[\"_sqlite3session_isempty\"] = wasmExports2[\"sqlite3session_isempty\"];\n    _sqlite3session_memory_used = Module[\"_sqlite3session_memory_used\"] = wasmExports2[\"sqlite3session_memory_used\"];\n    _sqlite3session_object_config = Module[\"_sqlite3session_object_config\"] = wasmExports2[\"sqlite3session_object_config\"];\n    _sqlite3session_changeset_size = Module[\"_sqlite3session_changeset_size\"] = wasmExports2[\"sqlite3session_changeset_size\"];\n    _sqlite3changeset_start = Module[\"_sqlite3changeset_start\"] = wasmExports2[\"sqlite3changeset_start\"];\n    _sqlite3changeset_start_v2 = Module[\"_sqlite3changeset_start_v2\"] = wasmExports2[\"sqlite3changeset_start_v2\"];\n    _sqlite3changeset_start_strm = Module[\"_sqlite3changeset_start_strm\"] = wasmExports2[\"sqlite3changeset_start_strm\"];\n    _sqlite3changeset_start_v2_strm = Module[\"_sqlite3changeset_start_v2_strm\"] = wasmExports2[\"sqlite3changeset_start_v2_strm\"];\n    _sqlite3changeset_next = Module[\"_sqlite3changeset_next\"] = wasmExports2[\"sqlite3changeset_next\"];\n    _sqlite3changeset_op = Module[\"_sqlite3changeset_op\"] = wasmExports2[\"sqlite3changeset_op\"];\n    _sqlite3changeset_pk = Module[\"_sqlite3changeset_pk\"] = wasmExports2[\"sqlite3changeset_pk\"];\n    _sqlite3changeset_old = Module[\"_sqlite3changeset_old\"] = wasmExports2[\"sqlite3changeset_old\"];\n    _sqlite3changeset_new = Module[\"_sqlite3changeset_new\"] = wasmExports2[\"sqlite3changeset_new\"];\n    _sqlite3changeset_conflict = Module[\"_sqlite3changeset_conflict\"] = wasmExports2[\"sqlite3changeset_conflict\"];\n    _sqlite3changeset_fk_conflicts = Module[\"_sqlite3changeset_fk_conflicts\"] = wasmExports2[\"sqlite3changeset_fk_conflicts\"];\n    _sqlite3changeset_finalize = Module[\"_sqlite3changeset_finalize\"] = wasmExports2[\"sqlite3changeset_finalize\"];\n    _sqlite3changeset_invert = Module[\"_sqlite3changeset_invert\"] = wasmExports2[\"sqlite3changeset_invert\"];\n    _sqlite3changeset_invert_strm = Module[\"_sqlite3changeset_invert_strm\"] = wasmExports2[\"sqlite3changeset_invert_strm\"];\n    _sqlite3changeset_apply_v2 = Module[\"_sqlite3changeset_apply_v2\"] = wasmExports2[\"sqlite3changeset_apply_v2\"];\n    _sqlite3changeset_apply_v3 = Module[\"_sqlite3changeset_apply_v3\"] = wasmExports2[\"sqlite3changeset_apply_v3\"];\n    _sqlite3changeset_apply = Module[\"_sqlite3changeset_apply\"] = wasmExports2[\"sqlite3changeset_apply\"];\n    _sqlite3changeset_apply_v3_strm = Module[\"_sqlite3changeset_apply_v3_strm\"] = wasmExports2[\"sqlite3changeset_apply_v3_strm\"];\n    _sqlite3changeset_apply_v2_strm = Module[\"_sqlite3changeset_apply_v2_strm\"] = wasmExports2[\"sqlite3changeset_apply_v2_strm\"];\n    _sqlite3changeset_apply_strm = Module[\"_sqlite3changeset_apply_strm\"] = wasmExports2[\"sqlite3changeset_apply_strm\"];\n    _sqlite3changegroup_new = Module[\"_sqlite3changegroup_new\"] = wasmExports2[\"sqlite3changegroup_new\"];\n    _sqlite3changegroup_add = Module[\"_sqlite3changegroup_add\"] = wasmExports2[\"sqlite3changegroup_add\"];\n    _sqlite3changegroup_output = Module[\"_sqlite3changegroup_output\"] = wasmExports2[\"sqlite3changegroup_output\"];\n    _sqlite3changegroup_add_strm = Module[\"_sqlite3changegroup_add_strm\"] = wasmExports2[\"sqlite3changegroup_add_strm\"];\n    _sqlite3changegroup_output_strm = Module[\"_sqlite3changegroup_output_strm\"] = wasmExports2[\"sqlite3changegroup_output_strm\"];\n    _sqlite3changegroup_delete = Module[\"_sqlite3changegroup_delete\"] = wasmExports2[\"sqlite3changegroup_delete\"];\n    _sqlite3changeset_concat = Module[\"_sqlite3changeset_concat\"] = wasmExports2[\"sqlite3changeset_concat\"];\n    _sqlite3changeset_concat_strm = Module[\"_sqlite3changeset_concat_strm\"] = wasmExports2[\"sqlite3changeset_concat_strm\"];\n    _sqlite3session_config = Module[\"_sqlite3session_config\"] = wasmExports2[\"sqlite3session_config\"];\n    _sqlite3_sourceid = Module[\"_sqlite3_sourceid\"] = wasmExports2[\"sqlite3_sourceid\"];\n    _sqlite3__wasm_pstack_ptr = Module[\"_sqlite3__wasm_pstack_ptr\"] = wasmExports2[\"sqlite3__wasm_pstack_ptr\"];\n    _sqlite3__wasm_pstack_restore = Module[\"_sqlite3__wasm_pstack_restore\"] = wasmExports2[\"sqlite3__wasm_pstack_restore\"];\n    _sqlite3__wasm_pstack_alloc = Module[\"_sqlite3__wasm_pstack_alloc\"] = wasmExports2[\"sqlite3__wasm_pstack_alloc\"];\n    _sqlite3__wasm_pstack_remaining = Module[\"_sqlite3__wasm_pstack_remaining\"] = wasmExports2[\"sqlite3__wasm_pstack_remaining\"];\n    _sqlite3__wasm_pstack_quota = Module[\"_sqlite3__wasm_pstack_quota\"] = wasmExports2[\"sqlite3__wasm_pstack_quota\"];\n    _sqlite3__wasm_test_struct = Module[\"_sqlite3__wasm_test_struct\"] = wasmExports2[\"sqlite3__wasm_test_struct\"];\n    _sqlite3__wasm_enum_json = Module[\"_sqlite3__wasm_enum_json\"] = wasmExports2[\"sqlite3__wasm_enum_json\"];\n    _sqlite3__wasm_vfs_unlink = Module[\"_sqlite3__wasm_vfs_unlink\"] = wasmExports2[\"sqlite3__wasm_vfs_unlink\"];\n    _sqlite3__wasm_db_vfs = Module[\"_sqlite3__wasm_db_vfs\"] = wasmExports2[\"sqlite3__wasm_db_vfs\"];\n    _sqlite3__wasm_db_reset = Module[\"_sqlite3__wasm_db_reset\"] = wasmExports2[\"sqlite3__wasm_db_reset\"];\n    _sqlite3__wasm_db_export_chunked = Module[\"_sqlite3__wasm_db_export_chunked\"] = wasmExports2[\"sqlite3__wasm_db_export_chunked\"];\n    _sqlite3__wasm_db_serialize = Module[\"_sqlite3__wasm_db_serialize\"] = wasmExports2[\"sqlite3__wasm_db_serialize\"];\n    _sqlite3__wasm_vfs_create_file = Module[\"_sqlite3__wasm_vfs_create_file\"] = wasmExports2[\"sqlite3__wasm_vfs_create_file\"];\n    _sqlite3__wasm_posix_create_file = Module[\"_sqlite3__wasm_posix_create_file\"] = wasmExports2[\"sqlite3__wasm_posix_create_file\"];\n    _sqlite3__wasm_kvvfsMakeKeyOnPstack = Module[\"_sqlite3__wasm_kvvfsMakeKeyOnPstack\"] = wasmExports2[\"sqlite3__wasm_kvvfsMakeKeyOnPstack\"];\n    _sqlite3__wasm_kvvfs_methods = Module[\"_sqlite3__wasm_kvvfs_methods\"] = wasmExports2[\"sqlite3__wasm_kvvfs_methods\"];\n    _sqlite3__wasm_vtab_config = Module[\"_sqlite3__wasm_vtab_config\"] = wasmExports2[\"sqlite3__wasm_vtab_config\"];\n    _sqlite3__wasm_db_config_ip = Module[\"_sqlite3__wasm_db_config_ip\"] = wasmExports2[\"sqlite3__wasm_db_config_ip\"];\n    _sqlite3__wasm_db_config_pii = Module[\"_sqlite3__wasm_db_config_pii\"] = wasmExports2[\"sqlite3__wasm_db_config_pii\"];\n    _sqlite3__wasm_db_config_s = Module[\"_sqlite3__wasm_db_config_s\"] = wasmExports2[\"sqlite3__wasm_db_config_s\"];\n    _sqlite3__wasm_config_i = Module[\"_sqlite3__wasm_config_i\"] = wasmExports2[\"sqlite3__wasm_config_i\"];\n    _sqlite3__wasm_config_ii = Module[\"_sqlite3__wasm_config_ii\"] = wasmExports2[\"sqlite3__wasm_config_ii\"];\n    _sqlite3__wasm_config_j = Module[\"_sqlite3__wasm_config_j\"] = wasmExports2[\"sqlite3__wasm_config_j\"];\n    _sqlite3__wasm_qfmt_token = Module[\"_sqlite3__wasm_qfmt_token\"] = wasmExports2[\"sqlite3__wasm_qfmt_token\"];\n    _sqlite3__wasm_init_wasmfs = Module[\"_sqlite3__wasm_init_wasmfs\"] = wasmExports2[\"sqlite3__wasm_init_wasmfs\"];\n    _sqlite3__wasm_test_intptr = Module[\"_sqlite3__wasm_test_intptr\"] = wasmExports2[\"sqlite3__wasm_test_intptr\"];\n    _sqlite3__wasm_test_voidptr = Module[\"_sqlite3__wasm_test_voidptr\"] = wasmExports2[\"sqlite3__wasm_test_voidptr\"];\n    _sqlite3__wasm_test_int64_max = Module[\"_sqlite3__wasm_test_int64_max\"] = wasmExports2[\"sqlite3__wasm_test_int64_max\"];\n    _sqlite3__wasm_test_int64_min = Module[\"_sqlite3__wasm_test_int64_min\"] = wasmExports2[\"sqlite3__wasm_test_int64_min\"];\n    _sqlite3__wasm_test_int64_times2 = Module[\"_sqlite3__wasm_test_int64_times2\"] = wasmExports2[\"sqlite3__wasm_test_int64_times2\"];\n    _sqlite3__wasm_test_int64_minmax = Module[\"_sqlite3__wasm_test_int64_minmax\"] = wasmExports2[\"sqlite3__wasm_test_int64_minmax\"];\n    _sqlite3__wasm_test_int64ptr = Module[\"_sqlite3__wasm_test_int64ptr\"] = wasmExports2[\"sqlite3__wasm_test_int64ptr\"];\n    _sqlite3__wasm_test_stack_overflow = Module[\"_sqlite3__wasm_test_stack_overflow\"] = wasmExports2[\"sqlite3__wasm_test_stack_overflow\"];\n    _sqlite3__wasm_test_str_hello = Module[\"_sqlite3__wasm_test_str_hello\"] = wasmExports2[\"sqlite3__wasm_test_str_hello\"];\n    _sqlite3__wasm_SQLTester_strglob = Module[\"_sqlite3__wasm_SQLTester_strglob\"] = wasmExports2[\"sqlite3__wasm_SQLTester_strglob\"];\n    _malloc = Module[\"_malloc\"] = wasmExports2[\"malloc\"];\n    _free = Module[\"_free\"] = wasmExports2[\"free\"];\n    _realloc = Module[\"_realloc\"] = wasmExports2[\"realloc\"];\n    _emscripten_builtin_memalign = wasmExports2[\"emscripten_builtin_memalign\"];\n    __emscripten_stack_restore = wasmExports2[\"_emscripten_stack_restore\"];\n    __emscripten_stack_alloc = wasmExports2[\"_emscripten_stack_alloc\"];\n    _emscripten_stack_get_current = wasmExports2[\"emscripten_stack_get_current\"];\n    __indirect_function_table = wasmExports2[\"__indirect_function_table\"];\n  }\n  var wasmImports = {\n    __syscall_chmod: ___syscall_chmod,\n    __syscall_faccessat: ___syscall_faccessat,\n    __syscall_fchmod: ___syscall_fchmod,\n    __syscall_fchown32: ___syscall_fchown32,\n    __syscall_fcntl64: ___syscall_fcntl64,\n    __syscall_fstat64: ___syscall_fstat64,\n    __syscall_ftruncate64: ___syscall_ftruncate64,\n    __syscall_getcwd: ___syscall_getcwd,\n    __syscall_ioctl: ___syscall_ioctl,\n    __syscall_lstat64: ___syscall_lstat64,\n    __syscall_mkdirat: ___syscall_mkdirat,\n    __syscall_newfstatat: ___syscall_newfstatat,\n    __syscall_openat: ___syscall_openat,\n    __syscall_readlinkat: ___syscall_readlinkat,\n    __syscall_rmdir: ___syscall_rmdir,\n    __syscall_stat64: ___syscall_stat64,\n    __syscall_unlinkat: ___syscall_unlinkat,\n    __syscall_utimensat: ___syscall_utimensat,\n    _localtime_js: __localtime_js,\n    _mmap_js: __mmap_js,\n    _munmap_js: __munmap_js,\n    _tzset_js: __tzset_js,\n    clock_time_get: _clock_time_get,\n    emscripten_date_now: _emscripten_date_now,\n    emscripten_get_heap_max: _emscripten_get_heap_max,\n    emscripten_get_now: _emscripten_get_now,\n    emscripten_resize_heap: _emscripten_resize_heap,\n    environ_get: _environ_get,\n    environ_sizes_get: _environ_sizes_get,\n    fd_close: _fd_close,\n    fd_fdstat_get: _fd_fdstat_get,\n    fd_read: _fd_read,\n    fd_seek: _fd_seek,\n    fd_sync: _fd_sync,\n    fd_write: _fd_write,\n    memory: wasmMemory\n  };\n  function run() {\n    if (runDependencies > 0) {\n      dependenciesFulfilled = run;\n      return;\n    }\n    preRun();\n    if (runDependencies > 0) {\n      dependenciesFulfilled = run;\n      return;\n    }\n    function doRun() {\n      Module[\"calledRun\"] = true;\n      if (ABORT) return;\n      initRuntime();\n      readyPromiseResolve?.(Module);\n      Module[\"onRuntimeInitialized\"]?.();\n      postRun();\n    }\n    if (Module[\"setStatus\"]) {\n      Module[\"setStatus\"](\"Running...\");\n      setTimeout(() => {\n        setTimeout(() => Module[\"setStatus\"](\"\"), 1);\n        doRun();\n      }, 1);\n    } else {\n      doRun();\n    }\n  }\n  var wasmExports;\n  wasmExports = await createWasm();\n  run();\n  Module.runSQLite3PostLoadInit = function(sqlite3InitScriptInfo, EmscriptenModule, sqlite3IsUnderTest) {\n    \"use strict\";\n    delete EmscriptenModule.runSQLite3PostLoadInit;\n    \"use strict\";\n    globalThis.sqlite3ApiBootstrap = async function sqlite3ApiBootstrap(apiConfig = globalThis.sqlite3ApiConfig || sqlite3ApiBootstrap.defaultConfig) {\n      if (sqlite3ApiBootstrap.sqlite3) {\n        (sqlite3ApiBootstrap.sqlite3.config || console).warn(\n          \"sqlite3ApiBootstrap() called multiple times.\",\n          \"Config and external initializers are ignored on calls after the first.\"\n        );\n        return sqlite3ApiBootstrap.sqlite3;\n      }\n      const config = Object.assign(\n        /* @__PURE__ */ Object.create(null),\n        {\n          exports: void 0,\n          memory: void 0,\n          bigIntEnabled: !!globalThis.BigInt64Array,\n          debug: console.debug.bind(console),\n          warn: console.warn.bind(console),\n          error: console.error.bind(console),\n          log: console.log.bind(console),\n          wasmfsOpfsDir: \"/opfs\",\n          useStdAlloc: false\n        },\n        apiConfig || {}\n      );\n      Object.assign(config, {\n        allocExportName: config.useStdAlloc ? \"malloc\" : \"sqlite3_malloc\",\n        deallocExportName: config.useStdAlloc ? \"free\" : \"sqlite3_free\",\n        reallocExportName: config.useStdAlloc ? \"realloc\" : \"sqlite3_realloc\"\n      });\n      [\"exports\", \"memory\", \"functionTable\", \"wasmfsOpfsDir\"].forEach((k) => {\n        if (\"function\" === typeof config[k]) {\n          config[k] = config[k]();\n        }\n      });\n      delete globalThis.sqlite3ApiConfig;\n      delete sqlite3ApiBootstrap.defaultConfig;\n      const capi = /* @__PURE__ */ Object.create(null);\n      const wasm = /* @__PURE__ */ Object.create(null);\n      const __rcStr = (rc) => {\n        return capi.sqlite3_js_rc_str && capi.sqlite3_js_rc_str(rc) || \"Unknown result code #\" + rc;\n      };\n      const isInt32 = (n) => \"number\" === typeof n && n === (n | 0) && n <= 2147483647 && n >= -2147483648;\n      class SQLite3Error extends Error {\n        constructor(...args) {\n          let rc;\n          if (args.length) {\n            if (isInt32(args[0])) {\n              rc = args[0];\n              if (1 === args.length) {\n                super(__rcStr(args[0]));\n              } else {\n                const rcStr = __rcStr(rc);\n                if (\"object\" === typeof args[1]) {\n                  super(rcStr, args[1]);\n                } else {\n                  args[0] = rcStr + \":\";\n                  super(args.join(\" \"));\n                }\n              }\n            } else {\n              if (2 === args.length && \"object\" === typeof args[1]) {\n                super(...args);\n              } else {\n                super(args.join(\" \"));\n              }\n            }\n          }\n          this.resultCode = rc || capi.SQLITE_ERROR;\n          this.name = \"SQLite3Error\";\n        }\n      }\n      SQLite3Error.toss = (...args) => {\n        throw new SQLite3Error(...args);\n      };\n      const toss3 = SQLite3Error.toss;\n      if (config.wasmfsOpfsDir && !/^\\/[^/]+$/.test(config.wasmfsOpfsDir)) {\n        toss3(\"config.wasmfsOpfsDir must be falsy or in the form '/dir-name'.\");\n      }\n      const bigIntFits64 = function f(b) {\n        if (!f._max) {\n          f._max = BigInt(\"0x7fffffffffffffff\");\n          f._min = ~f._max;\n        }\n        return b >= f._min && b <= f._max;\n      };\n      const bigIntFits32 = (b) => b >= -0x7fffffffn - 1n && b <= 0x7fffffffn;\n      const bigIntFitsDouble = function f(b) {\n        if (!f._min) {\n          f._min = Number.MIN_SAFE_INTEGER;\n          f._max = Number.MAX_SAFE_INTEGER;\n        }\n        return b >= f._min && b <= f._max;\n      };\n      const isTypedArray = (v2) => {\n        return v2 && v2.constructor && isInt32(v2.constructor.BYTES_PER_ELEMENT) ? v2 : false;\n      };\n      const isBindableTypedArray = (v2) => v2 && (v2 instanceof Uint8Array || v2 instanceof Int8Array || v2 instanceof ArrayBuffer);\n      const isSQLableTypedArray = (v2) => v2 && (v2 instanceof Uint8Array || v2 instanceof Int8Array || v2 instanceof ArrayBuffer);\n      const affirmBindableTypedArray = (v2) => isBindableTypedArray(v2) || toss3(\"Value is not of a supported TypedArray type.\");\n      const flexibleString = function(v2) {\n        if (isSQLableTypedArray(v2)) {\n          return wasm.typedArrayToString(\n            v2 instanceof ArrayBuffer ? new Uint8Array(v2) : v2,\n            0,\n            v2.length\n          );\n        } else if (Array.isArray(v2)) return v2.join(\"\");\n        else if (wasm.isPtr(v2)) v2 = wasm.cstrToJs(v2);\n        return v2;\n      };\n      class WasmAllocError extends Error {\n        constructor(...args) {\n          if (2 === args.length && \"object\" === typeof args[1]) {\n            super(...args);\n          } else if (args.length) {\n            super(args.join(\" \"));\n          } else {\n            super(\"Allocation failed.\");\n          }\n          this.resultCode = capi.SQLITE_NOMEM;\n          this.name = \"WasmAllocError\";\n        }\n      }\n      WasmAllocError.toss = (...args) => {\n        throw new WasmAllocError(...args);\n      };\n      Object.assign(capi, {\n        sqlite3_bind_blob: void 0,\n        sqlite3_bind_text: void 0,\n        sqlite3_create_function_v2: (pDb2, funcName, nArg, eTextRep, pApp, xFunc, xStep, xFinal, xDestroy) => {\n        },\n        sqlite3_create_function: (pDb2, funcName, nArg, eTextRep, pApp, xFunc, xStep, xFinal) => {\n        },\n        sqlite3_create_window_function: (pDb2, funcName, nArg, eTextRep, pApp, xStep, xFinal, xValue, xInverse, xDestroy) => {\n        },\n        sqlite3_prepare_v3: (dbPtr, sql, sqlByteLen, prepFlags, stmtPtrPtr, strPtrPtr) => {\n        },\n        sqlite3_prepare_v2: (dbPtr, sql, sqlByteLen, stmtPtrPtr, strPtrPtr) => {\n        },\n        sqlite3_exec: (pDb2, sql, callback, pVoid, pErrMsg) => {\n        },\n        sqlite3_randomness: (n, outPtr) => {\n        }\n      });\n      const util = {\n        affirmBindableTypedArray,\n        flexibleString,\n        bigIntFits32,\n        bigIntFits64,\n        bigIntFitsDouble,\n        isBindableTypedArray,\n        isInt32,\n        isSQLableTypedArray,\n        isTypedArray,\n        isUIThread: () => globalThis.window === globalThis && !!globalThis.document,\n        toss: function(...args) {\n          throw new Error(args.join(\" \"));\n        },\n        toss3,\n        typedArrayPart: wasm.typedArrayPart,\n        affirmDbHeader: function(bytes) {\n          if (bytes instanceof ArrayBuffer) bytes = new Uint8Array(bytes);\n          const header = \"SQLite format 3\";\n          if (header.length > bytes.byteLength) {\n            toss3(\"Input does not contain an SQLite3 database header.\");\n          }\n          for (let i = 0; i < header.length; ++i) {\n            if (header.charCodeAt(i) !== bytes[i]) {\n              toss3(\"Input does not contain an SQLite3 database header.\");\n            }\n          }\n        },\n        affirmIsDb: function(bytes) {\n          if (bytes instanceof ArrayBuffer) bytes = new Uint8Array(bytes);\n          const n = bytes.byteLength;\n          if (n < 512 || n % 512 !== 0) {\n            toss3(\"Byte array size\", n, \"is invalid for an SQLite3 db.\");\n          }\n          util.affirmDbHeader(bytes);\n        }\n      };\n      Object.assign(wasm, {\n        pointerIR: config.wasmPtrIR,\n        bigIntEnabled: !!config.bigIntEnabled,\n        exports: config.exports || toss3(\"Missing API config.exports (WASM module exports).\"),\n        memory: config.memory || config.exports[\"memory\"] || toss3(\n          \"API config object requires a WebAssembly.Memory object\",\n          \"in either config.exports.memory (exported)\",\n          \"or config.memory (imported).\"\n        ),\n        functionTable: config.functionTable,\n        alloc: void 0,\n        realloc: void 0,\n        dealloc: void 0\n      });\n      wasm.allocFromTypedArray = function(srcTypedArray) {\n        if (srcTypedArray instanceof ArrayBuffer) {\n          srcTypedArray = new Uint8Array(srcTypedArray);\n        }\n        affirmBindableTypedArray(srcTypedArray);\n        const pRet = wasm.alloc(srcTypedArray.byteLength || 1);\n        wasm.heapForSize(srcTypedArray.constructor).set(srcTypedArray.byteLength ? srcTypedArray : [0], Number(pRet));\n        return pRet;\n      };\n      {\n        const keyAlloc = config.allocExportName, keyDealloc = config.deallocExportName, keyRealloc = config.reallocExportName;\n        for (const key of [keyAlloc, keyDealloc, keyRealloc]) {\n          const f = wasm.exports[key];\n          if (!(f instanceof Function))\n            toss3(\"Missing required exports[\", key, \"] function.\");\n        }\n        wasm.alloc = function f(n) {\n          return f.impl(n) || WasmAllocError.toss(\"Failed to allocate\", n, \" bytes.\");\n        };\n        wasm.alloc.impl = wasm.exports[keyAlloc];\n        wasm.realloc = function f(m, n) {\n          const m2 = f.impl(wasm.ptr.coerce(m), n);\n          return n ? m2 || WasmAllocError.toss(\"Failed to reallocate\", n, \" bytes.\") : wasm.ptr.null;\n        };\n        wasm.realloc.impl = wasm.exports[keyRealloc];\n        wasm.dealloc = function f(m) {\n          f.impl(wasm.ptr.coerce(m));\n        };\n        wasm.dealloc.impl = wasm.exports[keyDealloc];\n      }\n      wasm.compileOptionUsed = function f(optName) {\n        if (!arguments.length) {\n          if (f._result) return f._result;\n          else if (!f._opt) {\n            f._rx = /^([^=]+)=(.+)/;\n            f._rxInt = /^-?\\d+$/;\n            f._opt = function(opt, rv) {\n              const m = f._rx.exec(opt);\n              rv[0] = m ? m[1] : opt;\n              rv[1] = m ? f._rxInt.test(m[2]) ? +m[2] : m[2] : true;\n            };\n          }\n          const rc = /* @__PURE__ */ Object.create(null), ov = [0, 0];\n          let i = 0, k;\n          while (k = capi.sqlite3_compileoption_get(i++)) {\n            f._opt(k, ov);\n            rc[ov[0]] = ov[1];\n          }\n          return f._result = rc;\n        } else if (Array.isArray(optName)) {\n          const rc = /* @__PURE__ */ Object.create(null);\n          optName.forEach((v2) => {\n            rc[v2] = capi.sqlite3_compileoption_used(v2);\n          });\n          return rc;\n        } else if (\"object\" === typeof optName) {\n          Object.keys(optName).forEach((k) => {\n            optName[k] = capi.sqlite3_compileoption_used(k);\n          });\n          return optName;\n        }\n        return \"string\" === typeof optName ? !!capi.sqlite3_compileoption_used(optName) : false;\n      };\n      wasm.pstack = Object.assign(/* @__PURE__ */ Object.create(null), {\n        restore: wasm.exports.sqlite3__wasm_pstack_restore,\n        alloc: function(n) {\n          if (\"string\" === typeof n && !(n = wasm.sizeofIR(n))) {\n            WasmAllocError.toss(\n              \"Invalid value for pstack.alloc(\",\n              arguments[0],\n              \")\"\n            );\n          }\n          return wasm.exports.sqlite3__wasm_pstack_alloc(n) || WasmAllocError.toss(\n            \"Could not allocate\",\n            n,\n            \"bytes from the pstack.\"\n          );\n        },\n        allocChunks: function(n, sz) {\n          if (\"string\" === typeof sz && !(sz = wasm.sizeofIR(sz))) {\n            WasmAllocError.toss(\n              \"Invalid size value for allocChunks(\",\n              arguments[1],\n              \")\"\n            );\n          }\n          const mem = wasm.pstack.alloc(n * sz);\n          const rc = [mem];\n          let i = 1, offset = sz;\n          for (; i < n; ++i, offset += sz) rc.push(wasm.ptr.add(mem, offset));\n          return rc;\n        },\n        allocPtr: (n = 1, safePtrSize = true) => {\n          return 1 === n ? wasm.pstack.alloc(safePtrSize ? 8 : wasm.ptr.size) : wasm.pstack.allocChunks(n, safePtrSize ? 8 : wasm.ptr.size);\n        },\n        call: function(f) {\n          const stackPos = wasm.pstack.pointer;\n          try {\n            return f(sqlite32);\n          } finally {\n            wasm.pstack.restore(stackPos);\n          }\n        }\n      });\n      Object.defineProperties(wasm.pstack, {\n        pointer: {\n          configurable: false,\n          iterable: true,\n          writeable: false,\n          get: wasm.exports.sqlite3__wasm_pstack_ptr\n        },\n        quota: {\n          configurable: false,\n          iterable: true,\n          writeable: false,\n          get: wasm.exports.sqlite3__wasm_pstack_quota\n        },\n        remaining: {\n          configurable: false,\n          iterable: true,\n          writeable: false,\n          get: wasm.exports.sqlite3__wasm_pstack_remaining\n        }\n      });\n      capi.sqlite3_randomness = (...args) => {\n        if (1 === args.length && util.isTypedArray(args[0]) && 1 === args[0].BYTES_PER_ELEMENT) {\n          const ta = args[0];\n          if (0 === ta.byteLength) {\n            wasm.exports.sqlite3_randomness(0, wasm.ptr.null);\n            return ta;\n          }\n          const stack = wasm.pstack.pointer;\n          try {\n            let n = ta.byteLength, offset = 0;\n            const r = wasm.exports.sqlite3_randomness;\n            const heap = wasm.heap8u();\n            const nAlloc = n < 512 ? n : 512;\n            const ptr = wasm.pstack.alloc(nAlloc);\n            do {\n              const j = n > nAlloc ? nAlloc : n;\n              r(j, ptr);\n              ta.set(\n                wasm.typedArrayPart(heap, ptr, wasm.ptr.add(ptr, j)),\n                offset\n              );\n              n -= j;\n              offset += j;\n            } while (n > 0);\n          } catch (e) {\n            config.error(\n              \"Highly unexpected (and ignored!) exception in sqlite3_randomness():\",\n              e\n            );\n          } finally {\n            wasm.pstack.restore(stack);\n          }\n          return ta;\n        }\n        wasm.exports.sqlite3_randomness(...args);\n      };\n      let __wasmfsOpfsDir = void 0;\n      capi.sqlite3_wasmfs_opfs_dir = function() {\n        if (void 0 !== __wasmfsOpfsDir) return __wasmfsOpfsDir;\n        const pdir = config.wasmfsOpfsDir;\n        if (!pdir || !globalThis.FileSystemHandle || !globalThis.FileSystemDirectoryHandle || !globalThis.FileSystemFileHandle || !wasm.exports.sqlite3__wasm_init_wasmfs) {\n          return __wasmfsOpfsDir = \"\";\n        }\n        try {\n          if (pdir && 0 === wasm.xCallWrapped(\n            \"sqlite3__wasm_init_wasmfs\",\n            \"i32\",\n            [\"string\"],\n            pdir\n          )) {\n            return __wasmfsOpfsDir = pdir;\n          } else {\n            return __wasmfsOpfsDir = \"\";\n          }\n        } catch (e) {\n          return __wasmfsOpfsDir = \"\";\n        }\n      };\n      capi.sqlite3_wasmfs_filename_is_persistent = function(name) {\n        const p = capi.sqlite3_wasmfs_opfs_dir();\n        return p && name ? name.startsWith(p + \"/\") : false;\n      };\n      capi.sqlite3_js_db_uses_vfs = function(pDb2, vfsName, dbName = 0) {\n        try {\n          const pK = capi.sqlite3_vfs_find(vfsName);\n          if (!pK) return false;\n          else if (!pDb2) {\n            return pK === capi.sqlite3_vfs_find(0) ? pK : false;\n          } else {\n            return pK === capi.sqlite3_js_db_vfs(pDb2, dbName) ? pK : false;\n          }\n        } catch (e) {\n          return false;\n        }\n      };\n      capi.sqlite3_js_vfs_list = function() {\n        const rc = [];\n        let pVfs = capi.sqlite3_vfs_find(wasm.ptr.coerce(0));\n        while (pVfs) {\n          const oVfs = new capi.sqlite3_vfs(pVfs);\n          rc.push(wasm.cstrToJs(oVfs.$zName));\n          pVfs = oVfs.$pNext;\n          oVfs.dispose();\n        }\n        return rc;\n      };\n      capi.sqlite3_js_db_export = function(pDb2, schema = 0) {\n        pDb2 = wasm.xWrap.testConvertArg(\"sqlite3*\", pDb2);\n        if (!pDb2) toss3(\"Invalid sqlite3* argument.\");\n        if (!wasm.bigIntEnabled) toss3(\"BigInt support is not enabled.\");\n        const scope = wasm.scopedAllocPush();\n        let pOut;\n        try {\n          const pSize = wasm.scopedAlloc(8 + wasm.ptr.size);\n          const ppOut = wasm.ptr.add(pSize, 8);\n          const zSchema = schema ? wasm.isPtr(schema) ? schema : wasm.scopedAllocCString(\"\" + schema) : wasm.ptr.null;\n          let rc = wasm.exports.sqlite3__wasm_db_serialize(\n            pDb2,\n            zSchema,\n            ppOut,\n            pSize,\n            0\n          );\n          if (rc) {\n            toss3(\n              \"Database serialization failed with code\",\n              sqlite32.capi.sqlite3_js_rc_str(rc)\n            );\n          }\n          pOut = wasm.peekPtr(ppOut);\n          const nOut = wasm.peek(pSize, \"i64\");\n          rc = nOut ? wasm.heap8u().slice(Number(pOut), Number(pOut) + Number(nOut)) : new Uint8Array();\n          return rc;\n        } finally {\n          if (pOut) wasm.exports.sqlite3_free(pOut);\n          wasm.scopedAllocPop(scope);\n        }\n      };\n      capi.sqlite3_js_db_vfs = (dbPointer, dbName = 0) => util.sqlite3__wasm_db_vfs(dbPointer, dbName);\n      capi.sqlite3_js_aggregate_context = (pCtx, n) => {\n        return capi.sqlite3_aggregate_context(pCtx, n) || (n ? WasmAllocError.toss(\n          \"Cannot allocate\",\n          n,\n          \"bytes for sqlite3_aggregate_context()\"\n        ) : 0);\n      };\n      capi.sqlite3_js_posix_create_file = function(filename, data, dataLen) {\n        let pData;\n        if (data && wasm.isPtr(data)) {\n          pData = data;\n        } else if (data instanceof ArrayBuffer || data instanceof Uint8Array) {\n          pData = wasm.allocFromTypedArray(data);\n          if (arguments.length < 3 || !util.isInt32(dataLen) || dataLen < 0) {\n            dataLen = data.byteLength;\n          }\n        } else {\n          SQLite3Error.toss(\n            \"Invalid 2nd argument for sqlite3_js_posix_create_file().\"\n          );\n        }\n        try {\n          if (!util.isInt32(dataLen) || dataLen < 0) {\n            SQLite3Error.toss(\n              \"Invalid 3rd argument for sqlite3_js_posix_create_file().\"\n            );\n          }\n          const rc = util.sqlite3__wasm_posix_create_file(\n            filename,\n            pData,\n            dataLen\n          );\n          if (rc)\n            SQLite3Error.toss(\n              \"Creation of file failed with sqlite3 result code\",\n              capi.sqlite3_js_rc_str(rc)\n            );\n        } finally {\n          if (pData && pData !== data) wasm.dealloc(pData);\n        }\n      };\n      capi.sqlite3_js_vfs_create_file = function(vfs, filename, data, dataLen) {\n        config.warn(\n          \"sqlite3_js_vfs_create_file() is deprecated and\",\n          \"should be avoided because it can lead to C-level crashes.\",\n          \"See its documentation for alternatives.\"\n        );\n        let pData;\n        if (data) {\n          if (wasm.isPtr(data)) {\n            pData = data;\n          } else {\n            if (data instanceof ArrayBuffer) {\n              data = new Uint8Array(data);\n            }\n            if (data instanceof Uint8Array) {\n              pData = wasm.allocFromTypedArray(data);\n              if (arguments.length < 4 || !util.isInt32(dataLen) || dataLen < 0) {\n                dataLen = data.byteLength;\n              }\n            } else {\n              SQLite3Error.toss(\n                \"Invalid 3rd argument type for sqlite3_js_vfs_create_file().\"\n              );\n            }\n          }\n        } else {\n          pData = 0;\n        }\n        if (!util.isInt32(dataLen) || dataLen < 0) {\n          if (pData && pData !== data) wasm.dealloc(pData);\n          SQLite3Error.toss(\n            \"Invalid 4th argument for sqlite3_js_vfs_create_file().\"\n          );\n        }\n        try {\n          const rc = util.sqlite3__wasm_vfs_create_file(\n            vfs,\n            filename,\n            pData,\n            dataLen\n          );\n          if (rc)\n            SQLite3Error.toss(\n              \"Creation of file failed with sqlite3 result code\",\n              capi.sqlite3_js_rc_str(rc)\n            );\n        } finally {\n          if (pData && pData !== data) wasm.dealloc(pData);\n        }\n      };\n      capi.sqlite3_js_sql_to_string = (sql) => {\n        if (\"string\" === typeof sql) {\n          return sql;\n        }\n        const x = flexibleString(v);\n        return x === v ? void 0 : x;\n      };\n      if (util.isUIThread()) {\n        const __kvvfsInfo = function(which) {\n          const rc = /* @__PURE__ */ Object.create(null);\n          rc.prefix = \"kvvfs-\" + which;\n          rc.stores = [];\n          if (\"session\" === which || \"\" === which)\n            rc.stores.push(globalThis.sessionStorage);\n          if (\"local\" === which || \"\" === which)\n            rc.stores.push(globalThis.localStorage);\n          return rc;\n        };\n        capi.sqlite3_js_kvvfs_clear = function(which = \"\") {\n          let rc = 0;\n          const kvinfo = __kvvfsInfo(which);\n          kvinfo.stores.forEach((s) => {\n            const toRm = [];\n            let i;\n            for (i = 0; i < s.length; ++i) {\n              const k = s.key(i);\n              if (k.startsWith(kvinfo.prefix)) toRm.push(k);\n            }\n            toRm.forEach((kk) => s.removeItem(kk));\n            rc += toRm.length;\n          });\n          return rc;\n        };\n        capi.sqlite3_js_kvvfs_size = function(which = \"\") {\n          let sz = 0;\n          const kvinfo = __kvvfsInfo(which);\n          kvinfo.stores.forEach((s) => {\n            let i;\n            for (i = 0; i < s.length; ++i) {\n              const k = s.key(i);\n              if (k.startsWith(kvinfo.prefix)) {\n                sz += k.length;\n                sz += s.getItem(k).length;\n              }\n            }\n          });\n          return sz * 2;\n        };\n      }\n      capi.sqlite3_db_config = function(pDb2, op, ...args) {\n        switch (op) {\n          case capi.SQLITE_DBCONFIG_ENABLE_FKEY:\n          case capi.SQLITE_DBCONFIG_ENABLE_TRIGGER:\n          case capi.SQLITE_DBCONFIG_ENABLE_FTS3_TOKENIZER:\n          case capi.SQLITE_DBCONFIG_ENABLE_LOAD_EXTENSION:\n          case capi.SQLITE_DBCONFIG_NO_CKPT_ON_CLOSE:\n          case capi.SQLITE_DBCONFIG_ENABLE_QPSG:\n          case capi.SQLITE_DBCONFIG_TRIGGER_EQP:\n          case capi.SQLITE_DBCONFIG_RESET_DATABASE:\n          case capi.SQLITE_DBCONFIG_DEFENSIVE:\n          case capi.SQLITE_DBCONFIG_WRITABLE_SCHEMA:\n          case capi.SQLITE_DBCONFIG_LEGACY_ALTER_TABLE:\n          case capi.SQLITE_DBCONFIG_DQS_DML:\n          case capi.SQLITE_DBCONFIG_DQS_DDL:\n          case capi.SQLITE_DBCONFIG_ENABLE_VIEW:\n          case capi.SQLITE_DBCONFIG_LEGACY_FILE_FORMAT:\n          case capi.SQLITE_DBCONFIG_TRUSTED_SCHEMA:\n          case capi.SQLITE_DBCONFIG_STMT_SCANSTATUS:\n          case capi.SQLITE_DBCONFIG_REVERSE_SCANORDER:\n          case capi.SQLITE_DBCONFIG_ENABLE_ATTACH_CREATE:\n          case capi.SQLITE_DBCONFIG_ENABLE_ATTACH_WRITE:\n          case capi.SQLITE_DBCONFIG_ENABLE_COMMENTS:\n            if (!this.ip) {\n              this.ip = wasm.xWrap(\"sqlite3__wasm_db_config_ip\", \"int\", [\n                \"sqlite3*\",\n                \"int\",\n                \"int\",\n                \"*\"\n              ]);\n            }\n            return this.ip(pDb2, op, args[0], args[1] || 0);\n          case capi.SQLITE_DBCONFIG_LOOKASIDE:\n            if (!this.pii) {\n              this.pii = wasm.xWrap(\"sqlite3__wasm_db_config_pii\", \"int\", [\n                \"sqlite3*\",\n                \"int\",\n                \"*\",\n                \"int\",\n                \"int\"\n              ]);\n            }\n            return this.pii(pDb2, op, args[0], args[1], args[2]);\n          case capi.SQLITE_DBCONFIG_MAINDBNAME:\n            if (!this.s) {\n              this.s = wasm.xWrap(\"sqlite3__wasm_db_config_s\", \"int\", [\n                \"sqlite3*\",\n                \"int\",\n                \"string:static\"\n              ]);\n            }\n            return this.s(pDb2, op, args[0]);\n          default:\n            return capi.SQLITE_MISUSE;\n        }\n      }.bind(/* @__PURE__ */ Object.create(null));\n      capi.sqlite3_value_to_js = function(pVal, throwIfCannotConvert = true) {\n        let arg;\n        const valType = capi.sqlite3_value_type(pVal);\n        switch (valType) {\n          case capi.SQLITE_INTEGER:\n            if (wasm.bigIntEnabled) {\n              arg = capi.sqlite3_value_int64(pVal);\n              if (util.bigIntFitsDouble(arg)) arg = Number(arg);\n            } else arg = capi.sqlite3_value_double(pVal);\n            break;\n          case capi.SQLITE_FLOAT:\n            arg = capi.sqlite3_value_double(pVal);\n            break;\n          case capi.SQLITE_TEXT:\n            arg = capi.sqlite3_value_text(pVal);\n            break;\n          case capi.SQLITE_BLOB: {\n            const n = capi.sqlite3_value_bytes(pVal);\n            const pBlob = capi.sqlite3_value_blob(pVal);\n            if (n && !pBlob)\n              sqlite32.WasmAllocError.toss(\n                \"Cannot allocate memory for blob argument of\",\n                n,\n                \"byte(s)\"\n              );\n            arg = n ? wasm.heap8u().slice(Number(pBlob), Number(pBlob) + Number(n)) : null;\n            break;\n          }\n          case capi.SQLITE_NULL:\n            arg = null;\n            break;\n          default:\n            if (throwIfCannotConvert) {\n              toss3(\n                capi.SQLITE_MISMATCH,\n                \"Unhandled sqlite3_value_type():\",\n                valType\n              );\n            }\n            arg = void 0;\n        }\n        return arg;\n      };\n      capi.sqlite3_values_to_js = function(argc, pArgv, throwIfCannotConvert = true) {\n        let i;\n        const tgt = [];\n        for (i = 0; i < argc; ++i) {\n          tgt.push(\n            capi.sqlite3_value_to_js(\n              wasm.peekPtr(wasm.ptr.add(pArgv, wasm.ptr.size * i)),\n              throwIfCannotConvert\n            )\n          );\n        }\n        return tgt;\n      };\n      capi.sqlite3_result_error_js = function(pCtx, e) {\n        if (e instanceof WasmAllocError) {\n          capi.sqlite3_result_error_nomem(pCtx);\n        } else {\n          capi.sqlite3_result_error(pCtx, \"\" + e, -1);\n        }\n      };\n      capi.sqlite3_result_js = function(pCtx, val) {\n        if (val instanceof Error) {\n          capi.sqlite3_result_error_js(pCtx, val);\n          return;\n        }\n        try {\n          switch (typeof val) {\n            case \"undefined\":\n              break;\n            case \"boolean\":\n              capi.sqlite3_result_int(pCtx, val ? 1 : 0);\n              break;\n            case \"bigint\":\n              if (util.bigIntFits32(val)) {\n                capi.sqlite3_result_int(pCtx, Number(val));\n              } else if (util.bigIntFitsDouble(val)) {\n                capi.sqlite3_result_double(pCtx, Number(val));\n              } else if (wasm.bigIntEnabled) {\n                if (util.bigIntFits64(val))\n                  capi.sqlite3_result_int64(pCtx, val);\n                else\n                  toss3(\n                    \"BigInt value\",\n                    val.toString(),\n                    \"is too BigInt for int64.\"\n                  );\n              } else {\n                toss3(\"BigInt value\", val.toString(), \"is too BigInt.\");\n              }\n              break;\n            case \"number\": {\n              let f;\n              if (util.isInt32(val)) {\n                f = capi.sqlite3_result_int;\n              } else if (wasm.bigIntEnabled && Number.isInteger(val) && util.bigIntFits64(BigInt(val))) {\n                f = capi.sqlite3_result_int64;\n              } else {\n                f = capi.sqlite3_result_double;\n              }\n              f(pCtx, val);\n              break;\n            }\n            case \"string\": {\n              const [p, n] = wasm.allocCString(val, true);\n              capi.sqlite3_result_text(pCtx, p, n, capi.SQLITE_WASM_DEALLOC);\n              break;\n            }\n            case \"object\":\n              if (null === val) {\n                capi.sqlite3_result_null(pCtx);\n                break;\n              } else if (util.isBindableTypedArray(val)) {\n                const pBlob = wasm.allocFromTypedArray(val);\n                capi.sqlite3_result_blob(\n                  pCtx,\n                  pBlob,\n                  val.byteLength,\n                  capi.SQLITE_WASM_DEALLOC\n                );\n                break;\n              }\n            default:\n              toss3(\n                \"Don't not how to handle this UDF result value:\",\n                typeof val,\n                val\n              );\n          }\n        } catch (e) {\n          capi.sqlite3_result_error_js(pCtx, e);\n        }\n      };\n      capi.sqlite3_column_js = function(pStmt, iCol, throwIfCannotConvert = true) {\n        const v2 = capi.sqlite3_column_value(pStmt, iCol);\n        return 0 === v2 ? void 0 : capi.sqlite3_value_to_js(v2, throwIfCannotConvert);\n      };\n      const __newOldValue = function(pObj, iCol, impl) {\n        impl = capi[impl];\n        if (!this.ptr) this.ptr = wasm.allocPtr();\n        else wasm.pokePtr(this.ptr, 0);\n        const rc = impl(pObj, iCol, this.ptr);\n        if (rc)\n          return SQLite3Error.toss(\n            rc,\n            arguments[2] + \"() failed with code \" + rc\n          );\n        const pv = wasm.peekPtr(this.ptr);\n        return pv ? capi.sqlite3_value_to_js(pv, true) : void 0;\n      }.bind(/* @__PURE__ */ Object.create(null));\n      capi.sqlite3_preupdate_new_js = (pDb2, iCol) => __newOldValue(pDb2, iCol, \"sqlite3_preupdate_new\");\n      capi.sqlite3_preupdate_old_js = (pDb2, iCol) => __newOldValue(pDb2, iCol, \"sqlite3_preupdate_old\");\n      capi.sqlite3changeset_new_js = (pChangesetIter, iCol) => __newOldValue(pChangesetIter, iCol, \"sqlite3changeset_new\");\n      capi.sqlite3changeset_old_js = (pChangesetIter, iCol) => __newOldValue(pChangesetIter, iCol, \"sqlite3changeset_old\");\n      const sqlite32 = {\n        WasmAllocError,\n        SQLite3Error,\n        capi,\n        util,\n        wasm,\n        config,\n        version: /* @__PURE__ */ Object.create(null),\n        client: void 0,\n        asyncPostInit: async function ff() {\n          if (ff.isReady instanceof Promise) return ff.isReady;\n          let lia = sqlite3ApiBootstrap.initializersAsync;\n          delete sqlite3ApiBootstrap.initializersAsync;\n          const postInit = async () => {\n            if (!sqlite32.__isUnderTest) {\n              delete sqlite32.util;\n              delete sqlite32.StructBinder;\n            }\n            return sqlite32;\n          };\n          const catcher = (e) => {\n            config.error(\"an async sqlite3 initializer failed:\", e);\n            throw e;\n          };\n          if (!lia || !lia.length) {\n            return ff.isReady = postInit().catch(catcher);\n          }\n          lia = lia.map((f) => {\n            return f instanceof Function ? async (x) => f(sqlite32) : f;\n          });\n          lia.push(postInit);\n          let p = Promise.resolve(sqlite32);\n          while (lia.length) p = p.then(lia.shift());\n          return ff.isReady = p.catch(catcher);\n        },\n        scriptInfo: void 0\n      };\n      try {\n        sqlite3ApiBootstrap.initializers.forEach((f) => {\n          f(sqlite32);\n        });\n      } catch (e) {\n        console.error(\"sqlite3 bootstrap initializer threw:\", e);\n        throw e;\n      }\n      delete sqlite3ApiBootstrap.initializers;\n      sqlite3ApiBootstrap.sqlite3 = sqlite32;\n      delete globalThis.sqlite3ApiBootstrap;\n      delete globalThis.sqlite3ApiConfig;\n      sqlite3InitScriptInfo.debugModule(\n        \"sqlite3ApiBootstrap() complete\",\n        sqlite32\n      );\n      sqlite32.scriptInfo = sqlite3InitScriptInfo;\n      if (sqlite32.__isUnderTest = sqlite3IsUnderTest) {\n        sqlite32.config.emscripten = EmscriptenModule;\n        const iw = sqlite3InitScriptInfo.instantiateWasm;\n        if (iw) {\n          sqlite32.wasm.module = iw.module;\n          sqlite32.wasm.instance = iw.instance;\n          sqlite32.wasm.imports = iw.imports;\n        }\n      }\n      return sqlite32.asyncPostInit().then((s) => {\n        sqlite3InitScriptInfo.debugModule(\n          \"sqlite3.asyncPostInit() complete\",\n          sqlite32\n        );\n        delete s.asyncPostInit;\n        delete s.scriptInfo;\n        delete s.emscripten;\n        return s;\n      });\n    };\n    globalThis.sqlite3ApiBootstrap.initializers = [];\n    globalThis.sqlite3ApiBootstrap.initializersAsync = [];\n    globalThis.sqlite3ApiBootstrap.defaultConfig = /* @__PURE__ */ Object.create(null);\n    globalThis.sqlite3ApiBootstrap.sqlite3 = void 0;\n    globalThis.WhWasmUtilInstaller = function(target) {\n      \"use strict\";\n      if (void 0 === target.bigIntEnabled) {\n        target.bigIntEnabled = !!globalThis[\"BigInt64Array\"];\n      }\n      const toss = (...args) => {\n        throw new Error(args.join(\" \"));\n      };\n      if (target.pointerSize && !target.pointerIR) {\n        target.pointerIR = 4 === target.pointerSize ? \"i32\" : \"i64\";\n      }\n      const __ptrIR = target.pointerIR ??= \"i32\";\n      const __ptrSize = target.pointerSize ??= \"i32\" === __ptrIR ? 4 : \"i64\" === __ptrIR ? 8 : 0;\n      delete target.pointerSize;\n      delete target.pointerIR;\n      if (\"i32\" !== __ptrIR && \"i64\" !== __ptrIR) {\n        toss(\"Invalid pointerIR:\", __ptrIR);\n      } else if (8 !== __ptrSize && 4 !== __ptrSize) {\n        toss(\"Invalid pointerSize:\", __ptrSize);\n      }\n      const __BigInt = target.bigIntEnabled ? (v2) => BigInt(v2 || 0) : (v2) => toss(\"BigInt support is disabled in this build.\");\n      const __Number = (v2) => Number(v2 || 0);\n      const __asPtrType = 4 === __ptrSize ? __Number : __BigInt;\n      const __NullPtr = __asPtrType(0);\n      const __ptrAdd = function(...args) {\n        let rc = __asPtrType(0);\n        for (const v2 of args) rc += __asPtrType(v2);\n        return rc;\n      };\n      {\n        const __ptr = /* @__PURE__ */ Object.create(null);\n        Object.defineProperty(target, \"ptr\", {\n          enumerable: true,\n          get: () => __ptr,\n          set: () => toss(\"The ptr property is read-only.\")\n        });\n        (function f(name, val) {\n          Object.defineProperty(__ptr, name, {\n            enumerable: true,\n            get: () => val,\n            set: () => toss(\"ptr[\" + name + \"] is read-only.\")\n          });\n          return f;\n        })(\"null\", __NullPtr)(\"size\", __ptrSize)(\"ir\", __ptrIR)(\n          \"coerce\",\n          __asPtrType\n        )(\"add\", __ptrAdd)(\n          \"addn\",\n          4 === __ptrIR ? __ptrAdd : (...args) => Number(__ptrAdd(...args))\n        );\n      }\n      if (!target.exports) {\n        Object.defineProperty(target, \"exports\", {\n          enumerable: true,\n          configurable: true,\n          get: () => target.instance?.exports\n        });\n      }\n      const cache = /* @__PURE__ */ Object.create(null);\n      cache.heapSize = 0;\n      cache.memory = null;\n      cache.freeFuncIndexes = [];\n      cache.scopedAlloc = [];\n      cache.scopedAlloc.pushPtr = (ptr) => {\n        cache.scopedAlloc[cache.scopedAlloc.length - 1].push(ptr);\n        return ptr;\n      };\n      cache.utf8Decoder = new TextDecoder();\n      cache.utf8Encoder = new TextEncoder(\"utf-8\");\n      target.sizeofIR = (n) => {\n        switch (n) {\n          case \"i8\":\n            return 1;\n          case \"i16\":\n            return 2;\n          case \"i32\":\n          case \"f32\":\n          case \"float\":\n            return 4;\n          case \"i64\":\n          case \"f64\":\n          case \"double\":\n            return 8;\n          case \"*\":\n            return __ptrSize;\n          default:\n            return (\"\" + n).endsWith(\"*\") ? __ptrSize : void 0;\n        }\n      };\n      const heapWrappers = function() {\n        if (!cache.memory) {\n          cache.memory = target.memory instanceof WebAssembly.Memory ? target.memory : target.exports.memory;\n        } else if (cache.heapSize === cache.memory.buffer.byteLength) {\n          return cache;\n        }\n        const b = cache.memory.buffer;\n        cache.HEAP8 = new Int8Array(b);\n        cache.HEAP8U = new Uint8Array(b);\n        cache.HEAP16 = new Int16Array(b);\n        cache.HEAP16U = new Uint16Array(b);\n        cache.HEAP32 = new Int32Array(b);\n        cache.HEAP32U = new Uint32Array(b);\n        cache.HEAP32F = new Float32Array(b);\n        cache.HEAP64F = new Float64Array(b);\n        if (target.bigIntEnabled) {\n          if (\"undefined\" !== typeof BigInt64Array) {\n            cache.HEAP64 = new BigInt64Array(b);\n            cache.HEAP64U = new BigUint64Array(b);\n          } else {\n            toss(\n              \"BigInt support is enabled, but the BigInt64Array type is missing.\"\n            );\n          }\n        }\n        cache.heapSize = b.byteLength;\n        return cache;\n      };\n      target.heap8 = () => heapWrappers().HEAP8;\n      target.heap8u = () => heapWrappers().HEAP8U;\n      target.heap16 = () => heapWrappers().HEAP16;\n      target.heap16u = () => heapWrappers().HEAP16U;\n      target.heap32 = () => heapWrappers().HEAP32;\n      target.heap32u = () => heapWrappers().HEAP32U;\n      target.heapForSize = function(n, unsigned = true) {\n        let ctor;\n        const c = cache.memory && cache.heapSize === cache.memory.buffer.byteLength ? cache : heapWrappers();\n        switch (n) {\n          case Int8Array:\n            return c.HEAP8;\n          case Uint8Array:\n            return c.HEAP8U;\n          case Int16Array:\n            return c.HEAP16;\n          case Uint16Array:\n            return c.HEAP16U;\n          case Int32Array:\n            return c.HEAP32;\n          case Uint32Array:\n            return c.HEAP32U;\n          case 8:\n            return unsigned ? c.HEAP8U : c.HEAP8;\n          case 16:\n            return unsigned ? c.HEAP16U : c.HEAP16;\n          case 32:\n            return unsigned ? c.HEAP32U : c.HEAP32;\n          case 64:\n            if (c.HEAP64) return unsigned ? c.HEAP64U : c.HEAP64;\n            break;\n          default:\n            if (target.bigIntEnabled) {\n              if (n === globalThis[\"BigUint64Array\"]) return c.HEAP64U;\n              else if (n === globalThis[\"BigInt64Array\"]) return c.HEAP64;\n              break;\n            }\n        }\n        toss(\n          \"Invalid heapForSize() size: expecting 8, 16, 32,\",\n          \"or (if BigInt is enabled) 64.\"\n        );\n      };\n      const __funcTable = target.functionTable;\n      delete target.functionTable;\n      target.functionTable = __funcTable ? () => __funcTable : () => target.exports.__indirect_function_table;\n      target.functionEntry = function(fptr) {\n        const ft = target.functionTable();\n        return fptr < ft.length ? ft.get(__asPtrType(fptr)) : void 0;\n      };\n      target.jsFuncToWasm = function f(func, sig) {\n        if (!f._) {\n          f._ = {\n            sigTypes: Object.assign(/* @__PURE__ */ Object.create(null), {\n              i: \"i32\",\n              p: __ptrIR,\n              P: __ptrIR,\n              s: __ptrIR,\n              j: \"i64\",\n              f: \"f32\",\n              d: \"f64\"\n            }),\n            typeCodes: Object.assign(/* @__PURE__ */ Object.create(null), {\n              f64: 124,\n              f32: 125,\n              i64: 126,\n              i32: 127\n            }),\n            uleb128Encode: (tgt, method, n) => {\n              if (n < 128) tgt[method](n);\n              else tgt[method](n % 128 | 128, n >> 7);\n            },\n            rxJSig: /^(\\w)\\((\\w*)\\)$/,\n            sigParams: (sig2) => {\n              const m = f._.rxJSig.exec(sig2);\n              return m ? m[2] : sig2.substr(1);\n            },\n            letterType: (x) => f._.sigTypes[x] || toss(\"Invalid signature letter:\", x),\n            pushSigType: (dest, letter) => dest.push(f._.typeCodes[f._.letterType(letter)])\n          };\n        }\n        if (\"string\" === typeof func) {\n          const x = sig;\n          sig = func;\n          func = x;\n        }\n        const _ = f._;\n        const sigParams = _.sigParams(sig);\n        const wasmCode = [1, 96];\n        _.uleb128Encode(wasmCode, \"push\", sigParams.length);\n        for (const x of sigParams) _.pushSigType(wasmCode, x);\n        if (\"v\" === sig[0]) wasmCode.push(0);\n        else {\n          wasmCode.push(1);\n          _.pushSigType(wasmCode, sig[0]);\n        }\n        _.uleb128Encode(wasmCode, \"unshift\", wasmCode.length);\n        wasmCode.unshift(0, 97, 115, 109, 1, 0, 0, 0, 1);\n        wasmCode.push(\n          2,\n          7,\n          1,\n          1,\n          101,\n          1,\n          102,\n          0,\n          0,\n          7,\n          5,\n          1,\n          1,\n          102,\n          0,\n          0\n        );\n        return new WebAssembly.Instance(\n          new WebAssembly.Module(new Uint8Array(wasmCode)),\n          {\n            e: { f: func }\n          }\n        ).exports[\"f\"];\n      };\n      const __installFunction = function f(func, sig, scoped) {\n        if (scoped && !cache.scopedAlloc.length) {\n          toss(\"No scopedAllocPush() scope is active.\");\n        }\n        if (\"string\" === typeof func) {\n          const x = sig;\n          sig = func;\n          func = x;\n        }\n        if (\"string\" !== typeof sig || !(func instanceof Function)) {\n          toss(\n            \"Invalid arguments: expecting (function,signature) or (signature,function).\"\n          );\n        }\n        const ft = target.functionTable();\n        const oldLen = __asPtrType(ft.length);\n        let ptr;\n        while (cache.freeFuncIndexes.length) {\n          ptr = cache.freeFuncIndexes.pop();\n          if (ft.get(ptr)) {\n            ptr = null;\n            continue;\n          } else {\n            break;\n          }\n        }\n        if (!ptr) {\n          ptr = __asPtrType(oldLen);\n          ft.grow(__asPtrType(1));\n        }\n        try {\n          ft.set(ptr, func);\n          if (scoped) {\n            cache.scopedAlloc.pushPtr(ptr);\n          }\n          return ptr;\n        } catch (e) {\n          if (!(e instanceof TypeError)) {\n            if (ptr === oldLen) cache.freeFuncIndexes.push(oldLen);\n            throw e;\n          }\n        }\n        try {\n          const fptr = target.jsFuncToWasm(func, sig);\n          ft.set(ptr, fptr);\n          if (scoped) {\n            cache.scopedAlloc.pushPtr(ptr);\n          }\n        } catch (e) {\n          if (ptr === oldLen) cache.freeFuncIndexes.push(oldLen);\n          throw e;\n        }\n        return ptr;\n      };\n      target.installFunction = (func, sig) => __installFunction(func, sig, false);\n      target.scopedInstallFunction = (func, sig) => __installFunction(func, sig, true);\n      target.uninstallFunction = function(ptr) {\n        if (!ptr && 0 !== ptr) return void 0;\n        const fi = cache.freeFuncIndexes;\n        const ft = target.functionTable();\n        fi.push(ptr);\n        const rc = ft.get(ptr);\n        ft.set(ptr, null);\n        return rc;\n      };\n      target.peek = function f(ptr, type = \"i8\") {\n        if (type.endsWith(\"*\")) type = __ptrIR;\n        const c = cache.memory && cache.heapSize === cache.memory.buffer.byteLength ? cache : heapWrappers();\n        const list = Array.isArray(ptr) ? [] : void 0;\n        let rc;\n        do {\n          if (list) ptr = arguments[0].shift();\n          switch (type) {\n            case \"i1\":\n            case \"i8\":\n              rc = c.HEAP8[Number(ptr) >> 0];\n              break;\n            case \"i16\":\n              rc = c.HEAP16[Number(ptr) >> 1];\n              break;\n            case \"i32\":\n              rc = c.HEAP32[Number(ptr) >> 2];\n              break;\n            case \"float\":\n            case \"f32\":\n              rc = c.HEAP32F[Number(ptr) >> 2];\n              break;\n            case \"double\":\n            case \"f64\":\n              rc = Number(c.HEAP64F[Number(ptr) >> 3]);\n              break;\n            case \"i64\":\n              if (c.HEAP64) {\n                rc = __BigInt(c.HEAP64[Number(ptr) >> 3]);\n                break;\n              }\n            default:\n              toss(\"Invalid type for peek():\", type);\n          }\n          if (list) list.push(rc);\n        } while (list && arguments[0].length);\n        return list || rc;\n      };\n      target.poke = function(ptr, value, type = \"i8\") {\n        if (type.endsWith(\"*\")) type = __ptrIR;\n        const c = cache.memory && cache.heapSize === cache.memory.buffer.byteLength ? cache : heapWrappers();\n        for (const p of Array.isArray(ptr) ? ptr : [ptr]) {\n          switch (type) {\n            case \"i1\":\n            case \"i8\":\n              c.HEAP8[Number(p) >> 0] = value;\n              continue;\n            case \"i16\":\n              c.HEAP16[Number(p) >> 1] = value;\n              continue;\n            case \"i32\":\n              c.HEAP32[Number(p) >> 2] = value;\n              continue;\n            case \"float\":\n            case \"f32\":\n              c.HEAP32F[Number(p) >> 2] = value;\n              continue;\n            case \"double\":\n            case \"f64\":\n              c.HEAP64F[Number(p) >> 3] = value;\n              continue;\n            case \"i64\":\n              if (c.HEAP64) {\n                c.HEAP64[Number(p) >> 3] = __BigInt(value);\n                continue;\n              }\n            default:\n              toss(\"Invalid type for poke(): \" + type);\n          }\n        }\n        return this;\n      };\n      target.peekPtr = (...ptr) => target.peek(1 === ptr.length ? ptr[0] : ptr, __ptrIR);\n      target.pokePtr = (ptr, value = 0) => target.poke(ptr, value, __ptrIR);\n      target.peek8 = (...ptr) => target.peek(1 === ptr.length ? ptr[0] : ptr, \"i8\");\n      target.poke8 = (ptr, value) => target.poke(ptr, value, \"i8\");\n      target.peek16 = (...ptr) => target.peek(1 === ptr.length ? ptr[0] : ptr, \"i16\");\n      target.poke16 = (ptr, value) => target.poke(ptr, value, \"i16\");\n      target.peek32 = (...ptr) => target.peek(1 === ptr.length ? ptr[0] : ptr, \"i32\");\n      target.poke32 = (ptr, value) => target.poke(ptr, value, \"i32\");\n      target.peek64 = (...ptr) => target.peek(1 === ptr.length ? ptr[0] : ptr, \"i64\");\n      target.poke64 = (ptr, value) => target.poke(ptr, value, \"i64\");\n      target.peek32f = (...ptr) => target.peek(1 === ptr.length ? ptr[0] : ptr, \"f32\");\n      target.poke32f = (ptr, value) => target.poke(ptr, value, \"f32\");\n      target.peek64f = (...ptr) => target.peek(1 === ptr.length ? ptr[0] : ptr, \"f64\");\n      target.poke64f = (ptr, value) => target.poke(ptr, value, \"f64\");\n      target.getMemValue = target.peek;\n      target.getPtrValue = target.peekPtr;\n      target.setMemValue = target.poke;\n      target.setPtrValue = target.pokePtr;\n      target.isPtr32 = (ptr) => \"number\" === typeof ptr && ptr >= 0 && ptr === (ptr | 0);\n      target.isPtr64 = (ptr) => \"bigint\" === typeof ptr ? ptr >= 0 : target.isPtr32(ptr);\n      target.isPtr = 4 === __ptrSize ? target.isPtr32 : target.isPtr64;\n      target.cstrlen = function(ptr) {\n        if (!ptr || !target.isPtr(ptr)) return null;\n        ptr = Number(ptr);\n        const h = heapWrappers().HEAP8U;\n        let pos = ptr;\n        for (; h[pos] !== 0; ++pos) {\n        }\n        return Number(pos - ptr);\n      };\n      const __SAB = \"undefined\" === typeof SharedArrayBuffer ? function() {\n      } : SharedArrayBuffer;\n      const isSharedTypedArray = (aTypedArray) => aTypedArray.buffer instanceof __SAB;\n      target.isSharedTypedArray = isSharedTypedArray;\n      const typedArrayPart = (aTypedArray, begin, end) => {\n        if (8 === __ptrSize) {\n          if (\"bigint\" === typeof begin) begin = Number(begin);\n          if (\"bigint\" === typeof end) end = Number(end);\n        }\n        return isSharedTypedArray(aTypedArray) ? aTypedArray.slice(begin, end) : aTypedArray.subarray(begin, end);\n      };\n      target.typedArrayPart = typedArrayPart;\n      const typedArrayToString = (typedArray, begin, end) => cache.utf8Decoder.decode(typedArrayPart(typedArray, begin, end));\n      target.typedArrayToString = typedArrayToString;\n      target.cstrToJs = function(ptr) {\n        const n = target.cstrlen(ptr);\n        return n ? typedArrayToString(\n          heapWrappers().HEAP8U,\n          Number(ptr),\n          Number(ptr) + n\n        ) : null === n ? n : \"\";\n      };\n      target.jstrlen = function(str) {\n        if (\"string\" !== typeof str) return null;\n        const n = str.length;\n        let len = 0;\n        for (let i = 0; i < n; ++i) {\n          let u = str.charCodeAt(i);\n          if (u >= 55296 && u <= 57343) {\n            u = 65536 + ((u & 1023) << 10) | str.charCodeAt(++i) & 1023;\n          }\n          if (u <= 127) ++len;\n          else if (u <= 2047) len += 2;\n          else if (u <= 65535) len += 3;\n          else len += 4;\n        }\n        return len;\n      };\n      target.jstrcpy = function(jstr, tgt, offset = 0, maxBytes = -1, addNul = true) {\n        if (!tgt || !(tgt instanceof Int8Array) && !(tgt instanceof Uint8Array)) {\n          toss(\"jstrcpy() target must be an Int8Array or Uint8Array.\");\n        }\n        maxBytes = Number(maxBytes);\n        offset = Number(offset);\n        if (maxBytes < 0) maxBytes = tgt.length - offset;\n        if (!(maxBytes > 0) || !(offset >= 0)) return 0;\n        let i = 0, max = jstr.length;\n        const begin = offset, end = offset + maxBytes - (addNul ? 1 : 0);\n        for (; i < max && offset < end; ++i) {\n          let u = jstr.charCodeAt(i);\n          if (u >= 55296 && u <= 57343) {\n            u = 65536 + ((u & 1023) << 10) | jstr.charCodeAt(++i) & 1023;\n          }\n          if (u <= 127) {\n            if (offset >= end) break;\n            tgt[offset++] = u;\n          } else if (u <= 2047) {\n            if (offset + 1 >= end) break;\n            tgt[offset++] = 192 | u >> 6;\n            tgt[offset++] = 128 | u & 63;\n          } else if (u <= 65535) {\n            if (offset + 2 >= end) break;\n            tgt[offset++] = 224 | u >> 12;\n            tgt[offset++] = 128 | u >> 6 & 63;\n            tgt[offset++] = 128 | u & 63;\n          } else {\n            if (offset + 3 >= end) break;\n            tgt[offset++] = 240 | u >> 18;\n            tgt[offset++] = 128 | u >> 12 & 63;\n            tgt[offset++] = 128 | u >> 6 & 63;\n            tgt[offset++] = 128 | u & 63;\n          }\n        }\n        if (addNul) tgt[offset++] = 0;\n        return offset - begin;\n      };\n      target.cstrncpy = function(tgtPtr, srcPtr, n) {\n        if (!tgtPtr || !srcPtr)\n          toss(\"cstrncpy() does not accept NULL strings.\");\n        if (n < 0) n = target.cstrlen(strPtr) + 1;\n        else if (!(n > 0)) return 0;\n        const heap = target.heap8u();\n        let i = 0, ch;\n        const tgtNumber = Number(tgtPtr), srcNumber = Number(srcPtr);\n        for (; i < n && (ch = heap[srcNumber + i]); ++i) {\n          heap[tgtNumber + i] = ch;\n        }\n        if (i < n) heap[tgtNumber + i++] = 0;\n        return i;\n      };\n      target.jstrToUintArray = (str, addNul = false) => {\n        return cache.utf8Encoder.encode(addNul ? str + \"\\0\" : str);\n      };\n      const __affirmAlloc = (obj, funcName) => {\n        if (!(obj.alloc instanceof Function) || !(obj.dealloc instanceof Function)) {\n          toss(\n            \"Object is missing alloc() and/or dealloc() function(s)\",\n            \"required by\",\n            funcName + \"().\"\n          );\n        }\n      };\n      const __allocCStr = function(jstr, returnWithLength, allocator, funcName) {\n        __affirmAlloc(target, funcName);\n        if (\"string\" !== typeof jstr) return null;\n        const u = cache.utf8Encoder.encode(jstr), ptr = allocator(u.length + 1);\n        let toFree = ptr;\n        try {\n          const heap = heapWrappers().HEAP8U;\n          heap.set(u, Number(ptr));\n          heap[__ptrAdd(ptr, u.length)] = 0;\n          toFree = __NullPtr;\n          return returnWithLength ? [ptr, u.length] : ptr;\n        } finally {\n          if (toFree) target.dealloc(toFree);\n        }\n      };\n      target.allocCString = (jstr, returnWithLength = false) => __allocCStr(jstr, returnWithLength, target.alloc, \"allocCString()\");\n      target.scopedAllocPush = function() {\n        __affirmAlloc(target, \"scopedAllocPush\");\n        const a = [];\n        cache.scopedAlloc.push(a);\n        return a;\n      };\n      target.scopedAllocPop = function(state) {\n        __affirmAlloc(target, \"scopedAllocPop\");\n        const n = arguments.length ? cache.scopedAlloc.indexOf(state) : cache.scopedAlloc.length - 1;\n        if (n < 0) toss(\"Invalid state object for scopedAllocPop().\");\n        if (0 === arguments.length) state = cache.scopedAlloc[n];\n        cache.scopedAlloc.splice(n, 1);\n        for (let p; p = state.pop(); ) {\n          if (target.functionEntry(p)) {\n            target.uninstallFunction(p);\n          } else {\n            target.dealloc(p);\n          }\n        }\n      };\n      target.scopedAlloc = function(n) {\n        if (!cache.scopedAlloc.length) {\n          toss(\"No scopedAllocPush() scope is active.\");\n        }\n        const p = __asPtrType(target.alloc(n));\n        return cache.scopedAlloc.pushPtr(p);\n      };\n      Object.defineProperty(target.scopedAlloc, \"level\", {\n        configurable: false,\n        enumerable: false,\n        get: () => cache.scopedAlloc.length,\n        set: () => toss(\"The 'active' property is read-only.\")\n      });\n      target.scopedAllocCString = (jstr, returnWithLength = false) => __allocCStr(\n        jstr,\n        returnWithLength,\n        target.scopedAlloc,\n        \"scopedAllocCString()\"\n      );\n      const __allocMainArgv = function(isScoped, list) {\n        const pList = target[isScoped ? \"scopedAlloc\" : \"alloc\"](\n          (list.length + 1) * target.ptr.size\n        );\n        let i = 0;\n        list.forEach((e) => {\n          target.pokePtr(\n            __ptrAdd(pList, target.ptr.size * i++),\n            target[isScoped ? \"scopedAllocCString\" : \"allocCString\"](\"\" + e)\n          );\n        });\n        target.pokePtr(__ptrAdd(pList, target.ptr.size * i), 0);\n        return pList;\n      };\n      target.scopedAllocMainArgv = (list) => __allocMainArgv(true, list);\n      target.allocMainArgv = (list) => __allocMainArgv(false, list);\n      target.cArgvToJs = (argc, pArgv) => {\n        const list = [];\n        for (let i = 0; i < argc; ++i) {\n          const arg = target.peekPtr(__ptrAdd(pArgv, target.ptr.size * i));\n          list.push(arg ? target.cstrToJs(arg) : null);\n        }\n        return list;\n      };\n      target.scopedAllocCall = function(func) {\n        target.scopedAllocPush();\n        try {\n          return func();\n        } finally {\n          target.scopedAllocPop();\n        }\n      };\n      const __allocPtr = function(howMany, safePtrSize, method) {\n        __affirmAlloc(target, method);\n        const pIr = safePtrSize ? \"i64\" : __ptrIR;\n        let m = target[method](howMany * (safePtrSize ? 8 : __ptrSize));\n        target.poke(m, 0, pIr);\n        if (1 === howMany) {\n          return m;\n        }\n        const a = [m];\n        for (let i = 1; i < howMany; ++i) {\n          m = __ptrAdd(m, safePtrSize ? 8 : __ptrSize);\n          a[i] = m;\n          target.poke(m, 0, pIr);\n        }\n        return a;\n      };\n      target.allocPtr = (howMany = 1, safePtrSize = true) => __allocPtr(howMany, safePtrSize, \"alloc\");\n      target.scopedAllocPtr = (howMany = 1, safePtrSize = true) => __allocPtr(howMany, safePtrSize, \"scopedAlloc\");\n      target.xGet = function(name) {\n        return target.exports[name] || toss(\"Cannot find exported symbol:\", name);\n      };\n      const __argcMismatch = (f, n) => toss(f + \"() requires\", n, \"argument(s).\");\n      target.xCall = function(fname, ...args) {\n        const f = fname instanceof Function ? fname : target.xGet(fname);\n        if (!(f instanceof Function))\n          toss(\"Exported symbol\", fname, \"is not a function.\");\n        if (f.length !== args.length) {\n          __argcMismatch(f === fname ? f.name : fname, f.length);\n        }\n        return 2 === arguments.length && Array.isArray(arguments[1]) ? f.apply(null, arguments[1]) : f.apply(null, args);\n      };\n      cache.xWrap = /* @__PURE__ */ Object.create(null);\n      cache.xWrap.convert = /* @__PURE__ */ Object.create(null);\n      cache.xWrap.convert.arg = /* @__PURE__ */ new Map();\n      cache.xWrap.convert.result = /* @__PURE__ */ new Map();\n      const xArg = cache.xWrap.convert.arg, xResult = cache.xWrap.convert.result;\n      const __xArgPtr = __asPtrType;\n      xArg.set(\"i64\", __BigInt).set(\"i32\", (i) => i | 0).set(\"i16\", (i) => (i | 0) & 65535).set(\"i8\", (i) => (i | 0) & 255).set(\"f32\", (i) => Number(i).valueOf()).set(\"float\", xArg.get(\"f32\")).set(\"f64\", xArg.get(\"f32\")).set(\"double\", xArg.get(\"f64\")).set(\"int\", xArg.get(\"i32\")).set(\"null\", (i) => i).set(null, xArg.get(\"null\")).set(\"**\", __xArgPtr).set(\"*\", __xArgPtr);\n      xResult.set(\"*\", __xArgPtr).set(\"pointer\", __xArgPtr).set(\"number\", (v2) => Number(v2)).set(\"void\", (v2) => void 0).set(void 0, xResult.get(\"void\")).set(\"null\", (v2) => v2).set(null, xResult.get(\"null\"));\n      for (const t of [\n        \"i8\",\n        \"i16\",\n        \"i32\",\n        \"i64\",\n        \"int\",\n        \"f32\",\n        \"float\",\n        \"f64\",\n        \"double\"\n      ]) {\n        xArg.set(t + \"*\", __xArgPtr);\n        xResult.set(t + \"*\", __xArgPtr);\n        xResult.set(\n          t,\n          xArg.get(t) || toss(\"Maintenance required: missing arg converter for\", t)\n        );\n      }\n      const __xArgString = (v2) => {\n        return \"string\" === typeof v2 ? target.scopedAllocCString(v2) : __asPtrType(v2);\n      };\n      xArg.set(\"string\", __xArgString).set(\"utf8\", __xArgString);\n      xResult.set(\"string\", (i) => target.cstrToJs(i)).set(\"utf8\", xResult.get(\"string\")).set(\"string:dealloc\", (i) => {\n        try {\n          return i ? target.cstrToJs(i) : null;\n        } finally {\n          target.dealloc(i);\n        }\n      }).set(\"utf8:dealloc\", xResult.get(\"string:dealloc\")).set(\"json\", (i) => JSON.parse(target.cstrToJs(i))).set(\"json:dealloc\", (i) => {\n        try {\n          return i ? JSON.parse(target.cstrToJs(i)) : null;\n        } finally {\n          target.dealloc(i);\n        }\n      });\n      const AbstractArgAdapter = class {\n        constructor(opt) {\n          this.name = opt.name || \"unnamed adapter\";\n        }\n        convertArg(v2, argv, argIndex) {\n          toss(\"AbstractArgAdapter must be subclassed.\");\n        }\n      };\n      xArg.FuncPtrAdapter = class FuncPtrAdapter extends AbstractArgAdapter {\n        constructor(opt) {\n          super(opt);\n          if (xArg.FuncPtrAdapter.warnOnUse) {\n            console.warn(\n              \"xArg.FuncPtrAdapter is an internal-only API\",\n              \"and is not intended to be invoked from\",\n              \"client-level code. Invoked with:\",\n              opt\n            );\n          }\n          this.name = opt.name || \"unnamed\";\n          this.signature = opt.signature;\n          if (opt.contextKey instanceof Function) {\n            this.contextKey = opt.contextKey;\n            if (!opt.bindScope) opt.bindScope = \"context\";\n          }\n          this.bindScope = opt.bindScope || toss(\n            \"FuncPtrAdapter options requires a bindScope (explicit or implied).\"\n          );\n          if (FuncPtrAdapter.bindScopes.indexOf(opt.bindScope) < 0) {\n            toss(\n              \"Invalid options.bindScope (\" + opt.bindMod + \") for FuncPtrAdapter. Expecting one of: (\" + FuncPtrAdapter.bindScopes.join(\", \") + \")\"\n            );\n          }\n          this.isTransient = \"transient\" === this.bindScope;\n          this.isContext = \"context\" === this.bindScope;\n          this.isPermanent = \"permanent\" === this.bindScope;\n          this.singleton = \"singleton\" === this.bindScope ? [] : void 0;\n          this.callProxy = opt.callProxy instanceof Function ? opt.callProxy : void 0;\n        }\n        contextKey(argv, argIndex) {\n          return this;\n        }\n        contextMap(key) {\n          const cm = this.__cmap || (this.__cmap = /* @__PURE__ */ new Map());\n          let rc = cm.get(key);\n          if (void 0 === rc) cm.set(key, rc = []);\n          return rc;\n        }\n        convertArg(v2, argv, argIndex) {\n          let pair = this.singleton;\n          if (!pair && this.isContext) {\n            pair = this.contextMap(this.contextKey(argv, argIndex));\n          }\n          if (0) {\n            FuncPtrAdapter.debugOut(\n              \"FuncPtrAdapter.convertArg()\",\n              this.name,\n              \"signature =\",\n              this.signature,\n              \"transient ?=\",\n              this.transient,\n              \"pair =\",\n              pair,\n              \"v =\",\n              v2\n            );\n          }\n          if (pair && 2 === pair.length && pair[0] === v2) {\n            return pair[1];\n          }\n          if (v2 instanceof Function) {\n            if (this.callProxy) {\n              v2 = this.callProxy(v2);\n            }\n            const fp = __installFunction(v2, this.signature, this.isTransient);\n            if (FuncPtrAdapter.debugFuncInstall) {\n              FuncPtrAdapter.debugOut(\n                \"FuncPtrAdapter installed\",\n                this,\n                this.contextKey(argv, argIndex),\n                \"@\" + fp,\n                v2\n              );\n            }\n            if (pair) {\n              if (pair[1]) {\n                if (FuncPtrAdapter.debugFuncInstall) {\n                  FuncPtrAdapter.debugOut(\n                    \"FuncPtrAdapter uninstalling\",\n                    this,\n                    this.contextKey(argv, argIndex),\n                    \"@\" + pair[1],\n                    v2\n                  );\n                }\n                try {\n                  cache.scopedAlloc.pushPtr(pair[1]);\n                } catch (e) {\n                }\n              }\n              pair[0] = arguments[0] || __NullPtr;\n              pair[1] = fp;\n            }\n            return fp;\n          } else if (target.isPtr(v2) || null === v2 || void 0 === v2) {\n            if (pair && pair[1] && pair[1] !== v2) {\n              if (FuncPtrAdapter.debugFuncInstall) {\n                FuncPtrAdapter.debugOut(\n                  \"FuncPtrAdapter uninstalling\",\n                  this,\n                  this.contextKey(argv, argIndex),\n                  \"@\" + pair[1],\n                  v2\n                );\n              }\n              try {\n                cache.scopedAlloc.pushPtr(pair[1]);\n              } catch (e) {\n              }\n              pair[0] = pair[1] = v2 || __NullPtr;\n            }\n            return v2 || __NullPtr;\n          } else {\n            throw new TypeError(\n              \"Invalid FuncPtrAdapter argument type. Expecting a function pointer or a \" + (this.name ? this.name + \" \" : \"\") + \"function matching signature \" + this.signature + \".\"\n            );\n          }\n        }\n      };\n      xArg.FuncPtrAdapter.warnOnUse = false;\n      xArg.FuncPtrAdapter.debugFuncInstall = false;\n      xArg.FuncPtrAdapter.debugOut = console.debug.bind(console);\n      xArg.FuncPtrAdapter.bindScopes = [\n        \"transient\",\n        \"context\",\n        \"singleton\",\n        \"permanent\"\n      ];\n      const __xArgAdapterCheck = (t) => xArg.get(t) || toss(\"Argument adapter not found:\", t);\n      const __xResultAdapterCheck = (t) => xResult.get(t) || toss(\"Result adapter not found:\", t);\n      cache.xWrap.convertArg = (t, ...args) => __xArgAdapterCheck(t)(...args);\n      cache.xWrap.convertArgNoCheck = (t, ...args) => xArg.get(t)(...args);\n      cache.xWrap.convertResult = (t, v2) => null === t ? v2 : t ? __xResultAdapterCheck(t)(v2) : void 0;\n      cache.xWrap.convertResultNoCheck = (t, v2) => null === t ? v2 : t ? xResult.get(t)(v2) : void 0;\n      target.xWrap = function callee3(fArg, resultType, ...argTypes) {\n        if (3 === arguments.length && Array.isArray(arguments[2])) {\n          argTypes = arguments[2];\n        }\n        if (target.isPtr(fArg)) {\n          fArg = target.functionEntry(fArg) || toss(\"Function pointer not found in WASM function table.\");\n        }\n        const fIsFunc = fArg instanceof Function;\n        const xf = fIsFunc ? fArg : target.xGet(fArg);\n        if (fIsFunc) fArg = xf.name || \"unnamed function\";\n        if (argTypes.length !== xf.length) __argcMismatch(fArg, xf.length);\n        if (0 === xf.length && (null === resultType || \"null\" === resultType)) {\n          return xf;\n        }\n        __xResultAdapterCheck(resultType);\n        for (const t of argTypes) {\n          if (t instanceof AbstractArgAdapter)\n            xArg.set(t, (...args) => t.convertArg(...args));\n          else __xArgAdapterCheck(t);\n        }\n        const cxw = cache.xWrap;\n        if (0 === xf.length) {\n          return (...args) => args.length ? __argcMismatch(fArg, xf.length) : cxw.convertResult(resultType, xf.call(null));\n        }\n        return function(...args) {\n          if (args.length !== xf.length) __argcMismatch(fArg, xf.length);\n          const scope = target.scopedAllocPush();\n          try {\n            let i = 0;\n            if (callee3.debug) {\n              console.debug(\n                \"xWrap() preparing: resultType \",\n                resultType,\n                \"xf\",\n                xf,\n                \"argTypes\",\n                argTypes,\n                \"args\",\n                args\n              );\n            }\n            for (; i < args.length; ++i)\n              args[i] = cxw.convertArgNoCheck(argTypes[i], args[i], args, i);\n            if (callee3.debug) {\n              console.debug(\n                \"xWrap() calling: resultType \",\n                resultType,\n                \"xf\",\n                xf,\n                \"argTypes\",\n                argTypes,\n                \"args\",\n                args\n              );\n            }\n            return cxw.convertResultNoCheck(resultType, xf.apply(null, args));\n          } finally {\n            target.scopedAllocPop(scope);\n          }\n        };\n      };\n      const __xAdapter = function(func, argc, typeName, adapter, modeName, xcvPart) {\n        if (\"string\" === typeof typeName) {\n          if (1 === argc) return xcvPart.get(typeName);\n          else if (2 === argc) {\n            if (!adapter) {\n              xcvPart.delete(typeName);\n              return func;\n            } else if (!(adapter instanceof Function)) {\n              toss(modeName, \"requires a function argument.\");\n            }\n            xcvPart.set(typeName, adapter);\n            return func;\n          }\n        }\n        toss(\"Invalid arguments to\", modeName);\n      };\n      target.xWrap.resultAdapter = function f(typeName, adapter) {\n        return __xAdapter(\n          f,\n          arguments.length,\n          typeName,\n          adapter,\n          \"resultAdapter()\",\n          xResult\n        );\n      };\n      target.xWrap.argAdapter = function f(typeName, adapter) {\n        return __xAdapter(\n          f,\n          arguments.length,\n          typeName,\n          adapter,\n          \"argAdapter()\",\n          xArg\n        );\n      };\n      target.xWrap.FuncPtrAdapter = xArg.FuncPtrAdapter;\n      target.xCallWrapped = function(fArg, resultType, argTypes, ...args) {\n        if (Array.isArray(arguments[3])) args = arguments[3];\n        return target.xWrap(fArg, resultType, argTypes || []).apply(null, args || []);\n      };\n      target.xWrap.testConvertArg = cache.xWrap.convertArg;\n      target.xWrap.testConvertResult = cache.xWrap.convertResult;\n      return target;\n    };\n    globalThis.WhWasmUtilInstaller.yawl = function(config) {\n      const wfetch = () => fetch(config.uri, { credentials: \"same-origin\" });\n      const wui = this;\n      const finalThen = function(arg) {\n        if (config.wasmUtilTarget) {\n          const toss = (...args) => {\n            throw new Error(args.join(\" \"));\n          };\n          const tgt = config.wasmUtilTarget;\n          tgt.module = arg.module;\n          tgt.instance = arg.instance;\n          if (!tgt.instance.exports.memory) {\n            tgt.memory = config?.imports?.env?.memory || toss(\"Missing 'memory' object!\");\n          }\n          if (!tgt.alloc && arg.instance.exports.malloc) {\n            const exports = arg.instance.exports;\n            tgt.alloc = function(n) {\n              return exports.malloc(n) || toss(\"Allocation of\", n, \"bytes failed.\");\n            };\n            tgt.dealloc = function(m) {\n              exports.free(m);\n            };\n          }\n          wui(tgt);\n        }\n        arg.config = config;\n        if (config.onload) config.onload(arg);\n        return arg;\n      };\n      const loadWasm = WebAssembly.instantiateStreaming ? () => WebAssembly.instantiateStreaming(\n        wfetch(),\n        config.imports || {}\n      ).then(finalThen) : () => wfetch().then((response) => response.arrayBuffer()).then(\n        (bytes) => WebAssembly.instantiate(bytes, config.imports || {})\n      ).then(finalThen);\n      return loadWasm;\n    }.bind(globalThis.WhWasmUtilInstaller);\n    \"use strict\";\n    globalThis.Jaccwabyt = function StructBinderFactory(config) {\n      const toss = (...args) => {\n        throw new Error(args.join(\" \"));\n      };\n      if (!(config.heap instanceof WebAssembly.Memory) && !(config.heap instanceof Function)) {\n        toss(\"config.heap must be WebAssembly.Memory instance or a function.\");\n      }\n      [\"alloc\", \"dealloc\"].forEach(function(k) {\n        config[k] instanceof Function || toss(\"Config option '\" + k + \"' must be a function.\");\n      });\n      const __heap = config.heap;\n      const SBF = StructBinderFactory;\n      const heap = __heap ? __heap : () => new Uint8Array(__heap.buffer), alloc = config.alloc, dealloc = config.dealloc, log = config.log || console.debug.bind(console), memberPrefix = config.memberPrefix || \"\", memberSuffix = config.memberSuffix || \"\", BigInt2 = globalThis[\"BigInt\"], BigInt64Array2 = globalThis[\"BigInt64Array\"], bigIntEnabled = config.bigIntEnabled ?? !!BigInt64Array2, ptrIR = config.pointerIR || config.ptrIR || \"i32\", ptrSize = config.ptrSize || (\"i32\" === ptrIR ? 4 : 8);\n      if (ptrIR !== \"i32\" && ptrIR !== \"i64\")\n        toss(\"Invalid pointer representation:\", ptrIR);\n      if (ptrSize !== 4 && ptrSize !== 8)\n        toss(\"Invalid pointer size:\", ptrSize);\n      const __BigInt = bigIntEnabled && BigInt2 ? (v2) => BigInt2(v2 || 0) : (v2) => toss(\"BigInt support is disabled in this build.\");\n      const __asPtrType = \"i32\" == ptrIR ? Number : __BigInt;\n      const __NullPtr = __asPtrType(0);\n      const __ptrAdd = function(...args) {\n        let rc = __NullPtr;\n        for (let i = 0; i < args.length; ++i) {\n          rc += __asPtrType(args[i]);\n        }\n        return rc;\n      };\n      if (!SBF.debugFlags) {\n        SBF.__makeDebugFlags = function(deriveFrom = null) {\n          if (deriveFrom && deriveFrom.__flags) deriveFrom = deriveFrom.__flags;\n          const f = function f2(flags) {\n            if (0 === arguments.length) {\n              return f2.__flags;\n            }\n            if (flags < 0) {\n              delete f2.__flags.getter;\n              delete f2.__flags.setter;\n              delete f2.__flags.alloc;\n              delete f2.__flags.dealloc;\n            } else {\n              f2.__flags.getter = 0 !== (1 & flags);\n              f2.__flags.setter = 0 !== (2 & flags);\n              f2.__flags.alloc = 0 !== (4 & flags);\n              f2.__flags.dealloc = 0 !== (8 & flags);\n            }\n            return f2._flags;\n          };\n          Object.defineProperty(f, \"__flags\", {\n            iterable: false,\n            writable: false,\n            value: Object.create(deriveFrom)\n          });\n          if (!deriveFrom) f(0);\n          return f;\n        };\n        SBF.debugFlags = SBF.__makeDebugFlags();\n      }\n      const isLittleEndian = function() {\n        const buffer = new ArrayBuffer(2);\n        new DataView(buffer).setInt16(0, 256, true);\n        return new Int16Array(buffer)[0] === 256;\n      }();\n      const isFuncSig = (s) => \"(\" === s[1];\n      const isPtrSig = (s) => \"p\" === s || \"P\" === s;\n      const isAutoPtrSig = (s) => \"P\" === s;\n      const sigLetter = (s) => isFuncSig(s) ? \"p\" : s[0];\n      const sigIR = function(s) {\n        switch (sigLetter(s)) {\n          case \"c\":\n          case \"C\":\n            return \"i8\";\n          case \"i\":\n            return \"i32\";\n          case \"p\":\n          case \"P\":\n          case \"s\":\n            return ptrIR;\n          case \"j\":\n            return \"i64\";\n          case \"f\":\n            return \"float\";\n          case \"d\":\n            return \"double\";\n        }\n        toss(\"Unhandled signature IR:\", s);\n      };\n      const affirmBigIntArray = BigInt64Array2 ? () => true : () => toss(\"BigInt64Array is not available.\");\n      const sigDVGetter = function(s) {\n        switch (sigLetter(s)) {\n          case \"p\":\n          case \"P\":\n          case \"s\": {\n            switch (ptrSize) {\n              case 4:\n                return \"getInt32\";\n              case 8:\n                return affirmBigIntArray() && \"getBigInt64\";\n            }\n            break;\n          }\n          case \"i\":\n            return \"getInt32\";\n          case \"c\":\n            return \"getInt8\";\n          case \"C\":\n            return \"getUint8\";\n          case \"j\":\n            return affirmBigIntArray() && \"getBigInt64\";\n          case \"f\":\n            return \"getFloat32\";\n          case \"d\":\n            return \"getFloat64\";\n        }\n        toss(\"Unhandled DataView getter for signature:\", s);\n      };\n      const sigDVSetter = function(s) {\n        switch (sigLetter(s)) {\n          case \"p\":\n          case \"P\":\n          case \"s\": {\n            switch (ptrSize) {\n              case 4:\n                return \"setInt32\";\n              case 8:\n                return affirmBigIntArray() && \"setBigInt64\";\n            }\n            break;\n          }\n          case \"i\":\n            return \"setInt32\";\n          case \"c\":\n            return \"setInt8\";\n          case \"C\":\n            return \"setUint8\";\n          case \"j\":\n            return affirmBigIntArray() && \"setBigInt64\";\n          case \"f\":\n            return \"setFloat32\";\n          case \"d\":\n            return \"setFloat64\";\n        }\n        toss(\"Unhandled DataView setter for signature:\", s);\n      };\n      const sigDVSetWrapper = function(s) {\n        switch (sigLetter(s)) {\n          case \"i\":\n          case \"f\":\n          case \"c\":\n          case \"C\":\n          case \"d\":\n            return Number;\n          case \"j\":\n            return __BigInt;\n          case \"p\":\n          case \"P\":\n          case \"s\":\n            switch (ptrSize) {\n              case 4:\n                return Number;\n              case 8:\n                return __BigInt;\n            }\n            break;\n        }\n        toss(\"Unhandled DataView set wrapper for signature:\", s);\n      };\n      const sPropName = (s, k) => s + \"::\" + k;\n      const __propThrowOnSet = function(structName, propName) {\n        return () => toss(sPropName(structName, propName), \"is read-only.\");\n      };\n      const __instancePointerMap = /* @__PURE__ */ new WeakMap();\n      const xPtrPropName = \"(pointer-is-external)\";\n      const __isPtr32 = (ptr) => \"number\" === typeof ptr && ptr === (ptr | 0) && ptr >= 0;\n      const __isPtr64 = (ptr) => \"bigint\" === typeof ptr && ptr >= 0 || __isPtr32(ptr);\n      const __isPtr = 4 === ptrSize ? __isPtr32 : __isPtr64;\n      const __freeStruct = function(ctor, obj, m) {\n        if (!m) m = __instancePointerMap.get(obj);\n        if (m) {\n          __instancePointerMap.delete(obj);\n          if (Array.isArray(obj.ondispose)) {\n            let x;\n            while (x = obj.ondispose.shift()) {\n              try {\n                if (x instanceof Function) x.call(obj);\n                else if (x instanceof StructType) x.dispose();\n                else if (__isPtr(x)) dealloc(x);\n              } catch (e) {\n                console.warn(\n                  \"ondispose() for\",\n                  ctor.structName,\n                  \"@\",\n                  m,\n                  \"threw. NOT propagating it.\",\n                  e\n                );\n              }\n            }\n          } else if (obj.ondispose instanceof Function) {\n            try {\n              obj.ondispose();\n            } catch (e) {\n              console.warn(\n                \"ondispose() for\",\n                ctor.structName,\n                \"@\",\n                m,\n                \"threw. NOT propagating it.\",\n                e\n              );\n            }\n          }\n          delete obj.ondispose;\n          if (ctor.debugFlags.__flags.dealloc) {\n            log(\n              \"debug.dealloc:\",\n              obj[xPtrPropName] ? \"EXTERNAL\" : \"\",\n              ctor.structName,\n              \"instance:\",\n              ctor.structInfo.sizeof,\n              \"bytes @\" + m\n            );\n          }\n          if (!obj[xPtrPropName]) dealloc(m);\n        }\n      };\n      const rop = (v2) => {\n        return {\n          configurable: false,\n          writable: false,\n          iterable: false,\n          value: v2\n        };\n      };\n      const __allocStruct = function(ctor, obj, m) {\n        let fill = !m;\n        if (m) Object.defineProperty(obj, xPtrPropName, rop(m));\n        else {\n          m = alloc(ctor.structInfo.sizeof);\n          if (!m) toss(\"Allocation of\", ctor.structName, \"structure failed.\");\n        }\n        try {\n          if (ctor.debugFlags.__flags.alloc) {\n            log(\n              \"debug.alloc:\",\n              fill ? \"\" : \"EXTERNAL\",\n              ctor.structName,\n              \"instance:\",\n              ctor.structInfo.sizeof,\n              \"bytes @\" + m\n            );\n          }\n          if (fill) {\n            heap().fill(0, Number(m), Number(m) + ctor.structInfo.sizeof);\n          }\n          __instancePointerMap.set(obj, m);\n        } catch (e) {\n          __freeStruct(ctor, obj, m);\n          throw e;\n        }\n      };\n      const __memoryDump = function() {\n        const p = this.pointer;\n        return p ? new Uint8Array(\n          heap().slice(Number(p), Number(p) + this.structInfo.sizeof)\n        ) : null;\n      };\n      const __memberKey = (k) => memberPrefix + k + memberSuffix;\n      const __memberKeyProp = rop(__memberKey);\n      const __lookupMember = function(structInfo, memberName, tossIfNotFound = true) {\n        let m = structInfo.members[memberName];\n        if (!m && (memberPrefix || memberSuffix)) {\n          for (const v2 of Object.values(structInfo.members)) {\n            if (v2.key === memberName) {\n              m = v2;\n              break;\n            }\n          }\n          if (!m && tossIfNotFound) {\n            toss(\n              sPropName(structInfo.name, memberName),\n              \"is not a mapped struct member.\"\n            );\n          }\n        }\n        return m;\n      };\n      const __memberSignature = function f(obj, memberName, emscriptenFormat = false) {\n        if (!f._)\n          f._ = (x) => x.replace(/[^vipPsjrdcC]/g, \"\").replace(/[pPscC]/g, \"i\");\n        const m = __lookupMember(obj.structInfo, memberName, true);\n        return emscriptenFormat ? f._(m.signature) : m.signature;\n      };\n      const __ptrPropDescriptor = {\n        configurable: false,\n        enumerable: false,\n        get: function() {\n          return __instancePointerMap.get(this);\n        },\n        set: () => toss(\"Cannot assign the 'pointer' property of a struct.\")\n      };\n      const __structMemberKeys = rop(function() {\n        const a = [];\n        for (const k of Object.keys(this.structInfo.members)) {\n          a.push(this.memberKey(k));\n        }\n        return a;\n      });\n      const __utf8Decoder = new TextDecoder(\"utf-8\");\n      const __utf8Encoder = new TextEncoder();\n      const __SAB = \"undefined\" === typeof SharedArrayBuffer ? function() {\n      } : SharedArrayBuffer;\n      const __utf8Decode = function(arrayBuffer, begin, end) {\n        if (8 === ptrSize) {\n          begin = Number(begin);\n          end = Number(end);\n        }\n        return __utf8Decoder.decode(\n          arrayBuffer.buffer instanceof __SAB ? arrayBuffer.slice(begin, end) : arrayBuffer.subarray(begin, end)\n        );\n      };\n      const __memberIsString = function(obj, memberName, tossIfNotFound = false) {\n        const m = __lookupMember(obj.structInfo, memberName, tossIfNotFound);\n        return m && 1 === m.signature.length && \"s\" === m.signature[0] ? m : false;\n      };\n      const __affirmCStringSignature = function(member) {\n        if (\"s\" === member.signature) return;\n        toss(\n          \"Invalid member type signature for C-string value:\",\n          JSON.stringify(member)\n        );\n      };\n      const __memberToJsString = function f(obj, memberName) {\n        const m = __lookupMember(obj.structInfo, memberName, true);\n        __affirmCStringSignature(m);\n        const addr = obj[m.key];\n        if (!addr) return null;\n        let pos = addr;\n        const mem = heap();\n        for (; mem[pos] !== 0; ++pos) {\n        }\n        return addr === pos ? \"\" : __utf8Decode(mem, addr, pos);\n      };\n      const __addOnDispose = function(obj, ...v2) {\n        if (obj.ondispose) {\n          if (!Array.isArray(obj.ondispose)) {\n            obj.ondispose = [obj.ondispose];\n          }\n        } else {\n          obj.ondispose = [];\n        }\n        obj.ondispose.push(...v2);\n      };\n      const __allocCString = function(str) {\n        const u = __utf8Encoder.encode(str);\n        const mem = alloc(u.length + 1);\n        if (!mem) toss(\"Allocation error while duplicating string:\", str);\n        const h = heap();\n        h.set(u, Number(mem));\n        h[__ptrAdd(mem, u.length)] = 0;\n        return mem;\n      };\n      const __setMemberCString = function(obj, memberName, str) {\n        const m = __lookupMember(obj.structInfo, memberName, true);\n        __affirmCStringSignature(m);\n        const mem = __allocCString(str);\n        obj[m.key] = mem;\n        __addOnDispose(obj, mem);\n        return obj;\n      };\n      const StructType = function ctor(structName, structInfo) {\n        if (arguments[2] !== rop) {\n          toss(\n            \"Do not call the StructType constructor\",\n            \"from client-level code.\"\n          );\n        }\n        Object.defineProperties(this, {\n          structName: rop(structName),\n          structInfo: rop(structInfo)\n        });\n      };\n      StructType.prototype = Object.create(null, {\n        dispose: rop(function() {\n          __freeStruct(this.constructor, this);\n        }),\n        lookupMember: rop(function(memberName, tossIfNotFound = true) {\n          return __lookupMember(this.structInfo, memberName, tossIfNotFound);\n        }),\n        memberToJsString: rop(function(memberName) {\n          return __memberToJsString(this, memberName);\n        }),\n        memberIsString: rop(function(memberName, tossIfNotFound = true) {\n          return __memberIsString(this, memberName, tossIfNotFound);\n        }),\n        memberKey: __memberKeyProp,\n        memberKeys: __structMemberKeys,\n        memberSignature: rop(function(memberName, emscriptenFormat = false) {\n          return __memberSignature(this, memberName, emscriptenFormat);\n        }),\n        memoryDump: rop(__memoryDump),\n        pointer: __ptrPropDescriptor,\n        setMemberCString: rop(function(memberName, str) {\n          return __setMemberCString(this, memberName, str);\n        })\n      });\n      Object.assign(StructType.prototype, {\n        addOnDispose: function(...v2) {\n          __addOnDispose(this, ...v2);\n          return this;\n        }\n      });\n      Object.defineProperties(StructType, {\n        allocCString: rop(__allocCString),\n        isA: rop((v2) => v2 instanceof StructType),\n        hasExternalPointer: rop(\n          (v2) => v2 instanceof StructType && !!v2[xPtrPropName]\n        ),\n        memberKey: __memberKeyProp\n      });\n      const makeMemberWrapper = function f(ctor, name, descr) {\n        if (!f._) {\n          f._ = { getters: {}, setters: {}, sw: {} };\n          const a = [\"i\", \"c\", \"C\", \"p\", \"P\", \"s\", \"f\", \"d\", \"v()\"];\n          if (bigIntEnabled) a.push(\"j\");\n          a.forEach(function(v2) {\n            f._.getters[v2] = sigDVGetter(v2);\n            f._.setters[v2] = sigDVSetter(v2);\n            f._.sw[v2] = sigDVSetWrapper(v2);\n          });\n          const rxSig1 = /^[ipPsjfdcC]$/, rxSig2 = /^[vipPsjfdcC]\\([ipPsjfdcC]*\\)$/;\n          f.sigCheck = function(obj, name2, key2, sig) {\n            if (Object.prototype.hasOwnProperty.call(obj, key2)) {\n              toss(obj.structName, \"already has a property named\", key2 + \".\");\n            }\n            rxSig1.test(sig) || rxSig2.test(sig) || toss(\n              \"Malformed signature for\",\n              sPropName(obj.structName, name2) + \":\",\n              sig\n            );\n          };\n        }\n        const key = ctor.memberKey(name);\n        f.sigCheck(ctor.prototype, name, key, descr.signature);\n        descr.key = key;\n        descr.name = name;\n        const sigGlyph = sigLetter(descr.signature);\n        const xPropName = sPropName(ctor.prototype.structName, key);\n        const dbg = ctor.prototype.debugFlags.__flags;\n        const prop = /* @__PURE__ */ Object.create(null);\n        prop.configurable = false;\n        prop.enumerable = false;\n        prop.get = function() {\n          if (dbg.getter) {\n            log(\n              \"debug.getter:\",\n              f._.getters[sigGlyph],\n              \"for\",\n              sigIR(sigGlyph),\n              xPropName,\n              \"@\",\n              this.pointer,\n              \"+\",\n              descr.offset,\n              \"sz\",\n              descr.sizeof\n            );\n          }\n          let rc = new DataView(\n            heap().buffer,\n            Number(this.pointer) + descr.offset,\n            descr.sizeof\n          )[f._.getters[sigGlyph]](0, isLittleEndian);\n          if (dbg.getter) log(\"debug.getter:\", xPropName, \"result =\", rc);\n          return rc;\n        };\n        if (descr.readOnly) {\n          prop.set = __propThrowOnSet(ctor.prototype.structName, key);\n        } else {\n          prop.set = function(v2) {\n            if (dbg.setter) {\n              log(\n                \"debug.setter:\",\n                f._.setters[sigGlyph],\n                \"for\",\n                sigIR(sigGlyph),\n                xPropName,\n                \"@\",\n                this.pointer,\n                \"+\",\n                descr.offset,\n                \"sz\",\n                descr.sizeof,\n                v2\n              );\n            }\n            if (!this.pointer) {\n              toss(\"Cannot set struct property on disposed instance.\");\n            }\n            if (null === v2) v2 = __NullPtr;\n            else\n              while (!__isPtr(v2)) {\n                if (isAutoPtrSig(descr.signature) && v2 instanceof StructType) {\n                  v2 = v2.pointer || __NullPtr;\n                  if (dbg.setter)\n                    log(\"debug.setter:\", xPropName, \"resolved to\", v2);\n                  break;\n                }\n                toss(\"Invalid value for pointer-type\", xPropName + \".\");\n              }\n            new DataView(\n              heap().buffer,\n              Number(this.pointer) + descr.offset,\n              descr.sizeof\n            )[f._.setters[sigGlyph]](0, f._.sw[sigGlyph](v2), isLittleEndian);\n          };\n        }\n        Object.defineProperty(ctor.prototype, key, prop);\n      };\n      const StructBinder = function StructBinder2(structName, structInfo) {\n        if (1 === arguments.length) {\n          structInfo = structName;\n          structName = structInfo.name;\n        } else if (!structInfo.name) {\n          structInfo.name = structName;\n        }\n        if (!structName) toss(\"Struct name is required.\");\n        let lastMember = false;\n        Object.keys(structInfo.members).forEach((k) => {\n          const m = structInfo.members[k];\n          if (!m.sizeof) toss(structName, \"member\", k, \"is missing sizeof.\");\n          else if (m.sizeof === 1) {\n            m.signature === \"c\" || m.signature === \"C\" || toss(\n              \"Unexpected sizeof==1 member\",\n              sPropName(structInfo.name, k),\n              \"with signature\",\n              m.signature\n            );\n          } else {\n            if (0 !== m.sizeof % 4) {\n              console.warn(\n                \"Invalid struct member description =\",\n                m,\n                \"from\",\n                structInfo\n              );\n              toss(\n                structName,\n                \"member\",\n                k,\n                \"sizeof is not aligned. sizeof=\" + m.sizeof\n              );\n            }\n            if (0 !== m.offset % 4) {\n              console.warn(\n                \"Invalid struct member description =\",\n                m,\n                \"from\",\n                structInfo\n              );\n              toss(\n                structName,\n                \"member\",\n                k,\n                \"offset is not aligned. offset=\" + m.offset\n              );\n            }\n          }\n          if (!lastMember || lastMember.offset < m.offset) lastMember = m;\n        });\n        if (!lastMember) toss(\"No member property descriptions found.\");\n        else if (structInfo.sizeof < lastMember.offset + lastMember.sizeof) {\n          toss(\n            \"Invalid struct config:\",\n            structName,\n            \"max member offset (\" + lastMember.offset + \") \",\n            \"extends past end of struct (sizeof=\" + structInfo.sizeof + \").\"\n          );\n        }\n        const debugFlags = rop(SBF.__makeDebugFlags(StructBinder2.debugFlags));\n        const zeroAsPtr = __asPtrType(0);\n        const StructCtor = function StructCtor2(externalMemory) {\n          externalMemory = __asPtrType(externalMemory);\n          if (!(this instanceof StructCtor2)) {\n            toss(\n              \"The\",\n              structName,\n              \"constructor may only be called via 'new'.\"\n            );\n          } else if (arguments.length) {\n            if (Number.isNaN(externalMemory) || externalMemory <= zeroAsPtr) {\n              toss(\n                \"Invalid pointer value\",\n                arguments[0],\n                \"for\",\n                structName,\n                \"constructor.\"\n              );\n            }\n            __allocStruct(StructCtor2, this, externalMemory);\n          } else {\n            __allocStruct(StructCtor2, this);\n          }\n        };\n        Object.defineProperties(StructCtor, {\n          debugFlags,\n          isA: rop((v2) => v2 instanceof StructCtor),\n          memberKey: __memberKeyProp,\n          memberKeys: __structMemberKeys,\n          methodInfoForKey: rop(function(mKey) {\n          }),\n          structInfo: rop(structInfo),\n          structName: rop(structName)\n        });\n        StructCtor.prototype = new StructType(structName, structInfo, rop);\n        Object.defineProperties(StructCtor.prototype, {\n          debugFlags,\n          constructor: rop(StructCtor)\n        });\n        Object.keys(structInfo.members).forEach(\n          (name) => makeMemberWrapper(StructCtor, name, structInfo.members[name])\n        );\n        return StructCtor;\n      };\n      StructBinder.StructType = StructType;\n      StructBinder.config = config;\n      StructBinder.allocCString = __allocCString;\n      if (!StructBinder.debugFlags) {\n        StructBinder.debugFlags = SBF.__makeDebugFlags(SBF.debugFlags);\n      }\n      return StructBinder;\n    };\n    globalThis.sqlite3ApiBootstrap.initializers.push(function(sqlite32) {\n      \"use strict\";\n      const toss = (...args) => {\n        throw new Error(args.join(\" \"));\n      };\n      const capi = sqlite32.capi, wasm = sqlite32.wasm, util = sqlite32.util;\n      globalThis.WhWasmUtilInstaller(wasm);\n      delete globalThis.WhWasmUtilInstaller;\n      if (0) {\n        const dealloc = wasm.exports[sqlite32.config.deallocExportName];\n        const nFunc = wasm.functionTable().length;\n        let i;\n        for (i = 0; i < nFunc; ++i) {\n          const e = wasm.functionEntry(i);\n          if (dealloc === e) {\n            capi.SQLITE_WASM_DEALLOC = i;\n            break;\n          }\n        }\n        if (dealloc !== wasm.functionEntry(capi.SQLITE_WASM_DEALLOC)) {\n          toss(\n            \"Internal error: cannot find function pointer for SQLITE_WASM_DEALLOC.\"\n          );\n        }\n      }\n      const bindingSignatures = {\n        core: [\n          [\"sqlite3_aggregate_context\", \"void*\", \"sqlite3_context*\", \"int\"],\n          [\"sqlite3_bind_double\", \"int\", \"sqlite3_stmt*\", \"int\", \"f64\"],\n          [\"sqlite3_bind_int\", \"int\", \"sqlite3_stmt*\", \"int\", \"int\"],\n          [\"sqlite3_bind_null\", void 0, \"sqlite3_stmt*\", \"int\"],\n          [\"sqlite3_bind_parameter_count\", \"int\", \"sqlite3_stmt*\"],\n          [\"sqlite3_bind_parameter_index\", \"int\", \"sqlite3_stmt*\", \"string\"],\n          [\"sqlite3_bind_parameter_name\", \"string\", \"sqlite3_stmt*\", \"int\"],\n          [\n            \"sqlite3_bind_pointer\",\n            \"int\",\n            \"sqlite3_stmt*\",\n            \"int\",\n            \"*\",\n            \"string:static\",\n            \"*\"\n          ],\n          [\n            \"sqlite3_busy_handler\",\n            \"int\",\n            [\n              \"sqlite3*\",\n              new wasm.xWrap.FuncPtrAdapter({\n                signature: \"i(pi)\",\n                contextKey: (argv, argIndex) => argv[0]\n              }),\n              \"*\"\n            ]\n          ],\n          [\"sqlite3_busy_timeout\", \"int\", \"sqlite3*\", \"int\"],\n          [\"sqlite3_changes\", \"int\", \"sqlite3*\"],\n          [\"sqlite3_clear_bindings\", \"int\", \"sqlite3_stmt*\"],\n          [\"sqlite3_collation_needed\", \"int\", \"sqlite3*\", \"*\", \"*\"],\n          [\"sqlite3_column_blob\", \"*\", \"sqlite3_stmt*\", \"int\"],\n          [\"sqlite3_column_bytes\", \"int\", \"sqlite3_stmt*\", \"int\"],\n          [\"sqlite3_column_count\", \"int\", \"sqlite3_stmt*\"],\n          [\"sqlite3_column_decltype\", \"string\", \"sqlite3_stmt*\", \"int\"],\n          [\"sqlite3_column_double\", \"f64\", \"sqlite3_stmt*\", \"int\"],\n          [\"sqlite3_column_int\", \"int\", \"sqlite3_stmt*\", \"int\"],\n          [\"sqlite3_column_name\", \"string\", \"sqlite3_stmt*\", \"int\"],\n          [\"sqlite3_column_text\", \"string\", \"sqlite3_stmt*\", \"int\"],\n          [\"sqlite3_column_type\", \"int\", \"sqlite3_stmt*\", \"int\"],\n          [\"sqlite3_column_value\", \"sqlite3_value*\", \"sqlite3_stmt*\", \"int\"],\n          [\n            \"sqlite3_commit_hook\",\n            \"void*\",\n            [\n              \"sqlite3*\",\n              new wasm.xWrap.FuncPtrAdapter({\n                name: \"sqlite3_commit_hook\",\n                signature: \"i(p)\",\n                contextKey: (argv) => argv[0]\n              }),\n              \"*\"\n            ]\n          ],\n          [\"sqlite3_compileoption_get\", \"string\", \"int\"],\n          [\"sqlite3_compileoption_used\", \"int\", \"string\"],\n          [\"sqlite3_complete\", \"int\", \"string:flexible\"],\n          [\"sqlite3_context_db_handle\", \"sqlite3*\", \"sqlite3_context*\"],\n          [\"sqlite3_data_count\", \"int\", \"sqlite3_stmt*\"],\n          [\"sqlite3_db_filename\", \"string\", \"sqlite3*\", \"string\"],\n          [\"sqlite3_db_handle\", \"sqlite3*\", \"sqlite3_stmt*\"],\n          [\"sqlite3_db_name\", \"string\", \"sqlite3*\", \"int\"],\n          [\"sqlite3_db_readonly\", \"int\", \"sqlite3*\", \"string\"],\n          [\"sqlite3_db_status\", \"int\", \"sqlite3*\", \"int\", \"*\", \"*\", \"int\"],\n          [\"sqlite3_errcode\", \"int\", \"sqlite3*\"],\n          [\"sqlite3_errmsg\", \"string\", \"sqlite3*\"],\n          [\"sqlite3_error_offset\", \"int\", \"sqlite3*\"],\n          [\"sqlite3_errstr\", \"string\", \"int\"],\n          [\n            \"sqlite3_exec\",\n            \"int\",\n            [\n              \"sqlite3*\",\n              \"string:flexible\",\n              new wasm.xWrap.FuncPtrAdapter({\n                signature: \"i(pipp)\",\n                bindScope: \"transient\",\n                callProxy: (callback) => {\n                  let aNames;\n                  return (pVoid, nCols, pColVals, pColNames) => {\n                    try {\n                      const aVals = wasm.cArgvToJs(nCols, pColVals);\n                      if (!aNames) aNames = wasm.cArgvToJs(nCols, pColNames);\n                      return callback(aVals, aNames) | 0;\n                    } catch (e) {\n                      return e.resultCode || capi.SQLITE_ERROR;\n                    }\n                  };\n                }\n              }),\n              \"*\",\n              \"**\"\n            ]\n          ],\n          [\"sqlite3_expanded_sql\", \"string\", \"sqlite3_stmt*\"],\n          [\"sqlite3_extended_errcode\", \"int\", \"sqlite3*\"],\n          [\"sqlite3_extended_result_codes\", \"int\", \"sqlite3*\", \"int\"],\n          [\"sqlite3_file_control\", \"int\", \"sqlite3*\", \"string\", \"int\", \"*\"],\n          [\"sqlite3_finalize\", \"int\", \"sqlite3_stmt*\"],\n          [\"sqlite3_free\", void 0, \"*\"],\n          [\"sqlite3_get_autocommit\", \"int\", \"sqlite3*\"],\n          [\"sqlite3_get_auxdata\", \"*\", \"sqlite3_context*\", \"int\"],\n          [\"sqlite3_initialize\", void 0],\n          [\"sqlite3_interrupt\", void 0, \"sqlite3*\"],\n          [\"sqlite3_is_interrupted\", \"int\", \"sqlite3*\"],\n          [\"sqlite3_keyword_count\", \"int\"],\n          [\"sqlite3_keyword_name\", \"int\", [\"int\", \"**\", \"*\"]],\n          [\"sqlite3_keyword_check\", \"int\", [\"string\", \"int\"]],\n          [\"sqlite3_libversion\", \"string\"],\n          [\"sqlite3_libversion_number\", \"int\"],\n          [\"sqlite3_limit\", \"int\", [\"sqlite3*\", \"int\", \"int\"]],\n          [\"sqlite3_malloc\", \"*\", \"int\"],\n          [\"sqlite3_open\", \"int\", \"string\", \"*\"],\n          [\"sqlite3_open_v2\", \"int\", \"string\", \"*\", \"int\", \"string\"],\n          [\"sqlite3_realloc\", \"*\", \"*\", \"int\"],\n          [\"sqlite3_reset\", \"int\", \"sqlite3_stmt*\"],\n          [\n            \"sqlite3_result_blob\",\n            void 0,\n            \"sqlite3_context*\",\n            \"*\",\n            \"int\",\n            \"*\"\n          ],\n          [\"sqlite3_result_double\", void 0, \"sqlite3_context*\", \"f64\"],\n          [\n            \"sqlite3_result_error\",\n            void 0,\n            \"sqlite3_context*\",\n            \"string\",\n            \"int\"\n          ],\n          [\"sqlite3_result_error_code\", void 0, \"sqlite3_context*\", \"int\"],\n          [\"sqlite3_result_error_nomem\", void 0, \"sqlite3_context*\"],\n          [\"sqlite3_result_error_toobig\", void 0, \"sqlite3_context*\"],\n          [\"sqlite3_result_int\", void 0, \"sqlite3_context*\", \"int\"],\n          [\"sqlite3_result_null\", void 0, \"sqlite3_context*\"],\n          [\n            \"sqlite3_result_pointer\",\n            void 0,\n            \"sqlite3_context*\",\n            \"*\",\n            \"string:static\",\n            \"*\"\n          ],\n          [\"sqlite3_result_subtype\", void 0, \"sqlite3_value*\", \"int\"],\n          [\n            \"sqlite3_result_text\",\n            void 0,\n            \"sqlite3_context*\",\n            \"string\",\n            \"int\",\n            \"*\"\n          ],\n          [\"sqlite3_result_zeroblob\", void 0, \"sqlite3_context*\", \"int\"],\n          [\n            \"sqlite3_rollback_hook\",\n            \"void*\",\n            [\n              \"sqlite3*\",\n              new wasm.xWrap.FuncPtrAdapter({\n                name: \"sqlite3_rollback_hook\",\n                signature: \"v(p)\",\n                contextKey: (argv) => argv[0]\n              }),\n              \"*\"\n            ]\n          ],\n          [\n            \"sqlite3_set_auxdata\",\n            void 0,\n            [\n              \"sqlite3_context*\",\n              \"int\",\n              \"*\",\n              true ? \"*\" : new wasm.xWrap.FuncPtrAdapter({\n                name: \"xDestroyAuxData\",\n                signature: \"v(p)\",\n                contextKey: (argv, argIndex) => argv[0]\n              })\n            ]\n          ],\n          [\"sqlite3_set_errmsg\", \"int\", \"sqlite3*\", \"int\", \"string\"],\n          [\"sqlite3_shutdown\", void 0],\n          [\"sqlite3_sourceid\", \"string\"],\n          [\"sqlite3_sql\", \"string\", \"sqlite3_stmt*\"],\n          [\"sqlite3_status\", \"int\", \"int\", \"*\", \"*\", \"int\"],\n          [\"sqlite3_step\", \"int\", \"sqlite3_stmt*\"],\n          [\"sqlite3_stmt_busy\", \"int\", \"sqlite3_stmt*\"],\n          [\"sqlite3_stmt_readonly\", \"int\", \"sqlite3_stmt*\"],\n          [\"sqlite3_stmt_status\", \"int\", \"sqlite3_stmt*\", \"int\", \"int\"],\n          [\"sqlite3_strglob\", \"int\", \"string\", \"string\"],\n          [\"sqlite3_stricmp\", \"int\", \"string\", \"string\"],\n          [\"sqlite3_strlike\", \"int\", \"string\", \"string\", \"int\"],\n          [\"sqlite3_strnicmp\", \"int\", \"string\", \"string\", \"int\"],\n          [\n            \"sqlite3_table_column_metadata\",\n            \"int\",\n            \"sqlite3*\",\n            \"string\",\n            \"string\",\n            \"string\",\n            \"**\",\n            \"**\",\n            \"*\",\n            \"*\",\n            \"*\"\n          ],\n          [\"sqlite3_total_changes\", \"int\", \"sqlite3*\"],\n          [\n            \"sqlite3_trace_v2\",\n            \"int\",\n            [\n              \"sqlite3*\",\n              \"int\",\n              new wasm.xWrap.FuncPtrAdapter({\n                name: \"sqlite3_trace_v2::callback\",\n                signature: \"i(ippp)\",\n                contextKey: (argv, argIndex) => argv[0]\n              }),\n              \"*\"\n            ]\n          ],\n          [\"sqlite3_txn_state\", \"int\", [\"sqlite3*\", \"string\"]],\n          [\"sqlite3_uri_boolean\", \"int\", \"sqlite3_filename\", \"string\", \"int\"],\n          [\"sqlite3_uri_key\", \"string\", \"sqlite3_filename\", \"int\"],\n          [\"sqlite3_uri_parameter\", \"string\", \"sqlite3_filename\", \"string\"],\n          [\"sqlite3_user_data\", \"void*\", \"sqlite3_context*\"],\n          [\"sqlite3_value_blob\", \"*\", \"sqlite3_value*\"],\n          [\"sqlite3_value_bytes\", \"int\", \"sqlite3_value*\"],\n          [\"sqlite3_value_double\", \"f64\", \"sqlite3_value*\"],\n          [\"sqlite3_value_dup\", \"sqlite3_value*\", \"sqlite3_value*\"],\n          [\"sqlite3_value_free\", void 0, \"sqlite3_value*\"],\n          [\"sqlite3_value_frombind\", \"int\", \"sqlite3_value*\"],\n          [\"sqlite3_value_int\", \"int\", \"sqlite3_value*\"],\n          [\"sqlite3_value_nochange\", \"int\", \"sqlite3_value*\"],\n          [\"sqlite3_value_numeric_type\", \"int\", \"sqlite3_value*\"],\n          [\"sqlite3_value_pointer\", \"*\", \"sqlite3_value*\", \"string:static\"],\n          [\"sqlite3_value_subtype\", \"int\", \"sqlite3_value*\"],\n          [\"sqlite3_value_text\", \"string\", \"sqlite3_value*\"],\n          [\"sqlite3_value_type\", \"int\", \"sqlite3_value*\"],\n          [\"sqlite3_vfs_find\", \"*\", \"string\"],\n          [\"sqlite3_vfs_register\", \"int\", \"sqlite3_vfs*\", \"int\"],\n          [\"sqlite3_vfs_unregister\", \"int\", \"sqlite3_vfs*\"]\n        ],\n        int64: [\n          [\"sqlite3_bind_int64\", \"int\", [\"sqlite3_stmt*\", \"int\", \"i64\"]],\n          [\"sqlite3_changes64\", \"i64\", [\"sqlite3*\"]],\n          [\"sqlite3_column_int64\", \"i64\", [\"sqlite3_stmt*\", \"int\"]],\n          [\n            \"sqlite3_deserialize\",\n            \"int\",\n            \"sqlite3*\",\n            \"string\",\n            \"*\",\n            \"i64\",\n            \"i64\",\n            \"int\"\n          ],\n          [\"sqlite3_last_insert_rowid\", \"i64\", [\"sqlite3*\"]],\n          [\"sqlite3_malloc64\", \"*\", \"i64\"],\n          [\"sqlite3_msize\", \"i64\", \"*\"],\n          [\"sqlite3_overload_function\", \"int\", [\"sqlite3*\", \"string\", \"int\"]],\n          [\"sqlite3_realloc64\", \"*\", \"*\", \"i64\"],\n          [\"sqlite3_result_int64\", void 0, \"*\", \"i64\"],\n          [\"sqlite3_result_zeroblob64\", \"int\", \"*\", \"i64\"],\n          [\"sqlite3_serialize\", \"*\", \"sqlite3*\", \"string\", \"*\", \"int\"],\n          [\"sqlite3_set_last_insert_rowid\", void 0, [\"sqlite3*\", \"i64\"]],\n          [\"sqlite3_status64\", \"int\", \"int\", \"*\", \"*\", \"int\"],\n          [\"sqlite3_db_status64\", \"int\", \"sqlite3*\", \"int\", \"*\", \"*\", \"int\"],\n          [\"sqlite3_total_changes64\", \"i64\", [\"sqlite3*\"]],\n          [\n            \"sqlite3_update_hook\",\n            \"*\",\n            [\n              \"sqlite3*\",\n              new wasm.xWrap.FuncPtrAdapter({\n                name: \"sqlite3_update_hook::callback\",\n                signature: \"v(pippj)\",\n                contextKey: (argv) => argv[0],\n                callProxy: (callback) => {\n                  return (p, op, z0, z1, rowid) => {\n                    callback(\n                      p,\n                      op,\n                      wasm.cstrToJs(z0),\n                      wasm.cstrToJs(z1),\n                      rowid\n                    );\n                  };\n                }\n              }),\n              \"*\"\n            ]\n          ],\n          [\"sqlite3_uri_int64\", \"i64\", [\"sqlite3_filename\", \"string\", \"i64\"]],\n          [\"sqlite3_value_int64\", \"i64\", \"sqlite3_value*\"]\n        ],\n        wasmInternal: [\n          [\"sqlite3__wasm_db_reset\", \"int\", \"sqlite3*\"],\n          [\"sqlite3__wasm_db_vfs\", \"sqlite3_vfs*\", \"sqlite3*\", \"string\"],\n          [\n            \"sqlite3__wasm_vfs_create_file\",\n            \"int\",\n            \"sqlite3_vfs*\",\n            \"string\",\n            \"*\",\n            \"int\"\n          ],\n          [\"sqlite3__wasm_posix_create_file\", \"int\", \"string\", \"*\", \"int\"],\n          [\"sqlite3__wasm_vfs_unlink\", \"int\", \"sqlite3_vfs*\", \"string\"],\n          [\"sqlite3__wasm_qfmt_token\", \"string:dealloc\", \"string\", \"int\"]\n        ]\n      };\n      if (!!wasm.exports.sqlite3_progress_handler) {\n        bindingSignatures.core.push([\n          \"sqlite3_progress_handler\",\n          void 0,\n          [\n            \"sqlite3*\",\n            \"int\",\n            new wasm.xWrap.FuncPtrAdapter({\n              name: \"xProgressHandler\",\n              signature: \"i(p)\",\n              bindScope: \"context\",\n              contextKey: (argv, argIndex) => argv[0]\n            }),\n            \"*\"\n          ]\n        ]);\n      }\n      if (!!wasm.exports.sqlite3_stmt_explain) {\n        bindingSignatures.core.push(\n          [\"sqlite3_stmt_explain\", \"int\", \"sqlite3_stmt*\", \"int\"],\n          [\"sqlite3_stmt_isexplain\", \"int\", \"sqlite3_stmt*\"]\n        );\n      }\n      if (!!wasm.exports.sqlite3_set_authorizer) {\n        bindingSignatures.core.push([\n          \"sqlite3_set_authorizer\",\n          \"int\",\n          [\n            \"sqlite3*\",\n            new wasm.xWrap.FuncPtrAdapter({\n              name: \"sqlite3_set_authorizer::xAuth\",\n              signature: \"i(pissss)\",\n              contextKey: (argv, argIndex) => argv[0],\n              callProxy: (callback) => {\n                return (pV, iCode, s0, s1, s2, s3) => {\n                  try {\n                    s0 = s0 && wasm.cstrToJs(s0);\n                    s1 = s1 && wasm.cstrToJs(s1);\n                    s2 = s2 && wasm.cstrToJs(s2);\n                    s3 = s3 && wasm.cstrToJs(s3);\n                    return callback(pV, iCode, s0, s1, s2, s3) | 0;\n                  } catch (e) {\n                    return e.resultCode || capi.SQLITE_ERROR;\n                  }\n                };\n              }\n            }),\n            \"*\"\n          ]\n        ]);\n      }\n      if (!!wasm.exports.sqlite3_column_origin_name) {\n        bindingSignatures.core.push(\n          [\"sqlite3_column_database_name\", \"string\", \"sqlite3_stmt*\", \"int\"],\n          [\"sqlite3_column_origin_name\", \"string\", \"sqlite3_stmt*\", \"int\"],\n          [\"sqlite3_column_table_name\", \"string\", \"sqlite3_stmt*\", \"int\"]\n        );\n      }\n      if (false) {\n        bindingSignatures.core.push([\n          \"sqlite3_normalized_sql\",\n          \"string\",\n          \"sqlite3_stmt*\"\n        ]);\n      }\n      if (wasm.bigIntEnabled && !!wasm.exports.sqlite3_declare_vtab) {\n        bindingSignatures.int64.push(\n          [\n            \"sqlite3_create_module\",\n            \"int\",\n            [\"sqlite3*\", \"string\", \"sqlite3_module*\", \"*\"]\n          ],\n          [\n            \"sqlite3_create_module_v2\",\n            \"int\",\n            [\"sqlite3*\", \"string\", \"sqlite3_module*\", \"*\", \"*\"]\n          ],\n          [\"sqlite3_declare_vtab\", \"int\", [\"sqlite3*\", \"string:flexible\"]],\n          [\"sqlite3_drop_modules\", \"int\", [\"sqlite3*\", \"**\"]],\n          [\"sqlite3_vtab_collation\", \"string\", \"sqlite3_index_info*\", \"int\"],\n          [\"sqlite3_vtab_distinct\", \"int\", \"sqlite3_index_info*\"],\n          [\"sqlite3_vtab_in\", \"int\", \"sqlite3_index_info*\", \"int\", \"int\"],\n          [\"sqlite3_vtab_in_first\", \"int\", \"sqlite3_value*\", \"**\"],\n          [\"sqlite3_vtab_in_next\", \"int\", \"sqlite3_value*\", \"**\"],\n          [\"sqlite3_vtab_nochange\", \"int\", \"sqlite3_context*\"],\n          [\"sqlite3_vtab_on_conflict\", \"int\", \"sqlite3*\"],\n          [\"sqlite3_vtab_rhs_value\", \"int\", \"sqlite3_index_info*\", \"int\", \"**\"]\n        );\n      }\n      if (wasm.bigIntEnabled && !!wasm.exports.sqlite3_preupdate_hook) {\n        bindingSignatures.int64.push(\n          [\"sqlite3_preupdate_blobwrite\", \"int\", \"sqlite3*\"],\n          [\"sqlite3_preupdate_count\", \"int\", \"sqlite3*\"],\n          [\"sqlite3_preupdate_depth\", \"int\", \"sqlite3*\"],\n          [\n            \"sqlite3_preupdate_hook\",\n            \"*\",\n            [\n              \"sqlite3*\",\n              new wasm.xWrap.FuncPtrAdapter({\n                name: \"sqlite3_preupdate_hook\",\n                signature: \"v(ppippjj)\",\n                contextKey: (argv) => argv[0],\n                callProxy: (callback) => {\n                  return (p, db, op, zDb, zTbl, iKey1, iKey2) => {\n                    callback(\n                      p,\n                      db,\n                      op,\n                      wasm.cstrToJs(zDb),\n                      wasm.cstrToJs(zTbl),\n                      iKey1,\n                      iKey2\n                    );\n                  };\n                }\n              }),\n              \"*\"\n            ]\n          ],\n          [\"sqlite3_preupdate_new\", \"int\", [\"sqlite3*\", \"int\", \"**\"]],\n          [\"sqlite3_preupdate_old\", \"int\", [\"sqlite3*\", \"int\", \"**\"]]\n        );\n      }\n      if (wasm.bigIntEnabled && !!wasm.exports.sqlite3changegroup_add && !!wasm.exports.sqlite3session_create && !!wasm.exports.sqlite3_preupdate_hook) {\n        const __ipsProxy = {\n          signature: \"i(ps)\",\n          callProxy: (callback) => {\n            return (p, s) => {\n              try {\n                return callback(p, wasm.cstrToJs(s)) | 0;\n              } catch (e) {\n                return e.resultCode || capi.SQLITE_ERROR;\n              }\n            };\n          }\n        };\n        bindingSignatures.int64.push(\n          [\n            \"sqlite3changegroup_add\",\n            \"int\",\n            [\"sqlite3_changegroup*\", \"int\", \"void*\"]\n          ],\n          [\n            \"sqlite3changegroup_add_strm\",\n            \"int\",\n            [\n              \"sqlite3_changegroup*\",\n              new wasm.xWrap.FuncPtrAdapter({\n                name: \"xInput\",\n                signature: \"i(ppp)\",\n                bindScope: \"transient\"\n              }),\n              \"void*\"\n            ]\n          ],\n          [\"sqlite3changegroup_delete\", void 0, [\"sqlite3_changegroup*\"]],\n          [\"sqlite3changegroup_new\", \"int\", [\"**\"]],\n          [\n            \"sqlite3changegroup_output\",\n            \"int\",\n            [\"sqlite3_changegroup*\", \"int*\", \"**\"]\n          ],\n          [\n            \"sqlite3changegroup_output_strm\",\n            \"int\",\n            [\n              \"sqlite3_changegroup*\",\n              new wasm.xWrap.FuncPtrAdapter({\n                name: \"xOutput\",\n                signature: \"i(ppi)\",\n                bindScope: \"transient\"\n              }),\n              \"void*\"\n            ]\n          ],\n          [\n            \"sqlite3changeset_apply\",\n            \"int\",\n            [\n              \"sqlite3*\",\n              \"int\",\n              \"void*\",\n              new wasm.xWrap.FuncPtrAdapter({\n                name: \"xFilter\",\n                bindScope: \"transient\",\n                ...__ipsProxy\n              }),\n              new wasm.xWrap.FuncPtrAdapter({\n                name: \"xConflict\",\n                signature: \"i(pip)\",\n                bindScope: \"transient\"\n              }),\n              \"void*\"\n            ]\n          ],\n          [\n            \"sqlite3changeset_apply_strm\",\n            \"int\",\n            [\n              \"sqlite3*\",\n              new wasm.xWrap.FuncPtrAdapter({\n                name: \"xInput\",\n                signature: \"i(ppp)\",\n                bindScope: \"transient\"\n              }),\n              \"void*\",\n              new wasm.xWrap.FuncPtrAdapter({\n                name: \"xFilter\",\n                bindScope: \"transient\",\n                ...__ipsProxy\n              }),\n              new wasm.xWrap.FuncPtrAdapter({\n                name: \"xConflict\",\n                signature: \"i(pip)\",\n                bindScope: \"transient\"\n              }),\n              \"void*\"\n            ]\n          ],\n          [\n            \"sqlite3changeset_apply_v2\",\n            \"int\",\n            [\n              \"sqlite3*\",\n              \"int\",\n              \"void*\",\n              new wasm.xWrap.FuncPtrAdapter({\n                name: \"xFilter\",\n                bindScope: \"transient\",\n                ...__ipsProxy\n              }),\n              new wasm.xWrap.FuncPtrAdapter({\n                name: \"xConflict\",\n                signature: \"i(pip)\",\n                bindScope: \"transient\"\n              }),\n              \"void*\",\n              \"**\",\n              \"int*\",\n              \"int\"\n            ]\n          ],\n          [\n            \"sqlite3changeset_apply_v2_strm\",\n            \"int\",\n            [\n              \"sqlite3*\",\n              new wasm.xWrap.FuncPtrAdapter({\n                name: \"xInput\",\n                signature: \"i(ppp)\",\n                bindScope: \"transient\"\n              }),\n              \"void*\",\n              new wasm.xWrap.FuncPtrAdapter({\n                name: \"xFilter\",\n                bindScope: \"transient\",\n                ...__ipsProxy\n              }),\n              new wasm.xWrap.FuncPtrAdapter({\n                name: \"xConflict\",\n                signature: \"i(pip)\",\n                bindScope: \"transient\"\n              }),\n              \"void*\",\n              \"**\",\n              \"int*\",\n              \"int\"\n            ]\n          ],\n          [\n            \"sqlite3changeset_apply_v3\",\n            \"int\",\n            [\n              \"sqlite3*\",\n              \"int\",\n              \"void*\",\n              new wasm.xWrap.FuncPtrAdapter({\n                name: \"xFilter\",\n                signature: \"i(pp)\",\n                bindScope: \"transient\"\n              }),\n              new wasm.xWrap.FuncPtrAdapter({\n                name: \"xConflict\",\n                signature: \"i(pip)\",\n                bindScope: \"transient\"\n              }),\n              \"void*\",\n              \"**\",\n              \"int*\",\n              \"int\"\n            ]\n          ],\n          [\n            \"sqlite3changeset_apply_v3_strm\",\n            \"int\",\n            [\n              \"sqlite3*\",\n              new wasm.xWrap.FuncPtrAdapter({\n                name: \"xInput\",\n                signature: \"i(ppp)\",\n                bindScope: \"transient\"\n              }),\n              \"void*\",\n              new wasm.xWrap.FuncPtrAdapter({\n                name: \"xFilter\",\n                signature: \"i(pp)\",\n                bindScope: \"transient\"\n              }),\n              new wasm.xWrap.FuncPtrAdapter({\n                name: \"xConflict\",\n                signature: \"i(pip)\",\n                bindScope: \"transient\"\n              }),\n              \"void*\",\n              \"**\",\n              \"int*\",\n              \"int\"\n            ]\n          ],\n          [\n            \"sqlite3changeset_concat\",\n            \"int\",\n            [\"int\", \"void*\", \"int\", \"void*\", \"int*\", \"**\"]\n          ],\n          [\n            \"sqlite3changeset_concat_strm\",\n            \"int\",\n            [\n              new wasm.xWrap.FuncPtrAdapter({\n                name: \"xInputA\",\n                signature: \"i(ppp)\",\n                bindScope: \"transient\"\n              }),\n              \"void*\",\n              new wasm.xWrap.FuncPtrAdapter({\n                name: \"xInputB\",\n                signature: \"i(ppp)\",\n                bindScope: \"transient\"\n              }),\n              \"void*\",\n              new wasm.xWrap.FuncPtrAdapter({\n                name: \"xOutput\",\n                signature: \"i(ppi)\",\n                bindScope: \"transient\"\n              }),\n              \"void*\"\n            ]\n          ],\n          [\n            \"sqlite3changeset_conflict\",\n            \"int\",\n            [\"sqlite3_changeset_iter*\", \"int\", \"**\"]\n          ],\n          [\"sqlite3changeset_finalize\", \"int\", [\"sqlite3_changeset_iter*\"]],\n          [\n            \"sqlite3changeset_fk_conflicts\",\n            \"int\",\n            [\"sqlite3_changeset_iter*\", \"int*\"]\n          ],\n          [\"sqlite3changeset_invert\", \"int\", [\"int\", \"void*\", \"int*\", \"**\"]],\n          [\n            \"sqlite3changeset_invert_strm\",\n            \"int\",\n            [\n              new wasm.xWrap.FuncPtrAdapter({\n                name: \"xInput\",\n                signature: \"i(ppp)\",\n                bindScope: \"transient\"\n              }),\n              \"void*\",\n              new wasm.xWrap.FuncPtrAdapter({\n                name: \"xOutput\",\n                signature: \"i(ppi)\",\n                bindScope: \"transient\"\n              }),\n              \"void*\"\n            ]\n          ],\n          [\n            \"sqlite3changeset_new\",\n            \"int\",\n            [\"sqlite3_changeset_iter*\", \"int\", \"**\"]\n          ],\n          [\"sqlite3changeset_next\", \"int\", [\"sqlite3_changeset_iter*\"]],\n          [\n            \"sqlite3changeset_old\",\n            \"int\",\n            [\"sqlite3_changeset_iter*\", \"int\", \"**\"]\n          ],\n          [\n            \"sqlite3changeset_op\",\n            \"int\",\n            [\"sqlite3_changeset_iter*\", \"**\", \"int*\", \"int*\", \"int*\"]\n          ],\n          [\n            \"sqlite3changeset_pk\",\n            \"int\",\n            [\"sqlite3_changeset_iter*\", \"**\", \"int*\"]\n          ],\n          [\"sqlite3changeset_start\", \"int\", [\"**\", \"int\", \"*\"]],\n          [\n            \"sqlite3changeset_start_strm\",\n            \"int\",\n            [\n              \"**\",\n              new wasm.xWrap.FuncPtrAdapter({\n                name: \"xInput\",\n                signature: \"i(ppp)\",\n                bindScope: \"transient\"\n              }),\n              \"void*\"\n            ]\n          ],\n          [\"sqlite3changeset_start_v2\", \"int\", [\"**\", \"int\", \"*\", \"int\"]],\n          [\n            \"sqlite3changeset_start_v2_strm\",\n            \"int\",\n            [\n              \"**\",\n              new wasm.xWrap.FuncPtrAdapter({\n                name: \"xInput\",\n                signature: \"i(ppp)\",\n                bindScope: \"transient\"\n              }),\n              \"void*\",\n              \"int\"\n            ]\n          ],\n          [\"sqlite3session_attach\", \"int\", [\"sqlite3_session*\", \"string\"]],\n          [\n            \"sqlite3session_changeset\",\n            \"int\",\n            [\"sqlite3_session*\", \"int*\", \"**\"]\n          ],\n          [\"sqlite3session_changeset_size\", \"i64\", [\"sqlite3_session*\"]],\n          [\n            \"sqlite3session_changeset_strm\",\n            \"int\",\n            [\n              \"sqlite3_session*\",\n              new wasm.xWrap.FuncPtrAdapter({\n                name: \"xOutput\",\n                signature: \"i(ppp)\",\n                bindScope: \"transient\"\n              }),\n              \"void*\"\n            ]\n          ],\n          [\"sqlite3session_config\", \"int\", [\"int\", \"void*\"]],\n          [\"sqlite3session_create\", \"int\", [\"sqlite3*\", \"string\", \"**\"]],\n          [\n            \"sqlite3session_diff\",\n            \"int\",\n            [\"sqlite3_session*\", \"string\", \"string\", \"**\"]\n          ],\n          [\"sqlite3session_enable\", \"int\", [\"sqlite3_session*\", \"int\"]],\n          [\"sqlite3session_indirect\", \"int\", [\"sqlite3_session*\", \"int\"]],\n          [\"sqlite3session_isempty\", \"int\", [\"sqlite3_session*\"]],\n          [\"sqlite3session_memory_used\", \"i64\", [\"sqlite3_session*\"]],\n          [\n            \"sqlite3session_object_config\",\n            \"int\",\n            [\"sqlite3_session*\", \"int\", \"void*\"]\n          ],\n          [\"sqlite3session_patchset\", \"int\", [\"sqlite3_session*\", \"*\", \"**\"]],\n          [\n            \"sqlite3session_patchset_strm\",\n            \"int\",\n            [\n              \"sqlite3_session*\",\n              new wasm.xWrap.FuncPtrAdapter({\n                name: \"xOutput\",\n                signature: \"i(ppp)\",\n                bindScope: \"transient\"\n              }),\n              \"void*\"\n            ]\n          ],\n          [\n            \"sqlite3session_table_filter\",\n            void 0,\n            [\n              \"sqlite3_session*\",\n              new wasm.xWrap.FuncPtrAdapter({\n                name: \"xFilter\",\n                ...__ipsProxy,\n                contextKey: (argv, argIndex) => argv[0]\n              }),\n              \"*\"\n            ]\n          ]\n        );\n      }\n      sqlite32.StructBinder = globalThis.Jaccwabyt({\n        heap: wasm.heap8u,\n        alloc: wasm.alloc,\n        dealloc: wasm.dealloc,\n        bigIntEnabled: wasm.bigIntEnabled,\n        pointerIR: wasm.ptr.ir,\n        memberPrefix: \"$\"\n      });\n      delete globalThis.Jaccwabyt;\n      {\n        const __xString = wasm.xWrap.argAdapter(\"string\");\n        wasm.xWrap.argAdapter(\n          \"string:flexible\",\n          (v2) => __xString(util.flexibleString(v2))\n        );\n        wasm.xWrap.argAdapter(\n          \"string:static\",\n          function(v2) {\n            if (wasm.isPtr(v2)) return v2;\n            v2 = \"\" + v2;\n            let rc = this[v2];\n            return rc || (this[v2] = wasm.allocCString(v2));\n          }.bind(/* @__PURE__ */ Object.create(null))\n        );\n        const __xArgPtr = wasm.xWrap.argAdapter(\"*\");\n        const nilType = function() {\n        };\n        wasm.xWrap.argAdapter(\"sqlite3_filename\", __xArgPtr)(\n          \"sqlite3_context*\",\n          __xArgPtr\n        )(\"sqlite3_value*\", __xArgPtr)(\"void*\", __xArgPtr)(\n          \"sqlite3_changegroup*\",\n          __xArgPtr\n        )(\"sqlite3_changeset_iter*\", __xArgPtr)(\"sqlite3_session*\", __xArgPtr)(\n          \"sqlite3_stmt*\",\n          (v2) => __xArgPtr(\n            v2 instanceof (sqlite32?.oo1?.Stmt || nilType) ? v2.pointer : v2\n          )\n        )(\n          \"sqlite3*\",\n          (v2) => __xArgPtr(v2 instanceof (sqlite32?.oo1?.DB || nilType) ? v2.pointer : v2)\n        )(\"sqlite3_vfs*\", (v2) => {\n          if (\"string\" === typeof v2) {\n            return capi.sqlite3_vfs_find(v2) || sqlite32.SQLite3Error.toss(\n              capi.SQLITE_NOTFOUND,\n              \"Unknown sqlite3_vfs name:\",\n              v2\n            );\n          }\n          return __xArgPtr(\n            v2 instanceof (capi.sqlite3_vfs || nilType) ? v2.pointer : v2\n          );\n        });\n        if (wasm.exports.sqlite3_declare_vtab) {\n          wasm.xWrap.argAdapter(\n            \"sqlite3_index_info*\",\n            (v2) => __xArgPtr(\n              v2 instanceof (capi.sqlite3_index_info || nilType) ? v2.pointer : v2\n            )\n          )(\n            \"sqlite3_module*\",\n            (v2) => __xArgPtr(\n              v2 instanceof (capi.sqlite3_module || nilType) ? v2.pointer : v2\n            )\n          );\n        }\n        const __xRcPtr = wasm.xWrap.resultAdapter(\"*\");\n        wasm.xWrap.resultAdapter(\"sqlite3*\", __xRcPtr)(\n          \"sqlite3_context*\",\n          __xRcPtr\n        )(\"sqlite3_stmt*\", __xRcPtr)(\"sqlite3_value*\", __xRcPtr)(\n          \"sqlite3_vfs*\",\n          __xRcPtr\n        )(\"void*\", __xRcPtr);\n        for (const e of bindingSignatures.core) {\n          capi[e[0]] = wasm.xWrap.apply(null, e);\n        }\n        for (const e of bindingSignatures.wasmInternal) {\n          util[e[0]] = wasm.xWrap.apply(null, e);\n        }\n        for (const e of bindingSignatures.int64) {\n          capi[e[0]] = wasm.bigIntEnabled ? wasm.xWrap.apply(null, e) : () => toss(\n            e[0] + \"() is unavailable due to lack\",\n            \"of BigInt support in this build.\"\n          );\n        }\n        delete bindingSignatures.core;\n        delete bindingSignatures.int64;\n        delete bindingSignatures.wasmInternal;\n        util.sqlite3__wasm_db_error = function(pDb2, resultCode, message) {\n          if (!pDb2) return capi.SQLITE_MISUSE;\n          if (resultCode instanceof sqlite32.WasmAllocError) {\n            resultCode = capi.SQLITE_NOMEM;\n            message = 0;\n          } else if (resultCode instanceof Error) {\n            message = message || \"\" + resultCode;\n            resultCode = resultCode.resultCode || capi.SQLITE_ERROR;\n          }\n          return capi.sqlite3_set_errmsg(pDb2, resultCode, message) || resultCode;\n        };\n      }\n      {\n        const cJson = wasm.xCall(\"sqlite3__wasm_enum_json\");\n        if (!cJson) {\n          toss(\n            \"Maintenance required: increase sqlite3__wasm_enum_json()'s\",\n            \"static buffer size!\"\n          );\n        }\n        wasm.ctype = JSON.parse(wasm.cstrToJs(cJson));\n        const defineGroups = [\n          \"access\",\n          \"authorizer\",\n          \"blobFinalizers\",\n          \"changeset\",\n          \"config\",\n          \"dataTypes\",\n          \"dbConfig\",\n          \"dbStatus\",\n          \"encodings\",\n          \"fcntl\",\n          \"flock\",\n          \"ioCap\",\n          \"limits\",\n          \"openFlags\",\n          \"prepareFlags\",\n          \"resultCodes\",\n          \"sqlite3Status\",\n          \"stmtStatus\",\n          \"syncFlags\",\n          \"trace\",\n          \"txnState\",\n          \"udfFlags\",\n          \"version\"\n        ];\n        if (wasm.bigIntEnabled) {\n          defineGroups.push(\"serialize\", \"session\", \"vtab\");\n        }\n        for (const t of defineGroups) {\n          for (const e of Object.entries(wasm.ctype[t])) {\n            capi[e[0]] = e[1];\n          }\n        }\n        if (!wasm.functionEntry(capi.SQLITE_WASM_DEALLOC)) {\n          toss(\n            \"Internal error: cannot resolve exported function\",\n            \"entry SQLITE_WASM_DEALLOC (==\" + capi.SQLITE_WASM_DEALLOC + \").\"\n          );\n        }\n        const __rcMap = /* @__PURE__ */ Object.create(null);\n        for (const t of [\"resultCodes\"]) {\n          for (const e of Object.entries(wasm.ctype[t])) {\n            __rcMap[e[1]] = e[0];\n          }\n        }\n        capi.sqlite3_js_rc_str = (rc) => __rcMap[rc];\n        const notThese = Object.assign(/* @__PURE__ */ Object.create(null), {\n          WasmTestStruct: true,\n          sqlite3_kvvfs_methods: !util.isUIThread(),\n          sqlite3_index_info: !wasm.bigIntEnabled,\n          sqlite3_index_constraint: !wasm.bigIntEnabled,\n          sqlite3_index_orderby: !wasm.bigIntEnabled,\n          sqlite3_index_constraint_usage: !wasm.bigIntEnabled\n        });\n        for (const s of wasm.ctype.structs) {\n          if (!notThese[s.name]) {\n            capi[s.name] = sqlite32.StructBinder(s);\n          }\n        }\n        if (capi.sqlite3_index_info) {\n          for (const k of [\n            \"sqlite3_index_constraint\",\n            \"sqlite3_index_orderby\",\n            \"sqlite3_index_constraint_usage\"\n          ]) {\n            capi.sqlite3_index_info[k] = capi[k];\n            delete capi[k];\n          }\n          capi.sqlite3_vtab_config = wasm.xWrap(\n            \"sqlite3__wasm_vtab_config\",\n            \"int\",\n            [\"sqlite3*\", \"int\", \"int\"]\n          );\n        }\n      }\n      const __dbArgcMismatch = (pDb2, f, n) => {\n        return util.sqlite3__wasm_db_error(\n          pDb2,\n          capi.SQLITE_MISUSE,\n          f + \"() requires \" + n + \" argument\" + (1 === n ? \"\" : \"s\") + \".\"\n        );\n      };\n      const __errEncoding = (pDb2) => {\n        return util.sqlite3__wasm_db_error(\n          pDb2,\n          capi.SQLITE_FORMAT,\n          \"SQLITE_UTF8 is the only supported encoding.\"\n        );\n      };\n      const __argPDb = (pDb2) => wasm.xWrap.argAdapter(\"sqlite3*\")(pDb2);\n      const __argStr = (str) => wasm.isPtr(str) ? wasm.cstrToJs(str) : str;\n      const __dbCleanupMap = function(pDb2, mode) {\n        pDb2 = __argPDb(pDb2);\n        let m = this.dbMap.get(pDb2);\n        if (!mode) {\n          this.dbMap.delete(pDb2);\n          return m;\n        } else if (!m && mode > 0) {\n          this.dbMap.set(pDb2, m = /* @__PURE__ */ Object.create(null));\n        }\n        return m;\n      }.bind(\n        Object.assign(/* @__PURE__ */ Object.create(null), {\n          dbMap: /* @__PURE__ */ new Map()\n        })\n      );\n      __dbCleanupMap.addCollation = function(pDb2, name) {\n        const m = __dbCleanupMap(pDb2, 1);\n        if (!m.collation) m.collation = /* @__PURE__ */ new Set();\n        m.collation.add(__argStr(name).toLowerCase());\n      };\n      __dbCleanupMap._addUDF = function(pDb2, name, arity, map) {\n        name = __argStr(name).toLowerCase();\n        let u = map.get(name);\n        if (!u) map.set(name, u = /* @__PURE__ */ new Set());\n        u.add(arity < 0 ? -1 : arity);\n      };\n      __dbCleanupMap.addFunction = function(pDb2, name, arity) {\n        const m = __dbCleanupMap(pDb2, 1);\n        if (!m.udf) m.udf = /* @__PURE__ */ new Map();\n        this._addUDF(pDb2, name, arity, m.udf);\n      };\n      if (wasm.exports.sqlite3_create_window_function) {\n        __dbCleanupMap.addWindowFunc = function(pDb2, name, arity) {\n          const m = __dbCleanupMap(pDb2, 1);\n          if (!m.wudf) m.wudf = /* @__PURE__ */ new Map();\n          this._addUDF(pDb2, name, arity, m.wudf);\n        };\n      }\n      __dbCleanupMap.cleanup = function(pDb2) {\n        pDb2 = __argPDb(pDb2);\n        for (const obj of [\n          [\"sqlite3_busy_handler\", 3],\n          [\"sqlite3_commit_hook\", 3],\n          [\"sqlite3_preupdate_hook\", 3],\n          [\"sqlite3_progress_handler\", 4],\n          [\"sqlite3_rollback_hook\", 3],\n          [\"sqlite3_set_authorizer\", 3],\n          [\"sqlite3_trace_v2\", 4],\n          [\"sqlite3_update_hook\", 3]\n        ]) {\n          const [name, arity] = obj;\n          const x = wasm.exports[name];\n          if (!x) {\n            continue;\n          }\n          const closeArgs = [pDb2];\n          closeArgs.length = arity;\n          try {\n            capi[name](...closeArgs);\n          } catch (e) {\n            sqlite32.config.warn(\n              \"close-time call of\",\n              name + \"(\",\n              closeArgs,\n              \") threw:\",\n              e\n            );\n          }\n        }\n        const m = __dbCleanupMap(pDb2, 0);\n        if (!m) return;\n        if (m.collation) {\n          for (const name of m.collation) {\n            try {\n              capi.sqlite3_create_collation_v2(\n                pDb2,\n                name,\n                capi.SQLITE_UTF8,\n                0,\n                0,\n                0\n              );\n            } catch (e) {\n            }\n          }\n          delete m.collation;\n        }\n        let i;\n        for (i = 0; i < 2; ++i) {\n          const fmap = i ? m.wudf : m.udf;\n          if (!fmap) continue;\n          const func = i ? capi.sqlite3_create_window_function : capi.sqlite3_create_function_v2;\n          for (const e of fmap) {\n            const name = e[0], arities = e[1];\n            const fargs = [pDb2, name, 0, capi.SQLITE_UTF8, 0, 0, 0, 0, 0];\n            if (i) fargs.push(0);\n            for (const arity of arities) {\n              try {\n                fargs[2] = arity;\n                func.apply(null, fargs);\n              } catch (e2) {\n              }\n            }\n            arities.clear();\n          }\n          fmap.clear();\n        }\n        delete m.udf;\n        delete m.wudf;\n      };\n      {\n        const __sqlite3CloseV2 = wasm.xWrap(\n          \"sqlite3_close_v2\",\n          \"int\",\n          \"sqlite3*\"\n        );\n        capi.sqlite3_close_v2 = function(pDb2) {\n          if (1 !== arguments.length)\n            return __dbArgcMismatch(pDb2, \"sqlite3_close_v2\", 1);\n          if (pDb2) {\n            try {\n              __dbCleanupMap.cleanup(pDb2);\n            } catch (e) {\n            }\n          }\n          return __sqlite3CloseV2(pDb2);\n        };\n      }\n      if (capi.sqlite3session_create) {\n        const __sqlite3SessionDelete = wasm.xWrap(\n          \"sqlite3session_delete\",\n          void 0,\n          [\"sqlite3_session*\"]\n        );\n        capi.sqlite3session_delete = function(pSession) {\n          if (1 !== arguments.length) {\n            return __dbArgcMismatch(pDb, \"sqlite3session_delete\", 1);\n          } else if (pSession) {\n            capi.sqlite3session_table_filter(pSession, 0, 0);\n          }\n          __sqlite3SessionDelete(pSession);\n        };\n      }\n      {\n        const contextKey = (argv, argIndex) => {\n          return \"argv[\" + argIndex + \"]:\" + argv[0] + \":\" + wasm.cstrToJs(argv[1]).toLowerCase();\n        };\n        const __sqlite3CreateCollationV2 = wasm.xWrap(\n          \"sqlite3_create_collation_v2\",\n          \"int\",\n          [\n            \"sqlite3*\",\n            \"string\",\n            \"int\",\n            \"*\",\n            new wasm.xWrap.FuncPtrAdapter({\n              name: \"xCompare\",\n              signature: \"i(pipip)\",\n              contextKey\n            }),\n            new wasm.xWrap.FuncPtrAdapter({\n              name: \"xDestroy\",\n              signature: \"v(p)\",\n              contextKey\n            })\n          ]\n        );\n        capi.sqlite3_create_collation_v2 = function(pDb2, zName, eTextRep, pArg, xCompare, xDestroy) {\n          if (6 !== arguments.length)\n            return __dbArgcMismatch(pDb2, \"sqlite3_create_collation_v2\", 6);\n          else if (0 === (eTextRep & 15)) {\n            eTextRep |= capi.SQLITE_UTF8;\n          } else if (capi.SQLITE_UTF8 !== (eTextRep & 15)) {\n            return __errEncoding(pDb2);\n          }\n          try {\n            const rc = __sqlite3CreateCollationV2(\n              pDb2,\n              zName,\n              eTextRep,\n              pArg,\n              xCompare,\n              xDestroy\n            );\n            if (0 === rc && xCompare instanceof Function) {\n              __dbCleanupMap.addCollation(pDb2, zName);\n            }\n            return rc;\n          } catch (e) {\n            return util.sqlite3__wasm_db_error(pDb2, e);\n          }\n        };\n        capi.sqlite3_create_collation = (pDb2, zName, eTextRep, pArg, xCompare) => {\n          return 5 === arguments.length ? capi.sqlite3_create_collation_v2(\n            pDb2,\n            zName,\n            eTextRep,\n            pArg,\n            xCompare,\n            0\n          ) : __dbArgcMismatch(pDb2, \"sqlite3_create_collation\", 5);\n        };\n      }\n      {\n        const contextKey = function(argv, argIndex) {\n          return argv[0] + \":\" + (argv[2] < 0 ? -1 : argv[2]) + \":\" + argIndex + \":\" + wasm.cstrToJs(argv[1]).toLowerCase();\n        };\n        const __cfProxy = Object.assign(/* @__PURE__ */ Object.create(null), {\n          xInverseAndStep: {\n            signature: \"v(pip)\",\n            contextKey,\n            callProxy: (callback) => {\n              return (pCtx, argc, pArgv) => {\n                try {\n                  callback(pCtx, ...capi.sqlite3_values_to_js(argc, pArgv));\n                } catch (e) {\n                  capi.sqlite3_result_error_js(pCtx, e);\n                }\n              };\n            }\n          },\n          xFinalAndValue: {\n            signature: \"v(p)\",\n            contextKey,\n            callProxy: (callback) => {\n              return (pCtx) => {\n                try {\n                  capi.sqlite3_result_js(pCtx, callback(pCtx));\n                } catch (e) {\n                  capi.sqlite3_result_error_js(pCtx, e);\n                }\n              };\n            }\n          },\n          xFunc: {\n            signature: \"v(pip)\",\n            contextKey,\n            callProxy: (callback) => {\n              return (pCtx, argc, pArgv) => {\n                try {\n                  capi.sqlite3_result_js(\n                    pCtx,\n                    callback(pCtx, ...capi.sqlite3_values_to_js(argc, pArgv))\n                  );\n                } catch (e) {\n                  capi.sqlite3_result_error_js(pCtx, e);\n                }\n              };\n            }\n          },\n          xDestroy: {\n            signature: \"v(p)\",\n            contextKey,\n            callProxy: (callback) => {\n              return (pVoid) => {\n                try {\n                  callback(pVoid);\n                } catch (e) {\n                  console.error(\"UDF xDestroy method threw:\", e);\n                }\n              };\n            }\n          }\n        });\n        const __sqlite3CreateFunction = wasm.xWrap(\n          \"sqlite3_create_function_v2\",\n          \"int\",\n          [\n            \"sqlite3*\",\n            \"string\",\n            \"int\",\n            \"int\",\n            \"*\",\n            new wasm.xWrap.FuncPtrAdapter({\n              name: \"xFunc\",\n              ...__cfProxy.xFunc\n            }),\n            new wasm.xWrap.FuncPtrAdapter({\n              name: \"xStep\",\n              ...__cfProxy.xInverseAndStep\n            }),\n            new wasm.xWrap.FuncPtrAdapter({\n              name: \"xFinal\",\n              ...__cfProxy.xFinalAndValue\n            }),\n            new wasm.xWrap.FuncPtrAdapter({\n              name: \"xDestroy\",\n              ...__cfProxy.xDestroy\n            })\n          ]\n        );\n        const __sqlite3CreateWindowFunction = wasm.exports.sqlite3_create_window_function ? wasm.xWrap(\"sqlite3_create_window_function\", \"int\", [\n          \"sqlite3*\",\n          \"string\",\n          \"int\",\n          \"int\",\n          \"*\",\n          new wasm.xWrap.FuncPtrAdapter({\n            name: \"xStep\",\n            ...__cfProxy.xInverseAndStep\n          }),\n          new wasm.xWrap.FuncPtrAdapter({\n            name: \"xFinal\",\n            ...__cfProxy.xFinalAndValue\n          }),\n          new wasm.xWrap.FuncPtrAdapter({\n            name: \"xValue\",\n            ...__cfProxy.xFinalAndValue\n          }),\n          new wasm.xWrap.FuncPtrAdapter({\n            name: \"xInverse\",\n            ...__cfProxy.xInverseAndStep\n          }),\n          new wasm.xWrap.FuncPtrAdapter({\n            name: \"xDestroy\",\n            ...__cfProxy.xDestroy\n          })\n        ]) : void 0;\n        capi.sqlite3_create_function_v2 = function f(pDb2, funcName, nArg, eTextRep, pApp, xFunc, xStep, xFinal, xDestroy) {\n          if (f.length !== arguments.length) {\n            return __dbArgcMismatch(\n              pDb2,\n              \"sqlite3_create_function_v2\",\n              f.length\n            );\n          } else if (0 === (eTextRep & 15)) {\n            eTextRep |= capi.SQLITE_UTF8;\n          } else if (capi.SQLITE_UTF8 !== (eTextRep & 15)) {\n            return __errEncoding(pDb2);\n          }\n          try {\n            const rc = __sqlite3CreateFunction(\n              pDb2,\n              funcName,\n              nArg,\n              eTextRep,\n              pApp,\n              xFunc,\n              xStep,\n              xFinal,\n              xDestroy\n            );\n            if (0 === rc && (xFunc instanceof Function || xStep instanceof Function || xFinal instanceof Function || xDestroy instanceof Function)) {\n              __dbCleanupMap.addFunction(pDb2, funcName, nArg);\n            }\n            return rc;\n          } catch (e) {\n            console.error(\"sqlite3_create_function_v2() setup threw:\", e);\n            return util.sqlite3__wasm_db_error(\n              pDb2,\n              e,\n              \"Creation of UDF threw: \" + e\n            );\n          }\n        };\n        capi.sqlite3_create_function = function f(pDb2, funcName, nArg, eTextRep, pApp, xFunc, xStep, xFinal) {\n          return f.length === arguments.length ? capi.sqlite3_create_function_v2(\n            pDb2,\n            funcName,\n            nArg,\n            eTextRep,\n            pApp,\n            xFunc,\n            xStep,\n            xFinal,\n            0\n          ) : __dbArgcMismatch(pDb2, \"sqlite3_create_function\", f.length);\n        };\n        if (__sqlite3CreateWindowFunction) {\n          capi.sqlite3_create_window_function = function f(pDb2, funcName, nArg, eTextRep, pApp, xStep, xFinal, xValue, xInverse, xDestroy) {\n            if (f.length !== arguments.length) {\n              return __dbArgcMismatch(\n                pDb2,\n                \"sqlite3_create_window_function\",\n                f.length\n              );\n            } else if (0 === (eTextRep & 15)) {\n              eTextRep |= capi.SQLITE_UTF8;\n            } else if (capi.SQLITE_UTF8 !== (eTextRep & 15)) {\n              return __errEncoding(pDb2);\n            }\n            try {\n              const rc = __sqlite3CreateWindowFunction(\n                pDb2,\n                funcName,\n                nArg,\n                eTextRep,\n                pApp,\n                xStep,\n                xFinal,\n                xValue,\n                xInverse,\n                xDestroy\n              );\n              if (0 === rc && (xStep instanceof Function || xFinal instanceof Function || xValue instanceof Function || xInverse instanceof Function || xDestroy instanceof Function)) {\n                __dbCleanupMap.addWindowFunc(pDb2, funcName, nArg);\n              }\n              return rc;\n            } catch (e) {\n              console.error(\"sqlite3_create_window_function() setup threw:\", e);\n              return util.sqlite3__wasm_db_error(\n                pDb2,\n                e,\n                \"Creation of UDF threw: \" + e\n              );\n            }\n          };\n        } else {\n          delete capi.sqlite3_create_window_function;\n        }\n        capi.sqlite3_create_function_v2.udfSetResult = capi.sqlite3_create_function.udfSetResult = capi.sqlite3_result_js;\n        if (capi.sqlite3_create_window_function) {\n          capi.sqlite3_create_window_function.udfSetResult = capi.sqlite3_result_js;\n        }\n        capi.sqlite3_create_function_v2.udfConvertArgs = capi.sqlite3_create_function.udfConvertArgs = capi.sqlite3_values_to_js;\n        if (capi.sqlite3_create_window_function) {\n          capi.sqlite3_create_window_function.udfConvertArgs = capi.sqlite3_values_to_js;\n        }\n        capi.sqlite3_create_function_v2.udfSetError = capi.sqlite3_create_function.udfSetError = capi.sqlite3_result_error_js;\n        if (capi.sqlite3_create_window_function) {\n          capi.sqlite3_create_window_function.udfSetError = capi.sqlite3_result_error_js;\n        }\n      }\n      {\n        const __flexiString = (v2, n) => {\n          if (\"string\" === typeof v2) {\n            n = -1;\n          } else if (util.isSQLableTypedArray(v2)) {\n            n = v2.byteLength;\n            v2 = wasm.typedArrayToString(\n              v2 instanceof ArrayBuffer ? new Uint8Array(v2) : v2\n            );\n          } else if (Array.isArray(v2)) {\n            v2 = v2.join(\"\");\n            n = -1;\n          }\n          return [v2, n];\n        };\n        const __prepare = {\n          basic: wasm.xWrap(\"sqlite3_prepare_v3\", \"int\", [\n            \"sqlite3*\",\n            \"string\",\n            \"int\",\n            \"int\",\n            \"**\",\n            \"**\"\n          ]),\n          full: wasm.xWrap(\"sqlite3_prepare_v3\", \"int\", [\n            \"sqlite3*\",\n            \"*\",\n            \"int\",\n            \"int\",\n            \"**\",\n            \"**\"\n          ])\n        };\n        capi.sqlite3_prepare_v3 = function f(pDb2, sql, sqlLen, prepFlags, ppStmt, pzTail) {\n          if (f.length !== arguments.length) {\n            return __dbArgcMismatch(pDb2, \"sqlite3_prepare_v3\", f.length);\n          }\n          const [xSql, xSqlLen] = __flexiString(sql, Number(sqlLen));\n          switch (typeof xSql) {\n            case \"string\":\n              return __prepare.basic(\n                pDb2,\n                xSql,\n                xSqlLen,\n                prepFlags,\n                ppStmt,\n                null\n              );\n            case typeof wasm.ptr.null:\n              return __prepare.full(\n                pDb2,\n                wasm.ptr.coerce(xSql),\n                xSqlLen,\n                prepFlags,\n                ppStmt,\n                pzTail\n              );\n            default:\n              return util.sqlite3__wasm_db_error(\n                pDb2,\n                capi.SQLITE_MISUSE,\n                \"Invalid SQL argument type for sqlite3_prepare_v2/v3(). typeof=\" + typeof xSql\n              );\n          }\n        };\n        capi.sqlite3_prepare_v2 = function f(pDb2, sql, sqlLen, ppStmt, pzTail) {\n          return f.length === arguments.length ? capi.sqlite3_prepare_v3(pDb2, sql, sqlLen, 0, ppStmt, pzTail) : __dbArgcMismatch(pDb2, \"sqlite3_prepare_v2\", f.length);\n        };\n      }\n      {\n        const __bindText = wasm.xWrap(\"sqlite3_bind_text\", \"int\", [\n          \"sqlite3_stmt*\",\n          \"int\",\n          \"string\",\n          \"int\",\n          \"*\"\n        ]);\n        const __bindBlob = wasm.xWrap(\"sqlite3_bind_blob\", \"int\", [\n          \"sqlite3_stmt*\",\n          \"int\",\n          \"*\",\n          \"int\",\n          \"*\"\n        ]);\n        capi.sqlite3_bind_text = function f(pStmt, iCol, text, nText, xDestroy) {\n          if (f.length !== arguments.length) {\n            return __dbArgcMismatch(\n              capi.sqlite3_db_handle(pStmt),\n              \"sqlite3_bind_text\",\n              f.length\n            );\n          } else if (wasm.isPtr(text) || null === text) {\n            return __bindText(pStmt, iCol, text, nText, xDestroy);\n          } else if (text instanceof ArrayBuffer) {\n            text = new Uint8Array(text);\n          } else if (Array.isArray(pMem)) {\n            text = pMem.join(\"\");\n          }\n          let p, n;\n          try {\n            if (util.isSQLableTypedArray(text)) {\n              p = wasm.allocFromTypedArray(text);\n              n = text.byteLength;\n            } else if (\"string\" === typeof text) {\n              [p, n] = wasm.allocCString(text);\n            } else {\n              return util.sqlite3__wasm_db_error(\n                capi.sqlite3_db_handle(pStmt),\n                capi.SQLITE_MISUSE,\n                \"Invalid 3rd argument type for sqlite3_bind_text().\"\n              );\n            }\n            return __bindText(pStmt, iCol, p, n, capi.SQLITE_WASM_DEALLOC);\n          } catch (e) {\n            wasm.dealloc(p);\n            return util.sqlite3__wasm_db_error(\n              capi.sqlite3_db_handle(pStmt),\n              e\n            );\n          }\n        };\n        capi.sqlite3_bind_blob = function f(pStmt, iCol, pMem2, nMem, xDestroy) {\n          if (f.length !== arguments.length) {\n            return __dbArgcMismatch(\n              capi.sqlite3_db_handle(pStmt),\n              \"sqlite3_bind_blob\",\n              f.length\n            );\n          } else if (wasm.isPtr(pMem2) || null === pMem2) {\n            return __bindBlob(pStmt, iCol, pMem2, nMem, xDestroy);\n          } else if (pMem2 instanceof ArrayBuffer) {\n            pMem2 = new Uint8Array(pMem2);\n          } else if (Array.isArray(pMem2)) {\n            pMem2 = pMem2.join(\"\");\n          }\n          let p, n;\n          try {\n            if (util.isBindableTypedArray(pMem2)) {\n              p = wasm.allocFromTypedArray(pMem2);\n              n = nMem >= 0 ? nMem : pMem2.byteLength;\n            } else if (\"string\" === typeof pMem2) {\n              [p, n] = wasm.allocCString(pMem2);\n            } else {\n              return util.sqlite3__wasm_db_error(\n                capi.sqlite3_db_handle(pStmt),\n                capi.SQLITE_MISUSE,\n                \"Invalid 3rd argument type for sqlite3_bind_blob().\"\n              );\n            }\n            return __bindBlob(pStmt, iCol, p, n, capi.SQLITE_WASM_DEALLOC);\n          } catch (e) {\n            wasm.dealloc(p);\n            return util.sqlite3__wasm_db_error(\n              capi.sqlite3_db_handle(pStmt),\n              e\n            );\n          }\n        };\n      }\n      {\n        capi.sqlite3_config = function(op, ...args) {\n          if (arguments.length < 2) return capi.SQLITE_MISUSE;\n          switch (op) {\n            case capi.SQLITE_CONFIG_COVERING_INDEX_SCAN:\n            case capi.SQLITE_CONFIG_MEMSTATUS:\n            case capi.SQLITE_CONFIG_SMALL_MALLOC:\n            case capi.SQLITE_CONFIG_SORTERREF_SIZE:\n            case capi.SQLITE_CONFIG_STMTJRNL_SPILL:\n            case capi.SQLITE_CONFIG_URI:\n              return wasm.exports.sqlite3__wasm_config_i(op, args[0]);\n            case capi.SQLITE_CONFIG_LOOKASIDE:\n              return wasm.exports.sqlite3__wasm_config_ii(op, args[0], args[1]);\n            case capi.SQLITE_CONFIG_MEMDB_MAXSIZE:\n              return wasm.exports.sqlite3__wasm_config_j(op, args[0]);\n            case capi.SQLITE_CONFIG_GETMALLOC:\n            case capi.SQLITE_CONFIG_GETMUTEX:\n            case capi.SQLITE_CONFIG_GETPCACHE2:\n            case capi.SQLITE_CONFIG_GETPCACHE:\n            case capi.SQLITE_CONFIG_HEAP:\n            case capi.SQLITE_CONFIG_LOG:\n            case capi.SQLITE_CONFIG_MALLOC:\n            case capi.SQLITE_CONFIG_MMAP_SIZE:\n            case capi.SQLITE_CONFIG_MULTITHREAD:\n            case capi.SQLITE_CONFIG_MUTEX:\n            case capi.SQLITE_CONFIG_PAGECACHE:\n            case capi.SQLITE_CONFIG_PCACHE2:\n            case capi.SQLITE_CONFIG_PCACHE:\n            case capi.SQLITE_CONFIG_PCACHE_HDRSZ:\n            case capi.SQLITE_CONFIG_PMASZ:\n            case capi.SQLITE_CONFIG_SERIALIZED:\n            case capi.SQLITE_CONFIG_SINGLETHREAD:\n            case capi.SQLITE_CONFIG_SQLLOG:\n            case capi.SQLITE_CONFIG_WIN32_HEAPSIZE:\n            default:\n              return capi.SQLITE_NOTFOUND;\n          }\n        };\n      }\n      {\n        const __autoExtFptr = /* @__PURE__ */ new Set();\n        capi.sqlite3_auto_extension = function(fPtr) {\n          if (fPtr instanceof Function) {\n            fPtr = wasm.installFunction(\"i(ppp)\", fPtr);\n          } else if (1 !== arguments.length || !wasm.isPtr(fPtr)) {\n            return capi.SQLITE_MISUSE;\n          }\n          const rc = wasm.exports.sqlite3_auto_extension(fPtr);\n          if (fPtr !== arguments[0]) {\n            if (0 === rc) __autoExtFptr.add(fPtr);\n            else wasm.uninstallFunction(fPtr);\n          }\n          return rc;\n        };\n        capi.sqlite3_cancel_auto_extension = function(fPtr) {\n          if (!fPtr || 1 !== arguments.length || !wasm.isPtr(fPtr)) return 0;\n          return wasm.exports.sqlite3_cancel_auto_extension(fPtr);\n        };\n        capi.sqlite3_reset_auto_extension = function() {\n          wasm.exports.sqlite3_reset_auto_extension();\n          for (const fp of __autoExtFptr) wasm.uninstallFunction(fp);\n          __autoExtFptr.clear();\n        };\n      }\n      const pKvvfs = capi.sqlite3_vfs_find(\"kvvfs\");\n      if (pKvvfs) {\n        if (util.isUIThread()) {\n          const kvvfsMethods = new capi.sqlite3_kvvfs_methods(\n            wasm.exports.sqlite3__wasm_kvvfs_methods()\n          );\n          delete capi.sqlite3_kvvfs_methods;\n          const kvvfsMakeKey = wasm.exports.sqlite3__wasm_kvvfsMakeKeyOnPstack, pstack = wasm.pstack;\n          const kvvfsStorage = (zClass) => 115 === wasm.peek(zClass) ? sessionStorage : localStorage;\n          const kvvfsImpls = {\n            xRead: (zClass, zKey, zBuf, nBuf) => {\n              const stack = pstack.pointer, astack = wasm.scopedAllocPush();\n              try {\n                const zXKey = kvvfsMakeKey(zClass, zKey);\n                if (!zXKey) return -3;\n                const jKey = wasm.cstrToJs(zXKey);\n                const jV = kvvfsStorage(zClass).getItem(jKey);\n                if (!jV) return -1;\n                const nV = jV.length;\n                if (nBuf <= 0) return nV;\n                else if (1 === nBuf) {\n                  wasm.poke(zBuf, 0);\n                  return nV;\n                }\n                const zV = wasm.scopedAllocCString(jV);\n                if (nBuf > nV + 1) nBuf = nV + 1;\n                wasm.heap8u().copyWithin(\n                  Number(zBuf),\n                  Number(zV),\n                  wasm.ptr.addn(zV, nBuf, -1)\n                );\n                wasm.poke(wasm.ptr.add(zBuf, nBuf, -1), 0);\n                return nBuf - 1;\n              } catch (e) {\n                sqlite32.config.error(\"kvstorageRead()\", e);\n                return -2;\n              } finally {\n                pstack.restore(stack);\n                wasm.scopedAllocPop(astack);\n              }\n            },\n            xWrite: (zClass, zKey, zData) => {\n              const stack = pstack.pointer;\n              try {\n                const zXKey = kvvfsMakeKey(zClass, zKey);\n                if (!zXKey) return 1;\n                const jKey = wasm.cstrToJs(zXKey);\n                kvvfsStorage(zClass).setItem(jKey, wasm.cstrToJs(zData));\n                return 0;\n              } catch (e) {\n                sqlite32.config.error(\"kvstorageWrite()\", e);\n                return capi.SQLITE_IOERR;\n              } finally {\n                pstack.restore(stack);\n              }\n            },\n            xDelete: (zClass, zKey) => {\n              const stack = pstack.pointer;\n              try {\n                const zXKey = kvvfsMakeKey(zClass, zKey);\n                if (!zXKey) return 1;\n                kvvfsStorage(zClass).removeItem(wasm.cstrToJs(zXKey));\n                return 0;\n              } catch (e) {\n                sqlite32.config.error(\"kvstorageDelete()\", e);\n                return capi.SQLITE_IOERR;\n              } finally {\n                pstack.restore(stack);\n              }\n            }\n          };\n          for (const k of Object.keys(kvvfsImpls)) {\n            kvvfsMethods[kvvfsMethods.memberKey(k)] = wasm.installFunction(\n              kvvfsMethods.memberSignature(k),\n              kvvfsImpls[k]\n            );\n          }\n        } else {\n          capi.sqlite3_vfs_unregister(pKvvfs);\n        }\n      }\n      wasm.xWrap.FuncPtrAdapter.warnOnUse = true;\n      const StructBinder = sqlite32.StructBinder;\n      const installMethod = function callee3(tgt, name, func, applyArgcCheck = callee3.installMethodArgcCheck) {\n        if (!(tgt instanceof StructBinder.StructType)) {\n          toss(\"Usage error: target object is-not-a StructType.\");\n        } else if (!(func instanceof Function) && !wasm.isPtr(func)) {\n          toss(\"Usage error: expecting a Function or WASM pointer to one.\");\n        }\n        if (1 === arguments.length) {\n          return (n, f) => callee3(tgt, n, f, applyArgcCheck);\n        }\n        if (!callee3.argcProxy) {\n          callee3.argcProxy = function(tgt2, funcName, func2, sig) {\n            return function(...args) {\n              if (func2.length !== arguments.length) {\n                toss(\n                  \"Argument mismatch for\",\n                  tgt2.structInfo.name + \"::\" + funcName + \": Native signature is:\",\n                  sig\n                );\n              }\n              return func2.apply(this, args);\n            };\n          };\n          callee3.removeFuncList = function() {\n            if (this.ondispose.__removeFuncList) {\n              this.ondispose.__removeFuncList.forEach((v2, ndx) => {\n                if (wasm.isPtr(v2)) {\n                  try {\n                    wasm.uninstallFunction(v2);\n                  } catch (e) {\n                  }\n                }\n              });\n              delete this.ondispose.__removeFuncList;\n            }\n          };\n        }\n        const sigN = tgt.memberSignature(name);\n        if (sigN.length < 2) {\n          toss(\n            \"Member\",\n            name,\n            \"does not have a function pointer signature:\",\n            sigN\n          );\n        }\n        const memKey = tgt.memberKey(name);\n        const fProxy = applyArgcCheck && !wasm.isPtr(func) ? callee3.argcProxy(tgt, memKey, func, sigN) : func;\n        if (wasm.isPtr(fProxy)) {\n          if (fProxy && !wasm.functionEntry(fProxy)) {\n            toss(\"Pointer\", fProxy, \"is not a WASM function table entry.\");\n          }\n          tgt[memKey] = fProxy;\n        } else {\n          const pFunc = wasm.installFunction(fProxy, tgt.memberSignature(name));\n          tgt[memKey] = pFunc;\n          if (!tgt.ondispose || !tgt.ondispose.__removeFuncList) {\n            tgt.addOnDispose(\n              \"ondispose.__removeFuncList handler\",\n              callee3.removeFuncList\n            );\n            tgt.ondispose.__removeFuncList = [];\n          }\n          tgt.ondispose.__removeFuncList.push(memKey, pFunc);\n        }\n        return (n, f) => callee3(tgt, n, f, applyArgcCheck);\n      };\n      installMethod.installMethodArgcCheck = false;\n      const installMethods = function(structInstance, methods, applyArgcCheck = installMethod.installMethodArgcCheck) {\n        const seen = /* @__PURE__ */ new Map();\n        for (const k of Object.keys(methods)) {\n          const m = methods[k];\n          const prior = seen.get(m);\n          if (prior) {\n            const mkey = structInstance.memberKey(k);\n            structInstance[mkey] = structInstance[structInstance.memberKey(prior)];\n          } else {\n            installMethod(structInstance, k, m, applyArgcCheck);\n            seen.set(m, k);\n          }\n        }\n        return structInstance;\n      };\n      StructBinder.StructType.prototype.installMethod = function callee3(name, func, applyArgcCheck = installMethod.installMethodArgcCheck) {\n        return arguments.length < 3 && name && \"object\" === typeof name ? installMethods(this, ...arguments) : installMethod(this, ...arguments);\n      };\n      StructBinder.StructType.prototype.installMethods = function(methods, applyArgcCheck = installMethod.installMethodArgcCheck) {\n        return installMethods(this, methods, applyArgcCheck);\n      };\n    });\n    globalThis.sqlite3ApiBootstrap.initializers.push(function(sqlite32) {\n      sqlite32.version = {\n        libVersion: \"3.51.1\",\n        libVersionNumber: 3051001,\n        sourceId: \"2025-11-28 17:28:25 281fc0e9afc38674b9b0991943b9e9d1e64c6cbdb133d35f6f5c87ff6af38a88\",\n        downloadVersion: 3510100,\n        scm: {\n          \"sha3-256\": \"281fc0e9afc38674b9b0991943b9e9d1e64c6cbdb133d35f6f5c87ff6af38a88\",\n          branch: \"branch-3.51\",\n          tags: \"release version-3.51.1\",\n          datetime: \"2025-11-28T17:28:25.933Z\"\n        }\n      };\n    });\n    globalThis.sqlite3ApiBootstrap.initializers.push(function(sqlite32) {\n      const toss3 = (...args) => {\n        throw new sqlite32.SQLite3Error(...args);\n      };\n      const capi = sqlite32.capi, wasm = sqlite32.wasm, util = sqlite32.util;\n      const __ptrMap = /* @__PURE__ */ new WeakMap();\n      const __doesNotOwnHandle = /* @__PURE__ */ new Set();\n      const __stmtMap = /* @__PURE__ */ new WeakMap();\n      const getOwnOption = (opts, p, dflt) => {\n        const d = Object.getOwnPropertyDescriptor(opts, p);\n        return d ? d.value : dflt;\n      };\n      const checkSqlite3Rc = function(dbPtr, sqliteResultCode) {\n        if (sqliteResultCode) {\n          if (dbPtr instanceof DB) dbPtr = dbPtr.pointer;\n          toss3(\n            sqliteResultCode,\n            \"sqlite3 result code\",\n            sqliteResultCode + \":\",\n            dbPtr ? capi.sqlite3_errmsg(dbPtr) : capi.sqlite3_errstr(sqliteResultCode)\n          );\n        }\n        return arguments[0];\n      };\n      const __dbTraceToConsole = wasm.installFunction(\n        \"i(ippp)\",\n        function(t, c, p, x) {\n          if (capi.SQLITE_TRACE_STMT === t) {\n            console.log(\n              \"SQL TRACE #\" + ++this.counter + \" via sqlite3@\" + c + \":\",\n              wasm.cstrToJs(x)\n            );\n          }\n        }.bind({ counter: 0 })\n      );\n      const __vfsPostOpenCallback = /* @__PURE__ */ Object.create(null);\n      const dbCtorHelper = function ctor(...args) {\n        if (!ctor._name2vfs) {\n          ctor._name2vfs = /* @__PURE__ */ Object.create(null);\n          const isWorkerThread = \"function\" === typeof importScripts ? (n) => toss3(\n            \"The VFS for\",\n            n,\n            \"is only available in the main window thread.\"\n          ) : false;\n          ctor._name2vfs[\":localStorage:\"] = {\n            vfs: \"kvvfs\",\n            filename: isWorkerThread || (() => \"local\")\n          };\n          ctor._name2vfs[\":sessionStorage:\"] = {\n            vfs: \"kvvfs\",\n            filename: isWorkerThread || (() => \"session\")\n          };\n        }\n        const opt = ctor.normalizeArgs(...args);\n        let pDb2;\n        if (pDb2 = opt[\"sqlite3*\"]) {\n          if (!opt[\"sqlite3*:takeOwnership\"]) {\n            __doesNotOwnHandle.add(this);\n          }\n          this.filename = capi.sqlite3_db_filename(pDb2, \"main\");\n        } else {\n          let fn = opt.filename, vfsName = opt.vfs, flagsStr = opt.flags;\n          if (\"string\" !== typeof fn && !wasm.isPtr(fn) || \"string\" !== typeof flagsStr || vfsName && \"string\" !== typeof vfsName && !wasm.isPtr(vfsName)) {\n            sqlite32.config.error(\"Invalid DB ctor args\", opt, arguments);\n            toss3(\n              \"Invalid arguments for DB constructor:\",\n              arguments,\n              \"opts:\",\n              opt\n            );\n          }\n          let fnJs = wasm.isPtr(fn) ? wasm.cstrToJs(fn) : fn;\n          const vfsCheck = ctor._name2vfs[fnJs];\n          if (vfsCheck) {\n            vfsName = vfsCheck.vfs;\n            fn = fnJs = vfsCheck.filename(fnJs);\n          }\n          let oflags = 0;\n          if (flagsStr.indexOf(\"c\") >= 0) {\n            oflags |= capi.SQLITE_OPEN_CREATE | capi.SQLITE_OPEN_READWRITE;\n          }\n          if (flagsStr.indexOf(\"w\") >= 0) oflags |= capi.SQLITE_OPEN_READWRITE;\n          if (0 === oflags) oflags |= capi.SQLITE_OPEN_READONLY;\n          oflags |= capi.SQLITE_OPEN_EXRESCODE;\n          const stack = wasm.pstack.pointer;\n          try {\n            const pPtr = wasm.pstack.allocPtr();\n            let rc = capi.sqlite3_open_v2(\n              fn,\n              pPtr,\n              oflags,\n              vfsName || wasm.ptr.null\n            );\n            pDb2 = wasm.peekPtr(pPtr);\n            checkSqlite3Rc(pDb2, rc);\n            capi.sqlite3_extended_result_codes(pDb2, 1);\n            if (flagsStr.indexOf(\"t\") >= 0) {\n              capi.sqlite3_trace_v2(\n                pDb2,\n                capi.SQLITE_TRACE_STMT,\n                __dbTraceToConsole,\n                pDb2\n              );\n            }\n          } catch (e) {\n            if (pDb2) capi.sqlite3_close_v2(pDb2);\n            throw e;\n          } finally {\n            wasm.pstack.restore(stack);\n          }\n          this.filename = fnJs;\n        }\n        __ptrMap.set(this, pDb2);\n        __stmtMap.set(this, /* @__PURE__ */ Object.create(null));\n        if (!opt[\"sqlite3*\"]) {\n          try {\n            const pVfs = capi.sqlite3_js_db_vfs(pDb2) || toss3(\"Internal error: cannot get VFS for new db handle.\");\n            const postInitSql = __vfsPostOpenCallback[pVfs];\n            if (postInitSql) {\n              if (postInitSql instanceof Function) {\n                postInitSql(this, sqlite32);\n              } else {\n                checkSqlite3Rc(\n                  pDb2,\n                  capi.sqlite3_exec(pDb2, postInitSql, 0, 0, 0)\n                );\n              }\n            }\n          } catch (e) {\n            this.close();\n            throw e;\n          }\n        }\n      };\n      dbCtorHelper.setVfsPostOpenCallback = function(pVfs, callback) {\n        if (!(callback instanceof Function)) {\n          toss3(\n            \"dbCtorHelper.setVfsPostOpenCallback() should not be used with a non-function argument.\",\n            arguments\n          );\n        }\n        __vfsPostOpenCallback[pVfs] = callback;\n      };\n      dbCtorHelper.normalizeArgs = function(filename = \":memory:\", flags = \"c\", vfs = null) {\n        const arg = {};\n        if (1 === arguments.length && arguments[0] && \"object\" === typeof arguments[0]) {\n          Object.assign(arg, arguments[0]);\n          if (void 0 === arg.flags) arg.flags = \"c\";\n          if (void 0 === arg.vfs) arg.vfs = null;\n          if (void 0 === arg.filename) arg.filename = \":memory:\";\n        } else {\n          arg.filename = filename;\n          arg.flags = flags;\n          arg.vfs = vfs;\n        }\n        return arg;\n      };\n      const DB = function(...args) {\n        dbCtorHelper.apply(this, args);\n      };\n      DB.dbCtorHelper = dbCtorHelper;\n      const BindTypes = {\n        null: 1,\n        number: 2,\n        string: 3,\n        boolean: 4,\n        blob: 5\n      };\n      if (wasm.bigIntEnabled) {\n        BindTypes.bigint = BindTypes.number;\n      }\n      const Stmt = function() {\n        if (BindTypes !== arguments[2]) {\n          toss3(\n            capi.SQLITE_MISUSE,\n            \"Do not call the Stmt constructor directly. Use DB.prepare().\"\n          );\n        }\n        this.db = arguments[0];\n        __ptrMap.set(this, arguments[1]);\n        if (arguments.length > 3 && !arguments[3]) {\n          __doesNotOwnHandle.add(this);\n        }\n      };\n      const affirmDbOpen = function(db) {\n        if (!db.pointer) toss3(\"DB has been closed.\");\n        return db;\n      };\n      const affirmColIndex = function(stmt, ndx) {\n        if (ndx !== (ndx | 0) || ndx < 0 || ndx >= stmt.columnCount) {\n          toss3(\"Column index\", ndx, \"is out of range.\");\n        }\n        return stmt;\n      };\n      const parseExecArgs = function(db, args) {\n        const out2 = /* @__PURE__ */ Object.create(null);\n        out2.opt = /* @__PURE__ */ Object.create(null);\n        switch (args.length) {\n          case 1:\n            if (\"string\" === typeof args[0] || util.isSQLableTypedArray(args[0])) {\n              out2.sql = args[0];\n            } else if (Array.isArray(args[0])) {\n              out2.sql = args[0];\n            } else if (args[0] && \"object\" === typeof args[0]) {\n              out2.opt = args[0];\n              out2.sql = out2.opt.sql;\n            }\n            break;\n          case 2:\n            out2.sql = args[0];\n            out2.opt = args[1];\n            break;\n          default:\n            toss3(\"Invalid argument count for exec().\");\n        }\n        out2.sql = util.flexibleString(out2.sql);\n        if (\"string\" !== typeof out2.sql) {\n          toss3(\"Missing SQL argument or unsupported SQL value type.\");\n        }\n        const opt = out2.opt;\n        switch (opt.returnValue) {\n          case \"resultRows\":\n            if (!opt.resultRows) opt.resultRows = [];\n            out2.returnVal = () => opt.resultRows;\n            break;\n          case \"saveSql\":\n            if (!opt.saveSql) opt.saveSql = [];\n            out2.returnVal = () => opt.saveSql;\n            break;\n          case void 0:\n          case \"this\":\n            out2.returnVal = () => db;\n            break;\n          default:\n            toss3(\"Invalid returnValue value:\", opt.returnValue);\n        }\n        if (!opt.callback && !opt.returnValue && void 0 !== opt.rowMode) {\n          if (!opt.resultRows) opt.resultRows = [];\n          out2.returnVal = () => opt.resultRows;\n        }\n        if (opt.callback || opt.resultRows) {\n          switch (void 0 === opt.rowMode ? \"array\" : opt.rowMode) {\n            case \"object\":\n              out2.cbArg = (stmt, cache) => {\n                if (!cache.columnNames)\n                  cache.columnNames = stmt.getColumnNames([]);\n                const row = stmt.get([]);\n                const rv = /* @__PURE__ */ Object.create(null);\n                for (const i in cache.columnNames)\n                  rv[cache.columnNames[i]] = row[i];\n                return rv;\n              };\n              break;\n            case \"array\":\n              out2.cbArg = (stmt) => stmt.get([]);\n              break;\n            case \"stmt\":\n              if (Array.isArray(opt.resultRows)) {\n                toss3(\n                  \"exec(): invalid rowMode for a resultRows array: must\",\n                  \"be one of 'array', 'object',\",\n                  \"a result column number, or column name reference.\"\n                );\n              }\n              out2.cbArg = (stmt) => stmt;\n              break;\n            default:\n              if (util.isInt32(opt.rowMode)) {\n                out2.cbArg = (stmt) => stmt.get(opt.rowMode);\n                break;\n              } else if (\"string\" === typeof opt.rowMode && opt.rowMode.length > 1 && \"$\" === opt.rowMode[0]) {\n                const $colName = opt.rowMode.substr(1);\n                out2.cbArg = (stmt) => {\n                  const rc = stmt.get(/* @__PURE__ */ Object.create(null))[$colName];\n                  return void 0 === rc ? toss3(\n                    capi.SQLITE_NOTFOUND,\n                    \"exec(): unknown result column:\",\n                    $colName\n                  ) : rc;\n                };\n                break;\n              }\n              toss3(\"Invalid rowMode:\", opt.rowMode);\n          }\n        }\n        return out2;\n      };\n      const __selectFirstRow = (db, sql, bind, ...getArgs) => {\n        const stmt = db.prepare(sql);\n        try {\n          const rc = stmt.bind(bind).step() ? stmt.get(...getArgs) : void 0;\n          stmt.reset();\n          return rc;\n        } finally {\n          stmt.finalize();\n        }\n      };\n      const __selectAll = (db, sql, bind, rowMode) => db.exec({\n        sql,\n        bind,\n        rowMode,\n        returnValue: \"resultRows\"\n      });\n      DB.checkRc = (db, resultCode) => checkSqlite3Rc(db, resultCode);\n      DB.prototype = {\n        isOpen: function() {\n          return !!this.pointer;\n        },\n        affirmOpen: function() {\n          return affirmDbOpen(this);\n        },\n        close: function() {\n          const pDb2 = this.pointer;\n          if (pDb2) {\n            if (this.onclose && this.onclose.before instanceof Function) {\n              try {\n                this.onclose.before(this);\n              } catch (e) {\n              }\n            }\n            Object.keys(__stmtMap.get(this)).forEach((k, s) => {\n              if (s && s.pointer) {\n                try {\n                  s.finalize();\n                } catch (e) {\n                }\n              }\n            });\n            __ptrMap.delete(this);\n            __stmtMap.delete(this);\n            if (!__doesNotOwnHandle.delete(this)) {\n              capi.sqlite3_close_v2(pDb2);\n            }\n            if (this.onclose && this.onclose.after instanceof Function) {\n              try {\n                this.onclose.after(this);\n              } catch (e) {\n              }\n            }\n            delete this.filename;\n          }\n        },\n        changes: function(total = false, sixtyFour = false) {\n          const p = affirmDbOpen(this).pointer;\n          if (total) {\n            return sixtyFour ? capi.sqlite3_total_changes64(p) : capi.sqlite3_total_changes(p);\n          } else {\n            return sixtyFour ? capi.sqlite3_changes64(p) : capi.sqlite3_changes(p);\n          }\n        },\n        dbFilename: function(dbName = \"main\") {\n          return capi.sqlite3_db_filename(affirmDbOpen(this).pointer, dbName);\n        },\n        dbName: function(dbNumber = 0) {\n          return capi.sqlite3_db_name(affirmDbOpen(this).pointer, dbNumber);\n        },\n        dbVfsName: function(dbName = 0) {\n          let rc;\n          const pVfs = capi.sqlite3_js_db_vfs(\n            affirmDbOpen(this).pointer,\n            dbName\n          );\n          if (pVfs) {\n            const v2 = new capi.sqlite3_vfs(pVfs);\n            try {\n              rc = wasm.cstrToJs(v2.$zName);\n            } finally {\n              v2.dispose();\n            }\n          }\n          return rc;\n        },\n        prepare: function(sql) {\n          affirmDbOpen(this);\n          const stack = wasm.pstack.pointer;\n          let ppStmt, pStmt;\n          try {\n            ppStmt = wasm.pstack.alloc(8);\n            DB.checkRc(\n              this,\n              capi.sqlite3_prepare_v2(this.pointer, sql, -1, ppStmt, null)\n            );\n            pStmt = wasm.peekPtr(ppStmt);\n          } finally {\n            wasm.pstack.restore(stack);\n          }\n          if (!pStmt) toss3(\"Cannot prepare empty SQL.\");\n          const stmt = new Stmt(this, pStmt, BindTypes);\n          __stmtMap.get(this)[pStmt] = stmt;\n          return stmt;\n        },\n        exec: function() {\n          affirmDbOpen(this);\n          const arg = parseExecArgs(this, arguments);\n          if (!arg.sql) {\n            return toss3(\"exec() requires an SQL string.\");\n          }\n          const opt = arg.opt;\n          const callback = opt.callback;\n          const resultRows = Array.isArray(opt.resultRows) ? opt.resultRows : void 0;\n          let stmt;\n          let bind = opt.bind;\n          let evalFirstResult = !!(arg.cbArg || opt.columnNames || resultRows);\n          const stack = wasm.scopedAllocPush();\n          const saveSql = Array.isArray(opt.saveSql) ? opt.saveSql : void 0;\n          try {\n            const isTA = util.isSQLableTypedArray(arg.sql);\n            let sqlByteLen = isTA ? arg.sql.byteLength : wasm.jstrlen(arg.sql);\n            const ppStmt = wasm.scopedAlloc(\n              2 * wasm.ptr.size + (sqlByteLen + 1)\n            );\n            const pzTail = wasm.ptr.add(ppStmt, wasm.ptr.size);\n            let pSql = wasm.ptr.add(pzTail, wasm.ptr.size);\n            const pSqlEnd = wasm.ptr.add(pSql, sqlByteLen);\n            if (isTA) wasm.heap8().set(arg.sql, pSql);\n            else wasm.jstrcpy(arg.sql, wasm.heap8(), pSql, sqlByteLen, false);\n            wasm.poke(wasm.ptr.add(pSql, sqlByteLen), 0);\n            while (pSql && wasm.peek(pSql, \"i8\")) {\n              wasm.pokePtr([ppStmt, pzTail], 0);\n              DB.checkRc(\n                this,\n                capi.sqlite3_prepare_v3(\n                  this.pointer,\n                  pSql,\n                  sqlByteLen,\n                  0,\n                  ppStmt,\n                  pzTail\n                )\n              );\n              const pStmt = wasm.peekPtr(ppStmt);\n              pSql = wasm.peekPtr(pzTail);\n              sqlByteLen = Number(wasm.ptr.add(pSqlEnd, -pSql));\n              if (!pStmt) continue;\n              if (saveSql) saveSql.push(capi.sqlite3_sql(pStmt).trim());\n              stmt = new Stmt(this, pStmt, BindTypes);\n              if (bind && stmt.parameterCount) {\n                stmt.bind(bind);\n                bind = null;\n              }\n              if (evalFirstResult && stmt.columnCount) {\n                let gotColNames = Array.isArray(opt.columnNames) ? 0 : 1;\n                evalFirstResult = false;\n                if (arg.cbArg || resultRows) {\n                  const cbArgCache = /* @__PURE__ */ Object.create(null);\n                  for (; stmt.step(); __execLock.delete(stmt)) {\n                    if (0 === gotColNames++) {\n                      stmt.getColumnNames(\n                        cbArgCache.columnNames = opt.columnNames || []\n                      );\n                    }\n                    __execLock.add(stmt);\n                    const row = arg.cbArg(stmt, cbArgCache);\n                    if (resultRows) resultRows.push(row);\n                    if (callback && false === callback.call(opt, row, stmt)) {\n                      break;\n                    }\n                  }\n                  __execLock.delete(stmt);\n                }\n                if (0 === gotColNames) {\n                  stmt.getColumnNames(opt.columnNames);\n                }\n              } else {\n                stmt.step();\n              }\n              stmt.reset().finalize();\n              stmt = null;\n            }\n          } finally {\n            wasm.scopedAllocPop(stack);\n            if (stmt) {\n              __execLock.delete(stmt);\n              stmt.finalize();\n            }\n          }\n          return arg.returnVal();\n        },\n        createFunction: function f(name, xFunc, opt) {\n          const isFunc = (f2) => f2 instanceof Function;\n          switch (arguments.length) {\n            case 1:\n              opt = name;\n              name = opt.name;\n              xFunc = opt.xFunc || 0;\n              break;\n            case 2:\n              if (!isFunc(xFunc)) {\n                opt = xFunc;\n                xFunc = opt.xFunc || 0;\n              }\n              break;\n            case 3:\n              break;\n            default:\n              break;\n          }\n          if (!opt) opt = {};\n          if (\"string\" !== typeof name) {\n            toss3(\"Invalid arguments: missing function name.\");\n          }\n          let xStep = opt.xStep || 0;\n          let xFinal = opt.xFinal || 0;\n          const xValue = opt.xValue || 0;\n          const xInverse = opt.xInverse || 0;\n          let isWindow = void 0;\n          if (isFunc(xFunc)) {\n            isWindow = false;\n            if (isFunc(xStep) || isFunc(xFinal)) {\n              toss3(\"Ambiguous arguments: scalar or aggregate?\");\n            }\n            xStep = xFinal = null;\n          } else if (isFunc(xStep)) {\n            if (!isFunc(xFinal)) {\n              toss3(\"Missing xFinal() callback for aggregate or window UDF.\");\n            }\n            xFunc = null;\n          } else if (isFunc(xFinal)) {\n            toss3(\"Missing xStep() callback for aggregate or window UDF.\");\n          } else {\n            toss3(\"Missing function-type properties.\");\n          }\n          if (false === isWindow) {\n            if (isFunc(xValue) || isFunc(xInverse)) {\n              toss3(\n                \"xValue and xInverse are not permitted for non-window UDFs.\"\n              );\n            }\n          } else if (isFunc(xValue)) {\n            if (!isFunc(xInverse)) {\n              toss3(\"xInverse must be provided if xValue is.\");\n            }\n            isWindow = true;\n          } else if (isFunc(xInverse)) {\n            toss3(\"xValue must be provided if xInverse is.\");\n          }\n          const pApp = opt.pApp;\n          if (void 0 !== pApp && null !== pApp && !wasm.isPtr(pApp)) {\n            toss3(\n              \"Invalid value for pApp property. Must be a legal WASM pointer value.\"\n            );\n          }\n          const xDestroy = opt.xDestroy || 0;\n          if (xDestroy && !isFunc(xDestroy)) {\n            toss3(\"xDestroy property must be a function.\");\n          }\n          let fFlags = 0;\n          if (getOwnOption(opt, \"deterministic\"))\n            fFlags |= capi.SQLITE_DETERMINISTIC;\n          if (getOwnOption(opt, \"directOnly\")) fFlags |= capi.SQLITE_DIRECTONLY;\n          if (getOwnOption(opt, \"innocuous\")) fFlags |= capi.SQLITE_INNOCUOUS;\n          name = name.toLowerCase();\n          const xArity = xFunc || xStep;\n          const arity = getOwnOption(opt, \"arity\");\n          const arityArg = \"number\" === typeof arity ? arity : xArity.length ? xArity.length - 1 : 0;\n          let rc;\n          if (isWindow) {\n            rc = capi.sqlite3_create_window_function(\n              this.pointer,\n              name,\n              arityArg,\n              capi.SQLITE_UTF8 | fFlags,\n              pApp || 0,\n              xStep,\n              xFinal,\n              xValue,\n              xInverse,\n              xDestroy\n            );\n          } else {\n            rc = capi.sqlite3_create_function_v2(\n              this.pointer,\n              name,\n              arityArg,\n              capi.SQLITE_UTF8 | fFlags,\n              pApp || 0,\n              xFunc,\n              xStep,\n              xFinal,\n              xDestroy\n            );\n          }\n          DB.checkRc(this, rc);\n          return this;\n        },\n        selectValue: function(sql, bind, asType) {\n          return __selectFirstRow(this, sql, bind, 0, asType);\n        },\n        selectValues: function(sql, bind, asType) {\n          const stmt = this.prepare(sql), rc = [];\n          try {\n            stmt.bind(bind);\n            while (stmt.step()) rc.push(stmt.get(0, asType));\n            stmt.reset();\n          } finally {\n            stmt.finalize();\n          }\n          return rc;\n        },\n        selectArray: function(sql, bind) {\n          return __selectFirstRow(this, sql, bind, []);\n        },\n        selectObject: function(sql, bind) {\n          return __selectFirstRow(this, sql, bind, {});\n        },\n        selectArrays: function(sql, bind) {\n          return __selectAll(this, sql, bind, \"array\");\n        },\n        selectObjects: function(sql, bind) {\n          return __selectAll(this, sql, bind, \"object\");\n        },\n        openStatementCount: function() {\n          return this.pointer ? Object.keys(__stmtMap.get(this)).length : 0;\n        },\n        transaction: function(callback) {\n          let opener = \"BEGIN\";\n          if (arguments.length > 1) {\n            if (/[^a-zA-Z]/.test(arguments[0])) {\n              toss3(\n                capi.SQLITE_MISUSE,\n                \"Invalid argument for BEGIN qualifier.\"\n              );\n            }\n            opener += \" \" + arguments[0];\n            callback = arguments[1];\n          }\n          affirmDbOpen(this).exec(opener);\n          try {\n            const rc = callback(this);\n            this.exec(\"COMMIT\");\n            return rc;\n          } catch (e) {\n            this.exec(\"ROLLBACK\");\n            throw e;\n          }\n        },\n        savepoint: function(callback) {\n          affirmDbOpen(this).exec(\"SAVEPOINT oo1\");\n          try {\n            const rc = callback(this);\n            this.exec(\"RELEASE oo1\");\n            return rc;\n          } catch (e) {\n            this.exec(\"ROLLBACK to SAVEPOINT oo1; RELEASE SAVEPOINT oo1\");\n            throw e;\n          }\n        },\n        checkRc: function(resultCode) {\n          return checkSqlite3Rc(this, resultCode);\n        }\n      };\n      DB.wrapHandle = function(pDb2, takeOwnership = false) {\n        if (!pDb2 || !wasm.isPtr(pDb2)) {\n          throw new sqlite32.SQLite3Error(\n            capi.SQLITE_MISUSE,\n            \"Argument must be a WASM sqlite3 pointer\"\n          );\n        }\n        return new DB({\n          \"sqlite3*\": pDb2,\n          \"sqlite3*:takeOwnership\": !!takeOwnership\n        });\n      };\n      const affirmStmtOpen = function(stmt) {\n        if (!stmt.pointer) toss3(\"Stmt has been closed.\");\n        return stmt;\n      };\n      const isSupportedBindType = function(v2) {\n        let t = BindTypes[null === v2 || void 0 === v2 ? \"null\" : typeof v2];\n        switch (t) {\n          case BindTypes.boolean:\n          case BindTypes.null:\n          case BindTypes.number:\n          case BindTypes.string:\n            return t;\n          case BindTypes.bigint:\n            return wasm.bigIntEnabled ? t : void 0;\n          default:\n            return util.isBindableTypedArray(v2) ? BindTypes.blob : void 0;\n        }\n      };\n      const affirmSupportedBindType = function(v2) {\n        return isSupportedBindType(v2) || toss3(\"Unsupported bind() argument type:\", typeof v2);\n      };\n      const affirmParamIndex = function(stmt, key) {\n        const n = \"number\" === typeof key ? key : capi.sqlite3_bind_parameter_index(stmt.pointer, key);\n        if (0 === n || !util.isInt32(n))\n          toss3(\"Invalid bind() parameter name: \" + key);\n        else if (n < 1 || n > stmt.parameterCount)\n          toss3(\"Bind index\", key, \"is out of range.\");\n        return n;\n      };\n      const __execLock = /* @__PURE__ */ new Set();\n      const __stmtMayGet = /* @__PURE__ */ new Set();\n      const affirmNotLockedByExec = function(stmt, currentOpName) {\n        if (__execLock.has(stmt)) {\n          toss3(\n            \"Operation is illegal when statement is locked:\",\n            currentOpName\n          );\n        }\n        return stmt;\n      };\n      const bindOne = function f(stmt, ndx, bindType, val) {\n        affirmNotLockedByExec(affirmStmtOpen(stmt), \"bind()\");\n        if (!f._) {\n          f._tooBigInt = (v2) => toss3(\n            \"BigInt value is too big to store without precision loss:\",\n            v2\n          );\n          f._ = {\n            string: function(stmt2, ndx2, val2, asBlob) {\n              const [pStr, n] = wasm.allocCString(val2, true);\n              const f2 = asBlob ? capi.sqlite3_bind_blob : capi.sqlite3_bind_text;\n              return f2(stmt2.pointer, ndx2, pStr, n, capi.SQLITE_WASM_DEALLOC);\n            }\n          };\n        }\n        affirmSupportedBindType(val);\n        ndx = affirmParamIndex(stmt, ndx);\n        let rc = 0;\n        switch (null === val || void 0 === val ? BindTypes.null : bindType) {\n          case BindTypes.null:\n            rc = capi.sqlite3_bind_null(stmt.pointer, ndx);\n            break;\n          case BindTypes.string:\n            rc = f._.string(stmt, ndx, val, false);\n            break;\n          case BindTypes.number: {\n            let m;\n            if (util.isInt32(val)) m = capi.sqlite3_bind_int;\n            else if (\"bigint\" === typeof val) {\n              if (!util.bigIntFits64(val)) {\n                f._tooBigInt(val);\n              } else if (wasm.bigIntEnabled) {\n                m = capi.sqlite3_bind_int64;\n              } else if (util.bigIntFitsDouble(val)) {\n                val = Number(val);\n                m = capi.sqlite3_bind_double;\n              } else {\n                f._tooBigInt(val);\n              }\n            } else {\n              val = Number(val);\n              if (wasm.bigIntEnabled && Number.isInteger(val)) {\n                m = capi.sqlite3_bind_int64;\n              } else {\n                m = capi.sqlite3_bind_double;\n              }\n            }\n            rc = m(stmt.pointer, ndx, val);\n            break;\n          }\n          case BindTypes.boolean:\n            rc = capi.sqlite3_bind_int(stmt.pointer, ndx, val ? 1 : 0);\n            break;\n          case BindTypes.blob: {\n            if (\"string\" === typeof val) {\n              rc = f._.string(stmt, ndx, val, true);\n              break;\n            } else if (val instanceof ArrayBuffer) {\n              val = new Uint8Array(val);\n            } else if (!util.isBindableTypedArray(val)) {\n              toss3(\n                \"Binding a value as a blob requires\",\n                \"that it be a string, Uint8Array, Int8Array, or ArrayBuffer.\"\n              );\n            }\n            const pBlob = wasm.alloc(val.byteLength || 1);\n            wasm.heap8().set(val.byteLength ? val : [0], Number(pBlob));\n            rc = capi.sqlite3_bind_blob(\n              stmt.pointer,\n              ndx,\n              pBlob,\n              val.byteLength,\n              capi.SQLITE_WASM_DEALLOC\n            );\n            break;\n          }\n          default:\n            sqlite32.config.warn(\"Unsupported bind() argument type:\", val);\n            toss3(\"Unsupported bind() argument type: \" + typeof val);\n        }\n        if (rc) DB.checkRc(stmt.db.pointer, rc);\n        return stmt;\n      };\n      Stmt.prototype = {\n        finalize: function() {\n          const ptr = this.pointer;\n          if (ptr) {\n            affirmNotLockedByExec(this, \"finalize()\");\n            const rc = __doesNotOwnHandle.delete(this) ? 0 : capi.sqlite3_finalize(ptr);\n            delete __stmtMap.get(this.db)[ptr];\n            __ptrMap.delete(this);\n            __execLock.delete(this);\n            __stmtMayGet.delete(this);\n            delete this.parameterCount;\n            delete this.db;\n            return rc;\n          }\n        },\n        clearBindings: function() {\n          affirmNotLockedByExec(affirmStmtOpen(this), \"clearBindings()\");\n          capi.sqlite3_clear_bindings(this.pointer);\n          __stmtMayGet.delete(this);\n          return this;\n        },\n        reset: function(alsoClearBinds) {\n          affirmNotLockedByExec(this, \"reset()\");\n          if (alsoClearBinds) this.clearBindings();\n          const rc = capi.sqlite3_reset(affirmStmtOpen(this).pointer);\n          __stmtMayGet.delete(this);\n          checkSqlite3Rc(this.db, rc);\n          return this;\n        },\n        bind: function() {\n          affirmStmtOpen(this);\n          let ndx, arg;\n          switch (arguments.length) {\n            case 1:\n              ndx = 1;\n              arg = arguments[0];\n              break;\n            case 2:\n              ndx = arguments[0];\n              arg = arguments[1];\n              break;\n            default:\n              toss3(\"Invalid bind() arguments.\");\n          }\n          if (void 0 === arg) {\n            return this;\n          } else if (!this.parameterCount) {\n            toss3(\"This statement has no bindable parameters.\");\n          }\n          __stmtMayGet.delete(this);\n          if (null === arg) {\n            return bindOne(this, ndx, BindTypes.null, arg);\n          } else if (Array.isArray(arg)) {\n            if (1 !== arguments.length) {\n              toss3(\n                \"When binding an array, an index argument is not permitted.\"\n              );\n            }\n            arg.forEach(\n              (v2, i) => bindOne(this, i + 1, affirmSupportedBindType(v2), v2)\n            );\n            return this;\n          } else if (arg instanceof ArrayBuffer) {\n            arg = new Uint8Array(arg);\n          }\n          if (\"object\" === typeof arg && !util.isBindableTypedArray(arg)) {\n            if (1 !== arguments.length) {\n              toss3(\n                \"When binding an object, an index argument is not permitted.\"\n              );\n            }\n            Object.keys(arg).forEach(\n              (k) => bindOne(this, k, affirmSupportedBindType(arg[k]), arg[k])\n            );\n            return this;\n          } else {\n            return bindOne(this, ndx, affirmSupportedBindType(arg), arg);\n          }\n          toss3(\"Should not reach this point.\");\n        },\n        bindAsBlob: function(ndx, arg) {\n          affirmStmtOpen(this);\n          if (1 === arguments.length) {\n            arg = ndx;\n            ndx = 1;\n          }\n          const t = affirmSupportedBindType(arg);\n          if (BindTypes.string !== t && BindTypes.blob !== t && BindTypes.null !== t) {\n            toss3(\"Invalid value type for bindAsBlob()\");\n          }\n          return bindOne(this, ndx, BindTypes.blob, arg);\n        },\n        step: function() {\n          affirmNotLockedByExec(this, \"step()\");\n          const rc = capi.sqlite3_step(affirmStmtOpen(this).pointer);\n          switch (rc) {\n            case capi.SQLITE_DONE:\n              __stmtMayGet.delete(this);\n              return false;\n            case capi.SQLITE_ROW:\n              __stmtMayGet.add(this);\n              return true;\n            default:\n              __stmtMayGet.delete(this);\n              sqlite32.config.warn(\n                \"sqlite3_step() rc=\",\n                rc,\n                capi.sqlite3_js_rc_str(rc),\n                \"SQL =\",\n                capi.sqlite3_sql(this.pointer)\n              );\n              DB.checkRc(this.db.pointer, rc);\n          }\n        },\n        stepReset: function() {\n          this.step();\n          return this.reset();\n        },\n        stepFinalize: function() {\n          try {\n            const rc = this.step();\n            this.reset();\n            return rc;\n          } finally {\n            try {\n              this.finalize();\n            } catch (e) {\n            }\n          }\n        },\n        get: function(ndx, asType) {\n          if (!__stmtMayGet.has(affirmStmtOpen(this))) {\n            toss3(\"Stmt.step() has not (recently) returned true.\");\n          }\n          if (Array.isArray(ndx)) {\n            let i = 0;\n            const n = this.columnCount;\n            while (i < n) {\n              ndx[i] = this.get(i++);\n            }\n            return ndx;\n          } else if (ndx && \"object\" === typeof ndx) {\n            let i = 0;\n            const n = this.columnCount;\n            while (i < n) {\n              ndx[capi.sqlite3_column_name(this.pointer, i)] = this.get(i++);\n            }\n            return ndx;\n          }\n          affirmColIndex(this, ndx);\n          switch (void 0 === asType ? capi.sqlite3_column_type(this.pointer, ndx) : asType) {\n            case capi.SQLITE_NULL:\n              return null;\n            case capi.SQLITE_INTEGER: {\n              if (wasm.bigIntEnabled) {\n                const rc = capi.sqlite3_column_int64(this.pointer, ndx);\n                if (rc >= Number.MIN_SAFE_INTEGER && rc <= Number.MAX_SAFE_INTEGER) {\n                  return Number(rc).valueOf();\n                }\n                return rc;\n              } else {\n                const rc = capi.sqlite3_column_double(this.pointer, ndx);\n                if (rc > Number.MAX_SAFE_INTEGER || rc < Number.MIN_SAFE_INTEGER) {\n                  toss3(\"Integer is out of range for JS integer range: \" + rc);\n                }\n                return util.isInt32(rc) ? rc | 0 : rc;\n              }\n            }\n            case capi.SQLITE_FLOAT:\n              return capi.sqlite3_column_double(this.pointer, ndx);\n            case capi.SQLITE_TEXT:\n              return capi.sqlite3_column_text(this.pointer, ndx);\n            case capi.SQLITE_BLOB: {\n              const n = capi.sqlite3_column_bytes(this.pointer, ndx), ptr = capi.sqlite3_column_blob(this.pointer, ndx), rc = new Uint8Array(n);\n              if (n) {\n                rc.set(wasm.heap8u().slice(Number(ptr), Number(ptr) + n), 0);\n                if (this.db._blobXfer instanceof Array) {\n                  this.db._blobXfer.push(rc.buffer);\n                }\n              }\n              return rc;\n            }\n            default:\n              toss3(\n                \"Don't know how to translate\",\n                \"type of result column #\" + ndx + \".\"\n              );\n          }\n          toss3(\"Not reached.\");\n        },\n        getInt: function(ndx) {\n          return this.get(ndx, capi.SQLITE_INTEGER);\n        },\n        getFloat: function(ndx) {\n          return this.get(ndx, capi.SQLITE_FLOAT);\n        },\n        getString: function(ndx) {\n          return this.get(ndx, capi.SQLITE_TEXT);\n        },\n        getBlob: function(ndx) {\n          return this.get(ndx, capi.SQLITE_BLOB);\n        },\n        getJSON: function(ndx) {\n          const s = this.get(ndx, capi.SQLITE_STRING);\n          return null === s ? s : JSON.parse(s);\n        },\n        getColumnName: function(ndx) {\n          return capi.sqlite3_column_name(\n            affirmColIndex(affirmStmtOpen(this), ndx).pointer,\n            ndx\n          );\n        },\n        getColumnNames: function(tgt = []) {\n          affirmColIndex(affirmStmtOpen(this), 0);\n          const n = this.columnCount;\n          for (let i = 0; i < n; ++i) {\n            tgt.push(capi.sqlite3_column_name(this.pointer, i));\n          }\n          return tgt;\n        },\n        getParamIndex: function(name) {\n          return affirmStmtOpen(this).parameterCount ? capi.sqlite3_bind_parameter_index(this.pointer, name) : void 0;\n        },\n        getParamName: function(ndx) {\n          return affirmStmtOpen(this).parameterCount ? capi.sqlite3_bind_parameter_name(this.pointer, ndx) : void 0;\n        },\n        isBusy: function() {\n          return 0 !== capi.sqlite3_stmt_busy(affirmStmtOpen(this));\n        },\n        isReadOnly: function() {\n          return 0 !== capi.sqlite3_stmt_readonly(affirmStmtOpen(this));\n        }\n      };\n      {\n        const prop = {\n          enumerable: true,\n          get: function() {\n            return __ptrMap.get(this);\n          },\n          set: () => toss3(\"The pointer property is read-only.\")\n        };\n        Object.defineProperty(Stmt.prototype, \"pointer\", prop);\n        Object.defineProperty(DB.prototype, \"pointer\", prop);\n      }\n      Object.defineProperty(Stmt.prototype, \"columnCount\", {\n        enumerable: false,\n        get: function() {\n          return capi.sqlite3_column_count(this.pointer);\n        },\n        set: () => toss3(\"The columnCount property is read-only.\")\n      });\n      Object.defineProperty(Stmt.prototype, \"parameterCount\", {\n        enumerable: false,\n        get: function() {\n          return capi.sqlite3_bind_parameter_count(this.pointer);\n        },\n        set: () => toss3(\"The parameterCount property is read-only.\")\n      });\n      Stmt.wrapHandle = function(oo1db, pStmt, takeOwnership = false) {\n        let ctor = Stmt;\n        if (!(oo1db instanceof DB) || !oo1db.pointer) {\n          throw new sqlite32.SQLite3Error(\n            sqlite32.SQLITE_MISUSE,\n            \"First argument must be an opened sqlite3.oo1.DB instance\"\n          );\n        }\n        if (!pStmt || !wasm.isPtr(pStmt)) {\n          throw new sqlite32.SQLite3Error(\n            sqlite32.SQLITE_MISUSE,\n            \"Second argument must be a WASM sqlite3_stmt pointer\"\n          );\n        }\n        return new Stmt(oo1db, pStmt, BindTypes, !!takeOwnership);\n      };\n      sqlite32.oo1 = {\n        DB,\n        Stmt\n      };\n      if (util.isUIThread()) {\n        sqlite32.oo1.JsStorageDb = function(storageName = \"session\") {\n          const opt = dbCtorHelper.normalizeArgs(...arguments);\n          storageName = opt.filename;\n          if (\"session\" !== storageName && \"local\" !== storageName) {\n            toss3(\"JsStorageDb db name must be one of 'session' or 'local'.\");\n          }\n          opt.vfs = \"kvvfs\";\n          dbCtorHelper.call(this, opt);\n        };\n        const jdb = sqlite32.oo1.JsStorageDb;\n        jdb.prototype = Object.create(DB.prototype);\n        jdb.clearStorage = capi.sqlite3_js_kvvfs_clear;\n        jdb.prototype.clearStorage = function() {\n          return jdb.clearStorage(affirmDbOpen(this).filename);\n        };\n        jdb.storageSize = capi.sqlite3_js_kvvfs_size;\n        jdb.prototype.storageSize = function() {\n          return jdb.storageSize(affirmDbOpen(this).filename);\n        };\n      }\n    });\n    globalThis.sqlite3ApiBootstrap.initializers.push(function(sqlite32) {\n      const util = sqlite32.util;\n      sqlite32.initWorker1API = function() {\n        \"use strict\";\n        const toss = (...args) => {\n          throw new Error(args.join(\" \"));\n        };\n        if (!(globalThis.WorkerGlobalScope instanceof Function)) {\n          toss(\"initWorker1API() must be run from a Worker thread.\");\n        }\n        const sqlite33 = this.sqlite3 || toss(\"Missing this.sqlite3 object.\");\n        const DB = sqlite33.oo1.DB;\n        const getDbId = function(db) {\n          let id = wState.idMap.get(db);\n          if (id) return id;\n          id = \"db#\" + ++wState.idSeq + \":\" + Math.floor(Math.random() * 1e8) + \":\" + Math.floor(Math.random() * 1e8);\n          wState.idMap.set(db, id);\n          return id;\n        };\n        const wState = {\n          dbList: [],\n          idSeq: 0,\n          idMap: /* @__PURE__ */ new WeakMap(),\n          xfer: [],\n          open: function(opt) {\n            const db = new DB(opt);\n            this.dbs[getDbId(db)] = db;\n            if (this.dbList.indexOf(db) < 0) this.dbList.push(db);\n            return db;\n          },\n          close: function(db, alsoUnlink) {\n            if (db) {\n              delete this.dbs[getDbId(db)];\n              const filename = db.filename;\n              const pVfs = util.sqlite3__wasm_db_vfs(db.pointer, 0);\n              db.close();\n              const ddNdx = this.dbList.indexOf(db);\n              if (ddNdx >= 0) this.dbList.splice(ddNdx, 1);\n              if (alsoUnlink && filename && pVfs) {\n                util.sqlite3__wasm_vfs_unlink(pVfs, filename);\n              }\n            }\n          },\n          post: function(msg, xferList) {\n            if (xferList && xferList.length) {\n              globalThis.postMessage(msg, Array.from(xferList));\n              xferList.length = 0;\n            } else {\n              globalThis.postMessage(msg);\n            }\n          },\n          dbs: /* @__PURE__ */ Object.create(null),\n          getDb: function(id, require2 = true) {\n            return this.dbs[id] || (require2 ? toss(\"Unknown (or closed) DB ID:\", id) : void 0);\n          }\n        };\n        const affirmDbOpen = function(db = wState.dbList[0]) {\n          return db && db.pointer ? db : toss(\"DB is not opened.\");\n        };\n        const getMsgDb = function(msgData, affirmExists = true) {\n          const db = wState.getDb(msgData.dbId, false) || wState.dbList[0];\n          return affirmExists ? affirmDbOpen(db) : db;\n        };\n        const getDefaultDbId = function() {\n          return wState.dbList[0] && getDbId(wState.dbList[0]);\n        };\n        const isSpecialDbFilename = (n) => {\n          return \"\" === n || \":\" === n[0];\n        };\n        const wMsgHandler = {\n          open: function(ev) {\n            const oargs = /* @__PURE__ */ Object.create(null), args = ev.args || /* @__PURE__ */ Object.create(null);\n            if (args.simulateError) {\n              toss(\"Throwing because of simulateError flag.\");\n            }\n            const rc = /* @__PURE__ */ Object.create(null);\n            oargs.vfs = args.vfs;\n            oargs.filename = args.filename || \"\";\n            const db = wState.open(oargs);\n            rc.filename = db.filename;\n            rc.persistent = !!sqlite33.capi.sqlite3_js_db_uses_vfs(\n              db.pointer,\n              \"opfs\"\n            );\n            rc.dbId = getDbId(db);\n            rc.vfs = db.dbVfsName();\n            return rc;\n          },\n          close: function(ev) {\n            const db = getMsgDb(ev, false);\n            const response = {\n              filename: db && db.filename\n            };\n            if (db) {\n              const doUnlink = ev.args && \"object\" === typeof ev.args ? !!ev.args.unlink : false;\n              wState.close(db, doUnlink);\n            }\n            return response;\n          },\n          exec: function(ev) {\n            const rc = \"string\" === typeof ev.args ? { sql: ev.args } : ev.args || /* @__PURE__ */ Object.create(null);\n            if (\"stmt\" === rc.rowMode) {\n              toss(\n                \"Invalid rowMode for 'exec': stmt mode\",\n                \"does not work in the Worker API.\"\n              );\n            } else if (!rc.sql) {\n              toss(\"'exec' requires input SQL.\");\n            }\n            const db = getMsgDb(ev);\n            if (rc.callback || Array.isArray(rc.resultRows)) {\n              db._blobXfer = wState.xfer;\n            }\n            const theCallback = rc.callback;\n            let rowNumber = 0;\n            const hadColNames = !!rc.columnNames;\n            if (\"string\" === typeof theCallback) {\n              if (!hadColNames) rc.columnNames = [];\n              rc.callback = function(row, stmt) {\n                wState.post(\n                  {\n                    type: theCallback,\n                    columnNames: rc.columnNames,\n                    rowNumber: ++rowNumber,\n                    row\n                  },\n                  wState.xfer\n                );\n              };\n            }\n            try {\n              const changeCount = !!rc.countChanges ? db.changes(true, 64 === rc.countChanges) : void 0;\n              db.exec(rc);\n              if (void 0 !== changeCount) {\n                rc.changeCount = db.changes(true, 64 === rc.countChanges) - changeCount;\n              }\n              const lastInsertRowId = !!rc.lastInsertRowId ? sqlite33.capi.sqlite3_last_insert_rowid(db) : void 0;\n              if (void 0 !== lastInsertRowId) {\n                rc.lastInsertRowId = lastInsertRowId;\n              }\n              if (rc.callback instanceof Function) {\n                rc.callback = theCallback;\n                wState.post({\n                  type: theCallback,\n                  columnNames: rc.columnNames,\n                  rowNumber: null,\n                  row: void 0\n                });\n              }\n            } finally {\n              delete db._blobXfer;\n              if (rc.callback) rc.callback = theCallback;\n            }\n            return rc;\n          },\n          \"config-get\": function() {\n            const rc = /* @__PURE__ */ Object.create(null), src = sqlite33.config;\n            [\"bigIntEnabled\"].forEach(function(k) {\n              if (Object.getOwnPropertyDescriptor(src, k)) rc[k] = src[k];\n            });\n            rc.version = sqlite33.version;\n            rc.vfsList = sqlite33.capi.sqlite3_js_vfs_list();\n            return rc;\n          },\n          export: function(ev) {\n            const db = getMsgDb(ev);\n            const response = {\n              byteArray: sqlite33.capi.sqlite3_js_db_export(db.pointer),\n              filename: db.filename,\n              mimetype: \"application/x-sqlite3\"\n            };\n            wState.xfer.push(response.byteArray.buffer);\n            return response;\n          },\n          toss: function(ev) {\n            toss(\"Testing worker exception\");\n          }\n        };\n        globalThis.onmessage = async function(ev) {\n          ev = ev.data;\n          let result, dbId = ev.dbId, evType = ev.type;\n          const arrivalTime = performance.now();\n          try {\n            if (wMsgHandler.hasOwnProperty(evType) && wMsgHandler[evType] instanceof Function) {\n              result = await wMsgHandler[evType](ev);\n            } else {\n              toss(\"Unknown db worker message type:\", ev.type);\n            }\n          } catch (err2) {\n            evType = \"error\";\n            result = {\n              operation: ev.type,\n              message: err2.message,\n              errorClass: err2.name,\n              input: ev\n            };\n            if (err2.stack) {\n              result.stack = \"string\" === typeof err2.stack ? err2.stack.split(/\\n\\s*/) : err2.stack;\n            }\n            if (0)\n              sqlite33.config.warn(\n                \"Worker is propagating an exception to main thread.\",\n                \"Reporting it _here_ for the stack trace:\",\n                err2,\n                result\n              );\n          }\n          if (!dbId) {\n            dbId = result.dbId || getDefaultDbId();\n          }\n          wState.post(\n            {\n              type: evType,\n              dbId,\n              messageId: ev.messageId,\n              workerReceivedTime: arrivalTime,\n              workerRespondTime: performance.now(),\n              departureTime: ev.departureTime,\n              result\n            },\n            wState.xfer\n          );\n        };\n        globalThis.postMessage({\n          type: \"sqlite3-api\",\n          result: \"worker1-ready\"\n        });\n      }.bind({ sqlite3: sqlite32 });\n    });\n    \"use strict\";\n    globalThis.sqlite3ApiBootstrap.initializers.push(function(sqlite32) {\n      const wasm = sqlite32.wasm, capi = sqlite32.capi, toss = sqlite32.util.toss3;\n      const vfs = /* @__PURE__ */ Object.create(null);\n      sqlite32.vfs = vfs;\n      capi.sqlite3_vfs.prototype.registerVfs = function(asDefault = false) {\n        if (!(this instanceof sqlite32.capi.sqlite3_vfs)) {\n          toss(\"Expecting a sqlite3_vfs-type argument.\");\n        }\n        const rc = capi.sqlite3_vfs_register(this, asDefault ? 1 : 0);\n        if (rc) {\n          toss(\"sqlite3_vfs_register(\", this, \") failed with rc\", rc);\n        }\n        if (this.pointer !== capi.sqlite3_vfs_find(this.$zName)) {\n          toss(\n            \"BUG: sqlite3_vfs_find(vfs.$zName) failed for just-installed VFS\",\n            this\n          );\n        }\n        return this;\n      };\n      vfs.installVfs = function(opt) {\n        let count = 0;\n        const propList = [\"io\", \"vfs\"];\n        for (const key of propList) {\n          const o = opt[key];\n          if (o) {\n            ++count;\n            o.struct.installMethods(o.methods, !!o.applyArgcCheck);\n            if (\"vfs\" === key) {\n              if (!o.struct.$zName && \"string\" === typeof o.name) {\n                o.struct.addOnDispose(\n                  o.struct.$zName = wasm.allocCString(o.name)\n                );\n              }\n              o.struct.registerVfs(!!o.asDefault);\n            }\n          }\n        }\n        if (!count)\n          toss(\n            \"Misuse: installVfs() options object requires at least\",\n            \"one of:\",\n            propList\n          );\n        return this;\n      };\n    });\n    \"use strict\";\n    globalThis.sqlite3ApiBootstrap.initializers.push(function(sqlite32) {\n      if (!sqlite32.wasm.exports.sqlite3_declare_vtab) {\n        return;\n      }\n      const wasm = sqlite32.wasm, capi = sqlite32.capi, toss = sqlite32.util.toss3;\n      const vtab = /* @__PURE__ */ Object.create(null);\n      sqlite32.vtab = vtab;\n      const sii = capi.sqlite3_index_info;\n      sii.prototype.nthConstraint = function(n, asPtr = false) {\n        if (n < 0 || n >= this.$nConstraint) return false;\n        const ptr = wasm.ptr.add(\n          this.$aConstraint,\n          sii.sqlite3_index_constraint.structInfo.sizeof * n\n        );\n        return asPtr ? ptr : new sii.sqlite3_index_constraint(ptr);\n      };\n      sii.prototype.nthConstraintUsage = function(n, asPtr = false) {\n        if (n < 0 || n >= this.$nConstraint) return false;\n        const ptr = wasm.ptr.add(\n          this.$aConstraintUsage,\n          sii.sqlite3_index_constraint_usage.structInfo.sizeof * n\n        );\n        return asPtr ? ptr : new sii.sqlite3_index_constraint_usage(ptr);\n      };\n      sii.prototype.nthOrderBy = function(n, asPtr = false) {\n        if (n < 0 || n >= this.$nOrderBy) return false;\n        const ptr = wasm.ptr.add(\n          this.$aOrderBy,\n          sii.sqlite3_index_orderby.structInfo.sizeof * n\n        );\n        return asPtr ? ptr : new sii.sqlite3_index_orderby(ptr);\n      };\n      const __xWrapFactory = function(methodName, StructType) {\n        return function(ptr, removeMapping = false) {\n          if (0 === arguments.length) ptr = new StructType();\n          if (ptr instanceof StructType) {\n            this.set(ptr.pointer, ptr);\n            return ptr;\n          } else if (!wasm.isPtr(ptr)) {\n            sqlite32.SQLite3Error.toss(\"Invalid argument to\", methodName + \"()\");\n          }\n          let rc = this.get(ptr);\n          if (removeMapping) this.delete(ptr);\n          return rc;\n        }.bind(/* @__PURE__ */ new Map());\n      };\n      const StructPtrMapper = function(name, StructType) {\n        const __xWrap = __xWrapFactory(name, StructType);\n        return Object.assign(/* @__PURE__ */ Object.create(null), {\n          StructType,\n          create: (ppOut) => {\n            const rc = __xWrap();\n            wasm.pokePtr(ppOut, rc.pointer);\n            return rc;\n          },\n          get: (pCObj) => __xWrap(pCObj),\n          unget: (pCObj) => __xWrap(pCObj, true),\n          dispose: (pCObj) => {\n            const o = __xWrap(pCObj, true);\n            if (o) o.dispose();\n          }\n        });\n      };\n      vtab.xVtab = StructPtrMapper(\"xVtab\", capi.sqlite3_vtab);\n      vtab.xCursor = StructPtrMapper(\"xCursor\", capi.sqlite3_vtab_cursor);\n      vtab.xIndexInfo = (pIdxInfo) => new capi.sqlite3_index_info(pIdxInfo);\n      vtab.xError = function f(methodName, err2, defaultRc) {\n        if (f.errorReporter instanceof Function) {\n          try {\n            f.errorReporter(\n              \"sqlite3_module::\" + methodName + \"(): \" + err2.message\n            );\n          } catch (e) {\n          }\n        }\n        let rc;\n        if (err2 instanceof sqlite32.WasmAllocError) rc = capi.SQLITE_NOMEM;\n        else if (arguments.length > 2) rc = defaultRc;\n        else if (err2 instanceof sqlite32.SQLite3Error) rc = err2.resultCode;\n        return rc || capi.SQLITE_ERROR;\n      };\n      vtab.xError.errorReporter = 1 ? sqlite32.config.error.bind(sqlite32.config) : false;\n      vtab.xRowid = (ppRowid64, value) => wasm.poke(ppRowid64, value, \"i64\");\n      vtab.setupModule = function(opt) {\n        let createdMod = false;\n        const mod = this instanceof capi.sqlite3_module ? this : opt.struct || (createdMod = new capi.sqlite3_module());\n        try {\n          const methods = opt.methods || toss(\"Missing 'methods' object.\");\n          for (const e of Object.entries({\n            xConnect: \"xCreate\",\n            xDisconnect: \"xDestroy\"\n          })) {\n            const k = e[0], v2 = e[1];\n            if (true === methods[k]) methods[k] = methods[v2];\n            else if (true === methods[v2]) methods[v2] = methods[k];\n          }\n          if (opt.catchExceptions) {\n            const fwrap = function(methodName, func) {\n              if ([\"xConnect\", \"xCreate\"].indexOf(methodName) >= 0) {\n                return function(pDb2, pAux, argc, argv, ppVtab, pzErr) {\n                  try {\n                    return func(...arguments) || 0;\n                  } catch (e) {\n                    if (!(e instanceof sqlite32.WasmAllocError)) {\n                      wasm.dealloc(wasm.peekPtr(pzErr));\n                      wasm.pokePtr(pzErr, wasm.allocCString(e.message));\n                    }\n                    return vtab.xError(methodName, e);\n                  }\n                };\n              } else {\n                return function(...args) {\n                  try {\n                    return func(...args) || 0;\n                  } catch (e) {\n                    return vtab.xError(methodName, e);\n                  }\n                };\n              }\n            };\n            const mnames = [\n              \"xCreate\",\n              \"xConnect\",\n              \"xBestIndex\",\n              \"xDisconnect\",\n              \"xDestroy\",\n              \"xOpen\",\n              \"xClose\",\n              \"xFilter\",\n              \"xNext\",\n              \"xEof\",\n              \"xColumn\",\n              \"xRowid\",\n              \"xUpdate\",\n              \"xBegin\",\n              \"xSync\",\n              \"xCommit\",\n              \"xRollback\",\n              \"xFindFunction\",\n              \"xRename\",\n              \"xSavepoint\",\n              \"xRelease\",\n              \"xRollbackTo\",\n              \"xShadowName\"\n            ];\n            const remethods = /* @__PURE__ */ Object.create(null);\n            for (const k of mnames) {\n              const m = methods[k];\n              if (!(m instanceof Function)) continue;\n              else if (\"xConnect\" === k && methods.xCreate === m) {\n                remethods[k] = methods.xCreate;\n              } else if (\"xCreate\" === k && methods.xConnect === m) {\n                remethods[k] = methods.xConnect;\n              } else {\n                remethods[k] = fwrap(k, m);\n              }\n            }\n            mod.installMethods(remethods, false);\n          } else {\n            mod.installMethods(methods, !!opt.applyArgcCheck);\n          }\n          if (0 === mod.$iVersion) {\n            let v2;\n            if (\"number\" === typeof opt.iVersion) v2 = opt.iVersion;\n            else if (mod.$xIntegrity) v2 = 4;\n            else if (mod.$xShadowName) v2 = 3;\n            else if (mod.$xSavePoint || mod.$xRelease || mod.$xRollbackTo)\n              v2 = 2;\n            else v2 = 1;\n            mod.$iVersion = v2;\n          }\n        } catch (e) {\n          if (createdMod) createdMod.dispose();\n          throw e;\n        }\n        return mod;\n      };\n      capi.sqlite3_module.prototype.setupModule = function(opt) {\n        return vtab.setupModule.call(this, opt);\n      };\n    });\n    \"use strict\";\n    globalThis.sqlite3ApiBootstrap.initializers.push(function(sqlite32) {\n      const installOpfsVfs = function callee3(options) {\n        if (!globalThis.SharedArrayBuffer || !globalThis.Atomics) {\n          return Promise.reject(\n            new Error(\n              \"Cannot install OPFS: Missing SharedArrayBuffer and/or Atomics. The server must emit the COOP/COEP response headers to enable those. See https://sqlite.org/wasm/doc/trunk/persistence.md#coop-coep\"\n            )\n          );\n        } else if (\"undefined\" === typeof WorkerGlobalScope) {\n          return Promise.reject(\n            new Error(\n              \"The OPFS sqlite3_vfs cannot run in the main thread because it requires Atomics.wait().\"\n            )\n          );\n        } else if (!globalThis.FileSystemHandle || !globalThis.FileSystemDirectoryHandle || !globalThis.FileSystemFileHandle || !globalThis.FileSystemFileHandle.prototype.createSyncAccessHandle || !navigator?.storage?.getDirectory) {\n          return Promise.reject(new Error(\"Missing required OPFS APIs.\"));\n        }\n        if (!options || \"object\" !== typeof options) {\n          options = /* @__PURE__ */ Object.create(null);\n        }\n        const urlParams = new URL(globalThis.location.href).searchParams;\n        if (urlParams.has(\"opfs-disable\")) {\n          return Promise.resolve(sqlite32);\n        }\n        if (void 0 === options.verbose) {\n          options.verbose = urlParams.has(\"opfs-verbose\") ? +urlParams.get(\"opfs-verbose\") || 2 : 1;\n        }\n        if (void 0 === options.sanityChecks) {\n          options.sanityChecks = urlParams.has(\"opfs-sanity-check\");\n        }\n        if (void 0 === options.proxyUri) {\n          options.proxyUri = callee3.defaultProxyUri;\n        }\n        if (\"function\" === typeof options.proxyUri) {\n          options.proxyUri = options.proxyUri();\n        }\n        const thePromise = new Promise(function(promiseResolve_, promiseReject_) {\n          const loggers = [\n            sqlite32.config.error,\n            sqlite32.config.warn,\n            sqlite32.config.log\n          ];\n          const logImpl = (level, ...args) => {\n            if (options.verbose > level)\n              loggers[level](\"OPFS syncer:\", ...args);\n          };\n          const log = (...args) => logImpl(2, ...args);\n          const warn = (...args) => logImpl(1, ...args);\n          const error = (...args) => logImpl(0, ...args);\n          const toss = sqlite32.util.toss;\n          const capi = sqlite32.capi;\n          const util = sqlite32.util;\n          const wasm = sqlite32.wasm;\n          const sqlite3_vfs = capi.sqlite3_vfs;\n          const sqlite3_file = capi.sqlite3_file;\n          const sqlite3_io_methods = capi.sqlite3_io_methods;\n          const opfsUtil = /* @__PURE__ */ Object.create(null);\n          const thisThreadHasOPFS = () => {\n            return globalThis.FileSystemHandle && globalThis.FileSystemDirectoryHandle && globalThis.FileSystemFileHandle && globalThis.FileSystemFileHandle.prototype.createSyncAccessHandle && navigator?.storage?.getDirectory;\n          };\n          opfsUtil.metrics = {\n            dump: function() {\n              let k, n = 0, t = 0, w = 0;\n              for (k in state.opIds) {\n                const m = metrics[k];\n                n += m.count;\n                t += m.time;\n                w += m.wait;\n                m.avgTime = m.count && m.time ? m.time / m.count : 0;\n                m.avgWait = m.count && m.wait ? m.wait / m.count : 0;\n              }\n              sqlite32.config.log(\n                globalThis.location.href,\n                \"metrics for\",\n                globalThis.location.href,\n                \":\",\n                metrics,\n                \"\\nTotal of\",\n                n,\n                \"op(s) for\",\n                t,\n                \"ms (incl. \" + w + \" ms of waiting on the async side)\"\n              );\n              sqlite32.config.log(\"Serialization metrics:\", metrics.s11n);\n              W.postMessage({ type: \"opfs-async-metrics\" });\n            },\n            reset: function() {\n              let k;\n              const r = (m) => m.count = m.time = m.wait = 0;\n              for (k in state.opIds) {\n                r(metrics[k] = /* @__PURE__ */ Object.create(null));\n              }\n              let s = metrics.s11n = /* @__PURE__ */ Object.create(null);\n              s = s.serialize = /* @__PURE__ */ Object.create(null);\n              s.count = s.time = 0;\n              s = metrics.s11n.deserialize = /* @__PURE__ */ Object.create(null);\n              s.count = s.time = 0;\n            }\n          };\n          const opfsIoMethods = new sqlite3_io_methods();\n          const opfsVfs = new sqlite3_vfs().addOnDispose(\n            () => opfsIoMethods.dispose()\n          );\n          let promiseWasRejected = void 0;\n          const promiseReject = (err2) => {\n            promiseWasRejected = true;\n            opfsVfs.dispose();\n            return promiseReject_(err2);\n          };\n          const promiseResolve = () => {\n            promiseWasRejected = false;\n            return promiseResolve_(sqlite32);\n          };\n          const W = new Worker(new URL(options.proxyUri, import.meta.url));\n          setTimeout(() => {\n            if (void 0 === promiseWasRejected) {\n              promiseReject(\n                new Error(\"Timeout while waiting for OPFS async proxy worker.\")\n              );\n            }\n          }, 4e3);\n          W._originalOnError = W.onerror;\n          W.onerror = function(err2) {\n            error(\"Error initializing OPFS asyncer:\", err2);\n            promiseReject(\n              new Error(\n                \"Loading OPFS async Worker failed for unknown reasons.\"\n              )\n            );\n          };\n          const pDVfs = capi.sqlite3_vfs_find(null);\n          const dVfs = pDVfs ? new sqlite3_vfs(pDVfs) : null;\n          opfsIoMethods.$iVersion = 1;\n          opfsVfs.$iVersion = 2;\n          opfsVfs.$szOsFile = capi.sqlite3_file.structInfo.sizeof;\n          opfsVfs.$mxPathname = 1024;\n          opfsVfs.$zName = wasm.allocCString(\"opfs\");\n          opfsVfs.$xDlOpen = opfsVfs.$xDlError = opfsVfs.$xDlSym = opfsVfs.$xDlClose = null;\n          opfsVfs.addOnDispose(\n            \"$zName\",\n            opfsVfs.$zName,\n            \"cleanup default VFS wrapper\",\n            () => dVfs ? dVfs.dispose() : null\n          );\n          const state = /* @__PURE__ */ Object.create(null);\n          state.verbose = options.verbose;\n          state.littleEndian = (() => {\n            const buffer = new ArrayBuffer(2);\n            new DataView(buffer).setInt16(0, 256, true);\n            return new Int16Array(buffer)[0] === 256;\n          })();\n          state.asyncIdleWaitTime = 150;\n          state.asyncS11nExceptions = 1;\n          state.fileBufferSize = 1024 * 64;\n          state.sabS11nOffset = state.fileBufferSize;\n          state.sabS11nSize = opfsVfs.$mxPathname * 2;\n          state.sabIO = new SharedArrayBuffer(\n            state.fileBufferSize + state.sabS11nSize\n          );\n          state.opIds = /* @__PURE__ */ Object.create(null);\n          const metrics = /* @__PURE__ */ Object.create(null);\n          {\n            let i = 0;\n            state.opIds.whichOp = i++;\n            state.opIds.rc = i++;\n            state.opIds.xAccess = i++;\n            state.opIds.xClose = i++;\n            state.opIds.xDelete = i++;\n            state.opIds.xDeleteNoWait = i++;\n            state.opIds.xFileSize = i++;\n            state.opIds.xLock = i++;\n            state.opIds.xOpen = i++;\n            state.opIds.xRead = i++;\n            state.opIds.xSleep = i++;\n            state.opIds.xSync = i++;\n            state.opIds.xTruncate = i++;\n            state.opIds.xUnlock = i++;\n            state.opIds.xWrite = i++;\n            state.opIds.mkdir = i++;\n            state.opIds[\"opfs-async-metrics\"] = i++;\n            state.opIds[\"opfs-async-shutdown\"] = i++;\n            state.opIds.retry = i++;\n            state.sabOP = new SharedArrayBuffer(i * 4);\n            opfsUtil.metrics.reset();\n          }\n          state.sq3Codes = /* @__PURE__ */ Object.create(null);\n          [\n            \"SQLITE_ACCESS_EXISTS\",\n            \"SQLITE_ACCESS_READWRITE\",\n            \"SQLITE_BUSY\",\n            \"SQLITE_CANTOPEN\",\n            \"SQLITE_ERROR\",\n            \"SQLITE_IOERR\",\n            \"SQLITE_IOERR_ACCESS\",\n            \"SQLITE_IOERR_CLOSE\",\n            \"SQLITE_IOERR_DELETE\",\n            \"SQLITE_IOERR_FSYNC\",\n            \"SQLITE_IOERR_LOCK\",\n            \"SQLITE_IOERR_READ\",\n            \"SQLITE_IOERR_SHORT_READ\",\n            \"SQLITE_IOERR_TRUNCATE\",\n            \"SQLITE_IOERR_UNLOCK\",\n            \"SQLITE_IOERR_WRITE\",\n            \"SQLITE_LOCK_EXCLUSIVE\",\n            \"SQLITE_LOCK_NONE\",\n            \"SQLITE_LOCK_PENDING\",\n            \"SQLITE_LOCK_RESERVED\",\n            \"SQLITE_LOCK_SHARED\",\n            \"SQLITE_LOCKED\",\n            \"SQLITE_MISUSE\",\n            \"SQLITE_NOTFOUND\",\n            \"SQLITE_OPEN_CREATE\",\n            \"SQLITE_OPEN_DELETEONCLOSE\",\n            \"SQLITE_OPEN_MAIN_DB\",\n            \"SQLITE_OPEN_READONLY\"\n          ].forEach((k) => {\n            if (void 0 === (state.sq3Codes[k] = capi[k])) {\n              toss(\"Maintenance required: not found:\", k);\n            }\n          });\n          state.opfsFlags = Object.assign(/* @__PURE__ */ Object.create(null), {\n            OPFS_UNLOCK_ASAP: 1,\n            OPFS_UNLINK_BEFORE_OPEN: 2,\n            defaultUnlockAsap: false\n          });\n          const opRun = (op, ...args) => {\n            const opNdx = state.opIds[op] || toss(\"Invalid op ID:\", op);\n            state.s11n.serialize(...args);\n            Atomics.store(state.sabOPView, state.opIds.rc, -1);\n            Atomics.store(state.sabOPView, state.opIds.whichOp, opNdx);\n            Atomics.notify(state.sabOPView, state.opIds.whichOp);\n            const t = performance.now();\n            while (\"not-equal\" !== Atomics.wait(state.sabOPView, state.opIds.rc, -1)) {\n            }\n            const rc = Atomics.load(state.sabOPView, state.opIds.rc);\n            metrics[op].wait += performance.now() - t;\n            if (rc && state.asyncS11nExceptions) {\n              const err2 = state.s11n.deserialize();\n              if (err2) error(op + \"() async error:\", ...err2);\n            }\n            return rc;\n          };\n          opfsUtil.debug = {\n            asyncShutdown: () => {\n              warn(\n                \"Shutting down OPFS async listener. The OPFS VFS will no longer work.\"\n              );\n              opRun(\"opfs-async-shutdown\");\n            },\n            asyncRestart: () => {\n              warn(\n                \"Attempting to restart OPFS VFS async listener. Might work, might not.\"\n              );\n              W.postMessage({ type: \"opfs-async-restart\" });\n            }\n          };\n          const initS11n = () => {\n            if (state.s11n) return state.s11n;\n            const textDecoder = new TextDecoder(), textEncoder = new TextEncoder(\"utf-8\"), viewU8 = new Uint8Array(\n              state.sabIO,\n              state.sabS11nOffset,\n              state.sabS11nSize\n            ), viewDV = new DataView(\n              state.sabIO,\n              state.sabS11nOffset,\n              state.sabS11nSize\n            );\n            state.s11n = /* @__PURE__ */ Object.create(null);\n            const TypeIds = /* @__PURE__ */ Object.create(null);\n            TypeIds.number = {\n              id: 1,\n              size: 8,\n              getter: \"getFloat64\",\n              setter: \"setFloat64\"\n            };\n            TypeIds.bigint = {\n              id: 2,\n              size: 8,\n              getter: \"getBigInt64\",\n              setter: \"setBigInt64\"\n            };\n            TypeIds.boolean = {\n              id: 3,\n              size: 4,\n              getter: \"getInt32\",\n              setter: \"setInt32\"\n            };\n            TypeIds.string = { id: 4 };\n            const getTypeId = (v2) => TypeIds[typeof v2] || toss(\n              \"Maintenance required: this value type cannot be serialized.\",\n              v2\n            );\n            const getTypeIdById = (tid) => {\n              switch (tid) {\n                case TypeIds.number.id:\n                  return TypeIds.number;\n                case TypeIds.bigint.id:\n                  return TypeIds.bigint;\n                case TypeIds.boolean.id:\n                  return TypeIds.boolean;\n                case TypeIds.string.id:\n                  return TypeIds.string;\n                default:\n                  toss(\"Invalid type ID:\", tid);\n              }\n            };\n            state.s11n.deserialize = function(clear = false) {\n              ++metrics.s11n.deserialize.count;\n              const t = performance.now();\n              const argc = viewU8[0];\n              const rc = argc ? [] : null;\n              if (argc) {\n                const typeIds = [];\n                let offset = 1, i, n, v2;\n                for (i = 0; i < argc; ++i, ++offset) {\n                  typeIds.push(getTypeIdById(viewU8[offset]));\n                }\n                for (i = 0; i < argc; ++i) {\n                  const t2 = typeIds[i];\n                  if (t2.getter) {\n                    v2 = viewDV[t2.getter](offset, state.littleEndian);\n                    offset += t2.size;\n                  } else {\n                    n = viewDV.getInt32(offset, state.littleEndian);\n                    offset += 4;\n                    v2 = textDecoder.decode(viewU8.slice(offset, offset + n));\n                    offset += n;\n                  }\n                  rc.push(v2);\n                }\n              }\n              if (clear) viewU8[0] = 0;\n              metrics.s11n.deserialize.time += performance.now() - t;\n              return rc;\n            };\n            state.s11n.serialize = function(...args) {\n              const t = performance.now();\n              ++metrics.s11n.serialize.count;\n              if (args.length) {\n                const typeIds = [];\n                let i = 0, offset = 1;\n                viewU8[0] = args.length & 255;\n                for (; i < args.length; ++i, ++offset) {\n                  typeIds.push(getTypeId(args[i]));\n                  viewU8[offset] = typeIds[i].id;\n                }\n                for (i = 0; i < args.length; ++i) {\n                  const t2 = typeIds[i];\n                  if (t2.setter) {\n                    viewDV[t2.setter](offset, args[i], state.littleEndian);\n                    offset += t2.size;\n                  } else {\n                    const s = textEncoder.encode(args[i]);\n                    viewDV.setInt32(offset, s.byteLength, state.littleEndian);\n                    offset += 4;\n                    viewU8.set(s, offset);\n                    offset += s.byteLength;\n                  }\n                }\n              } else {\n                viewU8[0] = 0;\n              }\n              metrics.s11n.serialize.time += performance.now() - t;\n            };\n            return state.s11n;\n          };\n          const randomFilename = function f(len = 16) {\n            if (!f._chars) {\n              f._chars = \"abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ012346789\";\n              f._n = f._chars.length;\n            }\n            const a = [];\n            let i = 0;\n            for (; i < len; ++i) {\n              const ndx = Math.random() * (f._n * 64) % f._n | 0;\n              a[i] = f._chars[ndx];\n            }\n            return a.join(\"\");\n          };\n          const __openFiles = /* @__PURE__ */ Object.create(null);\n          const opTimer = /* @__PURE__ */ Object.create(null);\n          opTimer.op = void 0;\n          opTimer.start = void 0;\n          const mTimeStart = (op) => {\n            opTimer.start = performance.now();\n            opTimer.op = op;\n            ++metrics[op].count;\n          };\n          const mTimeEnd = () => metrics[opTimer.op].time += performance.now() - opTimer.start;\n          const ioSyncWrappers = {\n            xCheckReservedLock: function(pFile, pOut) {\n              wasm.poke(pOut, 0, \"i32\");\n              return 0;\n            },\n            xClose: function(pFile) {\n              mTimeStart(\"xClose\");\n              let rc = 0;\n              const f = __openFiles[pFile];\n              if (f) {\n                delete __openFiles[pFile];\n                rc = opRun(\"xClose\", pFile);\n                if (f.sq3File) f.sq3File.dispose();\n              }\n              mTimeEnd();\n              return rc;\n            },\n            xDeviceCharacteristics: function(pFile) {\n              return capi.SQLITE_IOCAP_UNDELETABLE_WHEN_OPEN;\n            },\n            xFileControl: function(pFile, opId, pArg) {\n              return capi.SQLITE_NOTFOUND;\n            },\n            xFileSize: function(pFile, pSz64) {\n              mTimeStart(\"xFileSize\");\n              let rc = opRun(\"xFileSize\", pFile);\n              if (0 == rc) {\n                try {\n                  const sz = state.s11n.deserialize()[0];\n                  wasm.poke(pSz64, sz, \"i64\");\n                } catch (e) {\n                  error(\"Unexpected error reading xFileSize() result:\", e);\n                  rc = state.sq3Codes.SQLITE_IOERR;\n                }\n              }\n              mTimeEnd();\n              return rc;\n            },\n            xLock: function(pFile, lockType) {\n              mTimeStart(\"xLock\");\n              const f = __openFiles[pFile];\n              let rc = 0;\n              if (!f.lockType) {\n                rc = opRun(\"xLock\", pFile, lockType);\n                if (0 === rc) f.lockType = lockType;\n              } else {\n                f.lockType = lockType;\n              }\n              mTimeEnd();\n              return rc;\n            },\n            xRead: function(pFile, pDest, n, offset64) {\n              mTimeStart(\"xRead\");\n              const f = __openFiles[pFile];\n              let rc;\n              try {\n                rc = opRun(\"xRead\", pFile, n, Number(offset64));\n                if (0 === rc || capi.SQLITE_IOERR_SHORT_READ === rc) {\n                  wasm.heap8u().set(f.sabView.subarray(0, n), Number(pDest));\n                }\n              } catch (e) {\n                error(\"xRead(\", arguments, \") failed:\", e, f);\n                rc = capi.SQLITE_IOERR_READ;\n              }\n              mTimeEnd();\n              return rc;\n            },\n            xSync: function(pFile, flags) {\n              mTimeStart(\"xSync\");\n              ++metrics.xSync.count;\n              const rc = opRun(\"xSync\", pFile, flags);\n              mTimeEnd();\n              return rc;\n            },\n            xTruncate: function(pFile, sz64) {\n              mTimeStart(\"xTruncate\");\n              const rc = opRun(\"xTruncate\", pFile, Number(sz64));\n              mTimeEnd();\n              return rc;\n            },\n            xUnlock: function(pFile, lockType) {\n              mTimeStart(\"xUnlock\");\n              const f = __openFiles[pFile];\n              let rc = 0;\n              if (capi.SQLITE_LOCK_NONE === lockType && f.lockType) {\n                rc = opRun(\"xUnlock\", pFile, lockType);\n              }\n              if (0 === rc) f.lockType = lockType;\n              mTimeEnd();\n              return rc;\n            },\n            xWrite: function(pFile, pSrc, n, offset64) {\n              mTimeStart(\"xWrite\");\n              const f = __openFiles[pFile];\n              let rc;\n              try {\n                f.sabView.set(\n                  wasm.heap8u().subarray(Number(pSrc), Number(pSrc) + n)\n                );\n                rc = opRun(\"xWrite\", pFile, n, Number(offset64));\n              } catch (e) {\n                error(\"xWrite(\", arguments, \") failed:\", e, f);\n                rc = capi.SQLITE_IOERR_WRITE;\n              }\n              mTimeEnd();\n              return rc;\n            }\n          };\n          const vfsSyncWrappers = {\n            xAccess: function(pVfs, zName, flags, pOut) {\n              mTimeStart(\"xAccess\");\n              const rc = opRun(\"xAccess\", wasm.cstrToJs(zName));\n              wasm.poke(pOut, rc ? 0 : 1, \"i32\");\n              mTimeEnd();\n              return 0;\n            },\n            xCurrentTime: function(pVfs, pOut) {\n              wasm.poke(\n                pOut,\n                24405875e-1 + (/* @__PURE__ */ new Date()).getTime() / 864e5,\n                \"double\"\n              );\n              return 0;\n            },\n            xCurrentTimeInt64: function(pVfs, pOut) {\n              wasm.poke(\n                pOut,\n                24405875e-1 * 864e5 + (/* @__PURE__ */ new Date()).getTime(),\n                \"i64\"\n              );\n              return 0;\n            },\n            xDelete: function(pVfs, zName, doSyncDir) {\n              mTimeStart(\"xDelete\");\n              const rc = opRun(\n                \"xDelete\",\n                wasm.cstrToJs(zName),\n                doSyncDir,\n                false\n              );\n              mTimeEnd();\n              return rc;\n            },\n            xFullPathname: function(pVfs, zName, nOut, pOut) {\n              const i = wasm.cstrncpy(pOut, zName, nOut);\n              return i < nOut ? 0 : capi.SQLITE_CANTOPEN;\n            },\n            xGetLastError: function(pVfs, nOut, pOut) {\n              warn(\"OPFS xGetLastError() has nothing sensible to return.\");\n              return 0;\n            },\n            xOpen: function f(pVfs, zName, pFile, flags, pOutFlags) {\n              mTimeStart(\"xOpen\");\n              let opfsFlags = 0;\n              if (0 === zName) {\n                zName = randomFilename();\n              } else if (wasm.isPtr(zName)) {\n                if (capi.sqlite3_uri_boolean(zName, \"opfs-unlock-asap\", 0)) {\n                  opfsFlags |= state.opfsFlags.OPFS_UNLOCK_ASAP;\n                }\n                if (capi.sqlite3_uri_boolean(zName, \"delete-before-open\", 0)) {\n                  opfsFlags |= state.opfsFlags.OPFS_UNLINK_BEFORE_OPEN;\n                }\n                zName = wasm.cstrToJs(zName);\n              }\n              const fh = /* @__PURE__ */ Object.create(null);\n              fh.fid = pFile;\n              fh.filename = zName;\n              fh.sab = new SharedArrayBuffer(state.fileBufferSize);\n              fh.flags = flags;\n              fh.readOnly = !(sqlite32.SQLITE_OPEN_CREATE & flags) && !!(flags & capi.SQLITE_OPEN_READONLY);\n              const rc = opRun(\"xOpen\", pFile, zName, flags, opfsFlags);\n              if (!rc) {\n                if (fh.readOnly) {\n                  wasm.poke(pOutFlags, capi.SQLITE_OPEN_READONLY, \"i32\");\n                }\n                __openFiles[pFile] = fh;\n                fh.sabView = state.sabFileBufView;\n                fh.sq3File = new sqlite3_file(pFile);\n                fh.sq3File.$pMethods = opfsIoMethods.pointer;\n                fh.lockType = capi.SQLITE_LOCK_NONE;\n              }\n              mTimeEnd();\n              return rc;\n            }\n          };\n          if (dVfs) {\n            opfsVfs.$xRandomness = dVfs.$xRandomness;\n            opfsVfs.$xSleep = dVfs.$xSleep;\n          }\n          if (!opfsVfs.$xRandomness) {\n            vfsSyncWrappers.xRandomness = function(pVfs, nOut, pOut) {\n              const heap = wasm.heap8u();\n              let i = 0;\n              const npOut = Number(pOut);\n              for (; i < nOut; ++i)\n                heap[npOut + i] = Math.random() * 255e3 & 255;\n              return i;\n            };\n          }\n          if (!opfsVfs.$xSleep) {\n            vfsSyncWrappers.xSleep = function(pVfs, ms) {\n              Atomics.wait(state.sabOPView, state.opIds.xSleep, 0, ms);\n              return 0;\n            };\n          }\n          opfsUtil.getResolvedPath = function(filename, splitIt) {\n            const p = new URL(filename, \"file://irrelevant\").pathname;\n            return splitIt ? p.split(\"/\").filter((v2) => !!v2) : p;\n          };\n          opfsUtil.getDirForFilename = async function f(absFilename, createDirs = false) {\n            const path = opfsUtil.getResolvedPath(absFilename, true);\n            const filename = path.pop();\n            let dh = opfsUtil.rootDirectory;\n            for (const dirName of path) {\n              if (dirName) {\n                dh = await dh.getDirectoryHandle(dirName, {\n                  create: !!createDirs\n                });\n              }\n            }\n            return [dh, filename];\n          };\n          opfsUtil.mkdir = async function(absDirName) {\n            try {\n              await opfsUtil.getDirForFilename(absDirName + \"/filepart\", true);\n              return true;\n            } catch (e) {\n              return false;\n            }\n          };\n          opfsUtil.entryExists = async function(fsEntryName) {\n            try {\n              const [dh, fn] = await opfsUtil.getDirForFilename(fsEntryName);\n              await dh.getFileHandle(fn);\n              return true;\n            } catch (e) {\n              return false;\n            }\n          };\n          opfsUtil.randomFilename = randomFilename;\n          opfsUtil.treeList = async function() {\n            const doDir = async function callee4(dirHandle, tgt) {\n              tgt.name = dirHandle.name;\n              tgt.dirs = [];\n              tgt.files = [];\n              for await (const handle of dirHandle.values()) {\n                if (\"directory\" === handle.kind) {\n                  const subDir = /* @__PURE__ */ Object.create(null);\n                  tgt.dirs.push(subDir);\n                  await callee4(handle, subDir);\n                } else {\n                  tgt.files.push(handle.name);\n                }\n              }\n            };\n            const root = /* @__PURE__ */ Object.create(null);\n            await doDir(opfsUtil.rootDirectory, root);\n            return root;\n          };\n          opfsUtil.rmfr = async function() {\n            const dir = opfsUtil.rootDirectory, opt = { recurse: true };\n            for await (const handle of dir.values()) {\n              dir.removeEntry(handle.name, opt);\n            }\n          };\n          opfsUtil.unlink = async function(fsEntryName, recursive = false, throwOnError = false) {\n            try {\n              const [hDir, filenamePart] = await opfsUtil.getDirForFilename(\n                fsEntryName,\n                false\n              );\n              await hDir.removeEntry(filenamePart, { recursive });\n              return true;\n            } catch (e) {\n              if (throwOnError) {\n                throw new Error(\n                  \"unlink(\",\n                  arguments[0],\n                  \") failed: \" + e.message,\n                  {\n                    cause: e\n                  }\n                );\n              }\n              return false;\n            }\n          };\n          opfsUtil.traverse = async function(opt) {\n            const defaultOpt = {\n              recursive: true,\n              directory: opfsUtil.rootDirectory\n            };\n            if (\"function\" === typeof opt) {\n              opt = { callback: opt };\n            }\n            opt = Object.assign(defaultOpt, opt || {});\n            const doDir = async function callee4(dirHandle, depth) {\n              for await (const handle of dirHandle.values()) {\n                if (false === opt.callback(handle, dirHandle, depth))\n                  return false;\n                else if (opt.recursive && \"directory\" === handle.kind) {\n                  if (false === await callee4(handle, depth + 1)) break;\n                }\n              }\n            };\n            doDir(opt.directory, 0);\n          };\n          const importDbChunked = async function(filename, callback) {\n            const [hDir, fnamePart] = await opfsUtil.getDirForFilename(\n              filename,\n              true\n            );\n            const hFile = await hDir.getFileHandle(fnamePart, { create: true });\n            let sah = await hFile.createSyncAccessHandle();\n            let nWrote = 0, chunk, checkedHeader = false, err2 = false;\n            try {\n              sah.truncate(0);\n              while (void 0 !== (chunk = await callback())) {\n                if (chunk instanceof ArrayBuffer) chunk = new Uint8Array(chunk);\n                if (!checkedHeader && 0 === nWrote && chunk.byteLength >= 15) {\n                  util.affirmDbHeader(chunk);\n                  checkedHeader = true;\n                }\n                sah.write(chunk, { at: nWrote });\n                nWrote += chunk.byteLength;\n              }\n              if (nWrote < 512 || 0 !== nWrote % 512) {\n                toss(\n                  \"Input size\",\n                  nWrote,\n                  \"is not correct for an SQLite database.\"\n                );\n              }\n              if (!checkedHeader) {\n                const header = new Uint8Array(20);\n                sah.read(header, { at: 0 });\n                util.affirmDbHeader(header);\n              }\n              sah.write(new Uint8Array([1, 1]), { at: 18 });\n              return nWrote;\n            } catch (e) {\n              await sah.close();\n              sah = void 0;\n              await hDir.removeEntry(fnamePart).catch(() => {\n              });\n              throw e;\n            } finally {\n              if (sah) await sah.close();\n            }\n          };\n          opfsUtil.importDb = async function(filename, bytes) {\n            if (bytes instanceof Function) {\n              return importDbChunked(filename, bytes);\n            }\n            if (bytes instanceof ArrayBuffer) bytes = new Uint8Array(bytes);\n            util.affirmIsDb(bytes);\n            const n = bytes.byteLength;\n            const [hDir, fnamePart] = await opfsUtil.getDirForFilename(\n              filename,\n              true\n            );\n            let sah, err2, nWrote = 0;\n            try {\n              const hFile = await hDir.getFileHandle(fnamePart, {\n                create: true\n              });\n              sah = await hFile.createSyncAccessHandle();\n              sah.truncate(0);\n              nWrote = sah.write(bytes, { at: 0 });\n              if (nWrote != n) {\n                toss(\n                  \"Expected to write \" + n + \" bytes but wrote \" + nWrote + \".\"\n                );\n              }\n              sah.write(new Uint8Array([1, 1]), { at: 18 });\n              return nWrote;\n            } catch (e) {\n              if (sah) {\n                await sah.close();\n                sah = void 0;\n              }\n              await hDir.removeEntry(fnamePart).catch(() => {\n              });\n              throw e;\n            } finally {\n              if (sah) await sah.close();\n            }\n          };\n          if (sqlite32.oo1) {\n            const OpfsDb = function(...args) {\n              const opt = sqlite32.oo1.DB.dbCtorHelper.normalizeArgs(...args);\n              opt.vfs = opfsVfs.$zName;\n              sqlite32.oo1.DB.dbCtorHelper.call(this, opt);\n            };\n            OpfsDb.prototype = Object.create(sqlite32.oo1.DB.prototype);\n            sqlite32.oo1.OpfsDb = OpfsDb;\n            OpfsDb.importDb = opfsUtil.importDb;\n            sqlite32.oo1.DB.dbCtorHelper.setVfsPostOpenCallback(\n              opfsVfs.pointer,\n              function(oo1Db, sqlite33) {\n                sqlite33.capi.sqlite3_busy_timeout(oo1Db, 1e4);\n              }\n            );\n          }\n          const sanityCheck = function() {\n            const scope = wasm.scopedAllocPush();\n            const sq3File = new sqlite3_file();\n            try {\n              const fid = sq3File.pointer;\n              const openFlags = capi.SQLITE_OPEN_CREATE | capi.SQLITE_OPEN_READWRITE | capi.SQLITE_OPEN_MAIN_DB;\n              const pOut = wasm.scopedAlloc(8);\n              const dbFile = \"/sanity/check/file\" + randomFilename(8);\n              const zDbFile = wasm.scopedAllocCString(dbFile);\n              let rc;\n              state.s11n.serialize(\"This is \\xE4 string.\");\n              rc = state.s11n.deserialize();\n              log(\"deserialize() says:\", rc);\n              if (\"This is \\xE4 string.\" !== rc[0]) toss(\"String d13n error.\");\n              vfsSyncWrappers.xAccess(opfsVfs.pointer, zDbFile, 0, pOut);\n              rc = wasm.peek(pOut, \"i32\");\n              log(\"xAccess(\", dbFile, \") exists ?=\", rc);\n              rc = vfsSyncWrappers.xOpen(\n                opfsVfs.pointer,\n                zDbFile,\n                fid,\n                openFlags,\n                pOut\n              );\n              log(\n                \"open rc =\",\n                rc,\n                \"state.sabOPView[xOpen] =\",\n                state.sabOPView[state.opIds.xOpen]\n              );\n              if (0 !== rc) {\n                error(\"open failed with code\", rc);\n                return;\n              }\n              vfsSyncWrappers.xAccess(opfsVfs.pointer, zDbFile, 0, pOut);\n              rc = wasm.peek(pOut, \"i32\");\n              if (!rc) toss(\"xAccess() failed to detect file.\");\n              rc = ioSyncWrappers.xSync(sq3File.pointer, 0);\n              if (rc) toss(\"sync failed w/ rc\", rc);\n              rc = ioSyncWrappers.xTruncate(sq3File.pointer, 1024);\n              if (rc) toss(\"truncate failed w/ rc\", rc);\n              wasm.poke(pOut, 0, \"i64\");\n              rc = ioSyncWrappers.xFileSize(sq3File.pointer, pOut);\n              if (rc) toss(\"xFileSize failed w/ rc\", rc);\n              log(\"xFileSize says:\", wasm.peek(pOut, \"i64\"));\n              rc = ioSyncWrappers.xWrite(sq3File.pointer, zDbFile, 10, 1);\n              if (rc) toss(\"xWrite() failed!\");\n              const readBuf = wasm.scopedAlloc(16);\n              rc = ioSyncWrappers.xRead(sq3File.pointer, readBuf, 6, 2);\n              wasm.poke(readBuf + 6, 0);\n              let jRead = wasm.cstrToJs(readBuf);\n              log(\"xRead() got:\", jRead);\n              if (\"sanity\" !== jRead) toss(\"Unexpected xRead() value.\");\n              if (vfsSyncWrappers.xSleep) {\n                log(\"xSleep()ing before close()ing...\");\n                vfsSyncWrappers.xSleep(opfsVfs.pointer, 2e3);\n                log(\"waking up from xSleep()\");\n              }\n              rc = ioSyncWrappers.xClose(fid);\n              log(\"xClose rc =\", rc, \"sabOPView =\", state.sabOPView);\n              log(\"Deleting file:\", dbFile);\n              vfsSyncWrappers.xDelete(opfsVfs.pointer, zDbFile, 4660);\n              vfsSyncWrappers.xAccess(opfsVfs.pointer, zDbFile, 0, pOut);\n              rc = wasm.peek(pOut, \"i32\");\n              if (rc)\n                toss(\"Expecting 0 from xAccess(\", dbFile, \") after xDelete().\");\n              warn(\"End of OPFS sanity checks.\");\n            } finally {\n              sq3File.dispose();\n              wasm.scopedAllocPop(scope);\n            }\n          };\n          W.onmessage = function({ data }) {\n            switch (data.type) {\n              case \"opfs-unavailable\":\n                promiseReject(new Error(data.payload.join(\" \")));\n                break;\n              case \"opfs-async-loaded\":\n                W.postMessage({ type: \"opfs-async-init\", args: state });\n                break;\n              case \"opfs-async-inited\": {\n                if (true === promiseWasRejected) {\n                  break;\n                }\n                try {\n                  sqlite32.vfs.installVfs({\n                    io: { struct: opfsIoMethods, methods: ioSyncWrappers },\n                    vfs: { struct: opfsVfs, methods: vfsSyncWrappers }\n                  });\n                  state.sabOPView = new Int32Array(state.sabOP);\n                  state.sabFileBufView = new Uint8Array(\n                    state.sabIO,\n                    0,\n                    state.fileBufferSize\n                  );\n                  state.sabS11nView = new Uint8Array(\n                    state.sabIO,\n                    state.sabS11nOffset,\n                    state.sabS11nSize\n                  );\n                  initS11n();\n                  if (options.sanityChecks) {\n                    warn(\n                      \"Running sanity checks because of opfs-sanity-check URL arg...\"\n                    );\n                    sanityCheck();\n                  }\n                  if (thisThreadHasOPFS()) {\n                    navigator.storage.getDirectory().then((d) => {\n                      W.onerror = W._originalOnError;\n                      delete W._originalOnError;\n                      sqlite32.opfs = opfsUtil;\n                      opfsUtil.rootDirectory = d;\n                      log(\"End of OPFS sqlite3_vfs setup.\", opfsVfs);\n                      promiseResolve();\n                    }).catch(promiseReject);\n                  } else {\n                    promiseResolve();\n                  }\n                } catch (e) {\n                  error(e);\n                  promiseReject(e);\n                }\n                break;\n              }\n              default: {\n                const errMsg = \"Unexpected message from the OPFS async worker: \" + JSON.stringify(data);\n                error(errMsg);\n                promiseReject(new Error(errMsg));\n                break;\n              }\n            }\n          };\n        });\n        return thePromise;\n      };\n      installOpfsVfs.defaultProxyUri = \"sqlite3-opfs-async-proxy.js\";\n      globalThis.sqlite3ApiBootstrap.initializersAsync.push(async (sqlite33) => {\n        try {\n          let proxyJs = installOpfsVfs.defaultProxyUri;\n          if (sqlite33.scriptInfo.sqlite3Dir) {\n            installOpfsVfs.defaultProxyUri = sqlite33.scriptInfo.sqlite3Dir + proxyJs;\n          }\n          return installOpfsVfs().catch((e) => {\n            sqlite33.config.warn(\n              \"Ignoring inability to install OPFS sqlite3_vfs:\",\n              e.message\n            );\n          });\n        } catch (e) {\n          sqlite33.config.error(\"installOpfsVfs() exception:\", e);\n          return Promise.reject(e);\n        }\n      });\n    });\n    globalThis.sqlite3ApiBootstrap.initializers.push(function(sqlite32) {\n      \"use strict\";\n      const toss = sqlite32.util.toss;\n      const toss3 = sqlite32.util.toss3;\n      const initPromises = /* @__PURE__ */ Object.create(null);\n      const capi = sqlite32.capi;\n      const util = sqlite32.util;\n      const wasm = sqlite32.wasm;\n      const SECTOR_SIZE = 4096;\n      const HEADER_MAX_PATH_SIZE = 512;\n      const HEADER_FLAGS_SIZE = 4;\n      const HEADER_DIGEST_SIZE = 8;\n      const HEADER_CORPUS_SIZE = HEADER_MAX_PATH_SIZE + HEADER_FLAGS_SIZE;\n      const HEADER_OFFSET_FLAGS = HEADER_MAX_PATH_SIZE;\n      const HEADER_OFFSET_DIGEST = HEADER_CORPUS_SIZE;\n      const HEADER_OFFSET_DATA = SECTOR_SIZE;\n      const PERSISTENT_FILE_TYPES = capi.SQLITE_OPEN_MAIN_DB | capi.SQLITE_OPEN_MAIN_JOURNAL | capi.SQLITE_OPEN_SUPER_JOURNAL | capi.SQLITE_OPEN_WAL;\n      const FLAG_COMPUTE_DIGEST_V2 = capi.SQLITE_OPEN_MEMORY;\n      const OPAQUE_DIR_NAME = \".opaque\";\n      const getRandomName = () => Math.random().toString(36).slice(2);\n      const textDecoder = new TextDecoder();\n      const textEncoder = new TextEncoder();\n      const optionDefaults = Object.assign(/* @__PURE__ */ Object.create(null), {\n        name: \"opfs-sahpool\",\n        directory: void 0,\n        initialCapacity: 6,\n        clearOnInit: false,\n        verbosity: 2,\n        forceReinitIfPreviouslyFailed: false\n      });\n      const loggers = [\n        sqlite32.config.error,\n        sqlite32.config.warn,\n        sqlite32.config.log\n      ];\n      const log = sqlite32.config.log;\n      const warn = sqlite32.config.warn;\n      const error = sqlite32.config.error;\n      const __mapVfsToPool = /* @__PURE__ */ new Map();\n      const getPoolForVfs = (pVfs) => __mapVfsToPool.get(pVfs);\n      const setPoolForVfs = (pVfs, pool) => {\n        if (pool) __mapVfsToPool.set(pVfs, pool);\n        else __mapVfsToPool.delete(pVfs);\n      };\n      const __mapSqlite3File = /* @__PURE__ */ new Map();\n      const getPoolForPFile = (pFile) => __mapSqlite3File.get(pFile);\n      const setPoolForPFile = (pFile, pool) => {\n        if (pool) __mapSqlite3File.set(pFile, pool);\n        else __mapSqlite3File.delete(pFile);\n      };\n      const ioMethods = {\n        xCheckReservedLock: function(pFile, pOut) {\n          const pool = getPoolForPFile(pFile);\n          pool.log(\"xCheckReservedLock\");\n          pool.storeErr();\n          wasm.poke32(pOut, 1);\n          return 0;\n        },\n        xClose: function(pFile) {\n          const pool = getPoolForPFile(pFile);\n          pool.storeErr();\n          const file = pool.getOFileForS3File(pFile);\n          if (file) {\n            try {\n              pool.log(`xClose ${file.path}`);\n              pool.mapS3FileToOFile(pFile, false);\n              file.sah.flush();\n              if (file.flags & capi.SQLITE_OPEN_DELETEONCLOSE) {\n                pool.deletePath(file.path);\n              }\n            } catch (e) {\n              return pool.storeErr(e, capi.SQLITE_IOERR);\n            }\n          }\n          return 0;\n        },\n        xDeviceCharacteristics: function(pFile) {\n          return capi.SQLITE_IOCAP_UNDELETABLE_WHEN_OPEN;\n        },\n        xFileControl: function(pFile, opId, pArg) {\n          return capi.SQLITE_NOTFOUND;\n        },\n        xFileSize: function(pFile, pSz64) {\n          const pool = getPoolForPFile(pFile);\n          pool.log(`xFileSize`);\n          const file = pool.getOFileForS3File(pFile);\n          const size = file.sah.getSize() - HEADER_OFFSET_DATA;\n          wasm.poke64(pSz64, BigInt(size));\n          return 0;\n        },\n        xLock: function(pFile, lockType) {\n          const pool = getPoolForPFile(pFile);\n          pool.log(`xLock ${lockType}`);\n          pool.storeErr();\n          const file = pool.getOFileForS3File(pFile);\n          file.lockType = lockType;\n          return 0;\n        },\n        xRead: function(pFile, pDest, n, offset64) {\n          const pool = getPoolForPFile(pFile);\n          pool.storeErr();\n          const file = pool.getOFileForS3File(pFile);\n          pool.log(`xRead ${file.path} ${n} @ ${offset64}`);\n          try {\n            const nRead = file.sah.read(\n              wasm.heap8u().subarray(Number(pDest), Number(pDest) + n),\n              { at: HEADER_OFFSET_DATA + Number(offset64) }\n            );\n            if (nRead < n) {\n              wasm.heap8u().fill(0, Number(pDest) + nRead, Number(pDest) + n);\n              return capi.SQLITE_IOERR_SHORT_READ;\n            }\n            return 0;\n          } catch (e) {\n            return pool.storeErr(e, capi.SQLITE_IOERR);\n          }\n        },\n        xSectorSize: function(pFile) {\n          return SECTOR_SIZE;\n        },\n        xSync: function(pFile, flags) {\n          const pool = getPoolForPFile(pFile);\n          pool.log(`xSync ${flags}`);\n          pool.storeErr();\n          const file = pool.getOFileForS3File(pFile);\n          try {\n            file.sah.flush();\n            return 0;\n          } catch (e) {\n            return pool.storeErr(e, capi.SQLITE_IOERR);\n          }\n        },\n        xTruncate: function(pFile, sz64) {\n          const pool = getPoolForPFile(pFile);\n          pool.log(`xTruncate ${sz64}`);\n          pool.storeErr();\n          const file = pool.getOFileForS3File(pFile);\n          try {\n            file.sah.truncate(HEADER_OFFSET_DATA + Number(sz64));\n            return 0;\n          } catch (e) {\n            return pool.storeErr(e, capi.SQLITE_IOERR);\n          }\n        },\n        xUnlock: function(pFile, lockType) {\n          const pool = getPoolForPFile(pFile);\n          pool.log(\"xUnlock\");\n          const file = pool.getOFileForS3File(pFile);\n          file.lockType = lockType;\n          return 0;\n        },\n        xWrite: function(pFile, pSrc, n, offset64) {\n          const pool = getPoolForPFile(pFile);\n          pool.storeErr();\n          const file = pool.getOFileForS3File(pFile);\n          pool.log(`xWrite ${file.path} ${n} ${offset64}`);\n          try {\n            const nBytes = file.sah.write(\n              wasm.heap8u().subarray(Number(pSrc), Number(pSrc) + n),\n              { at: HEADER_OFFSET_DATA + Number(offset64) }\n            );\n            return n === nBytes ? 0 : toss(\"Unknown write() failure.\");\n          } catch (e) {\n            return pool.storeErr(e, capi.SQLITE_IOERR);\n          }\n        }\n      };\n      const opfsIoMethods = new capi.sqlite3_io_methods();\n      opfsIoMethods.$iVersion = 1;\n      sqlite32.vfs.installVfs({\n        io: { struct: opfsIoMethods, methods: ioMethods }\n      });\n      const vfsMethods = {\n        xAccess: function(pVfs, zName, flags, pOut) {\n          const pool = getPoolForVfs(pVfs);\n          pool.storeErr();\n          try {\n            const name = pool.getPath(zName);\n            wasm.poke32(pOut, pool.hasFilename(name) ? 1 : 0);\n          } catch (e) {\n            wasm.poke32(pOut, 0);\n          }\n          return 0;\n        },\n        xCurrentTime: function(pVfs, pOut) {\n          wasm.poke(\n            pOut,\n            24405875e-1 + (/* @__PURE__ */ new Date()).getTime() / 864e5,\n            \"double\"\n          );\n          return 0;\n        },\n        xCurrentTimeInt64: function(pVfs, pOut) {\n          wasm.poke(pOut, 24405875e-1 * 864e5 + (/* @__PURE__ */ new Date()).getTime(), \"i64\");\n          return 0;\n        },\n        xDelete: function(pVfs, zName, doSyncDir) {\n          const pool = getPoolForVfs(pVfs);\n          pool.log(`xDelete ${wasm.cstrToJs(zName)}`);\n          pool.storeErr();\n          try {\n            pool.deletePath(pool.getPath(zName));\n            return 0;\n          } catch (e) {\n            pool.storeErr(e);\n            return capi.SQLITE_IOERR_DELETE;\n          }\n        },\n        xFullPathname: function(pVfs, zName, nOut, pOut) {\n          const i = wasm.cstrncpy(pOut, zName, nOut);\n          return i < nOut ? 0 : capi.SQLITE_CANTOPEN;\n        },\n        xGetLastError: function(pVfs, nOut, pOut) {\n          const pool = getPoolForVfs(pVfs);\n          const e = pool.popErr();\n          pool.log(`xGetLastError ${nOut} e =`, e);\n          if (e) {\n            const scope = wasm.scopedAllocPush();\n            try {\n              const [cMsg, n] = wasm.scopedAllocCString(e.message, true);\n              wasm.cstrncpy(pOut, cMsg, nOut);\n              if (n > nOut) wasm.poke8(pOut + nOut - 1, 0);\n            } catch (e2) {\n              return capi.SQLITE_NOMEM;\n            } finally {\n              wasm.scopedAllocPop(scope);\n            }\n          }\n          return e ? e.sqlite3Rc || capi.SQLITE_IOERR : 0;\n        },\n        xOpen: function f(pVfs, zName, pFile, flags, pOutFlags) {\n          const pool = getPoolForVfs(pVfs);\n          try {\n            flags &= ~FLAG_COMPUTE_DIGEST_V2;\n            pool.log(`xOpen ${wasm.cstrToJs(zName)} ${flags}`);\n            const path = zName && wasm.peek8(zName) ? pool.getPath(zName) : getRandomName();\n            let sah = pool.getSAHForPath(path);\n            if (!sah && flags & capi.SQLITE_OPEN_CREATE) {\n              if (pool.getFileCount() < pool.getCapacity()) {\n                sah = pool.nextAvailableSAH();\n                pool.setAssociatedPath(sah, path, flags);\n              } else {\n                toss(\"SAH pool is full. Cannot create file\", path);\n              }\n            }\n            if (!sah) {\n              toss(\"file not found:\", path);\n            }\n            const file = { path, flags, sah };\n            pool.mapS3FileToOFile(pFile, file);\n            file.lockType = capi.SQLITE_LOCK_NONE;\n            const sq3File = new capi.sqlite3_file(pFile);\n            sq3File.$pMethods = opfsIoMethods.pointer;\n            sq3File.dispose();\n            wasm.poke32(pOutFlags, flags);\n            return 0;\n          } catch (e) {\n            pool.storeErr(e);\n            return capi.SQLITE_CANTOPEN;\n          }\n        }\n      };\n      const createOpfsVfs = function(vfsName) {\n        if (sqlite32.capi.sqlite3_vfs_find(vfsName)) {\n          toss3(\"VFS name is already registered:\", vfsName);\n        }\n        const opfsVfs = new capi.sqlite3_vfs();\n        const pDVfs = capi.sqlite3_vfs_find(null);\n        const dVfs = pDVfs ? new capi.sqlite3_vfs(pDVfs) : null;\n        opfsVfs.$iVersion = 2;\n        opfsVfs.$szOsFile = capi.sqlite3_file.structInfo.sizeof;\n        opfsVfs.$mxPathname = HEADER_MAX_PATH_SIZE;\n        opfsVfs.addOnDispose(\n          opfsVfs.$zName = wasm.allocCString(vfsName),\n          () => setPoolForVfs(opfsVfs.pointer, 0)\n        );\n        if (dVfs) {\n          opfsVfs.$xRandomness = dVfs.$xRandomness;\n          opfsVfs.$xSleep = dVfs.$xSleep;\n          dVfs.dispose();\n        }\n        if (!opfsVfs.$xRandomness && !vfsMethods.xRandomness) {\n          vfsMethods.xRandomness = function(pVfs, nOut, pOut) {\n            const heap = wasm.heap8u();\n            let i = 0;\n            const npOut = Number(pOut);\n            for (; i < nOut; ++i)\n              heap[npOut + i] = Math.random() * 255e3 & 255;\n            return i;\n          };\n        }\n        if (!opfsVfs.$xSleep && !vfsMethods.xSleep) {\n          vfsMethods.xSleep = (pVfs, ms) => 0;\n        }\n        sqlite32.vfs.installVfs({\n          vfs: { struct: opfsVfs, methods: vfsMethods }\n        });\n        return opfsVfs;\n      };\n      class OpfsSAHPool {\n        vfsDir;\n        #dhVfsRoot;\n        #dhOpaque;\n        #dhVfsParent;\n        #mapSAHToName = /* @__PURE__ */ new Map();\n        #mapFilenameToSAH = /* @__PURE__ */ new Map();\n        #availableSAH = /* @__PURE__ */ new Set();\n        #mapS3FileToOFile_ = /* @__PURE__ */ new Map();\n        #apBody = new Uint8Array(HEADER_CORPUS_SIZE);\n        #dvBody;\n        #cVfs;\n        #verbosity;\n        constructor(options = /* @__PURE__ */ Object.create(null)) {\n          this.#verbosity = options.verbosity ?? optionDefaults.verbosity;\n          this.vfsName = options.name || optionDefaults.name;\n          this.#cVfs = createOpfsVfs(this.vfsName);\n          setPoolForVfs(this.#cVfs.pointer, this);\n          this.vfsDir = options.directory || \".\" + this.vfsName;\n          this.#dvBody = new DataView(\n            this.#apBody.buffer,\n            this.#apBody.byteOffset\n          );\n          this.isReady = this.reset(\n            !!(options.clearOnInit ?? optionDefaults.clearOnInit)\n          ).then(() => {\n            if (this.$error) throw this.$error;\n            return this.getCapacity() ? Promise.resolve(void 0) : this.addCapacity(\n              options.initialCapacity || optionDefaults.initialCapacity\n            );\n          });\n        }\n        #logImpl(level, ...args) {\n          if (this.#verbosity > level)\n            loggers[level](this.vfsName + \":\", ...args);\n        }\n        log(...args) {\n          this.#logImpl(2, ...args);\n        }\n        warn(...args) {\n          this.#logImpl(1, ...args);\n        }\n        error(...args) {\n          this.#logImpl(0, ...args);\n        }\n        getVfs() {\n          return this.#cVfs;\n        }\n        getCapacity() {\n          return this.#mapSAHToName.size;\n        }\n        getFileCount() {\n          return this.#mapFilenameToSAH.size;\n        }\n        getFileNames() {\n          const rc = [];\n          for (const n of this.#mapFilenameToSAH.keys()) rc.push(n);\n          return rc;\n        }\n        async addCapacity(n) {\n          for (let i = 0; i < n; ++i) {\n            const name = getRandomName();\n            const h = await this.#dhOpaque.getFileHandle(name, {\n              create: true\n            });\n            const ah = await h.createSyncAccessHandle();\n            this.#mapSAHToName.set(ah, name);\n            this.setAssociatedPath(ah, \"\", 0);\n          }\n          return this.getCapacity();\n        }\n        async reduceCapacity(n) {\n          let nRm = 0;\n          for (const ah of Array.from(this.#availableSAH)) {\n            if (nRm === n || this.getFileCount() === this.getCapacity()) {\n              break;\n            }\n            const name = this.#mapSAHToName.get(ah);\n            ah.close();\n            await this.#dhOpaque.removeEntry(name);\n            this.#mapSAHToName.delete(ah);\n            this.#availableSAH.delete(ah);\n            ++nRm;\n          }\n          return nRm;\n        }\n        releaseAccessHandles() {\n          for (const ah of this.#mapSAHToName.keys()) ah.close();\n          this.#mapSAHToName.clear();\n          this.#mapFilenameToSAH.clear();\n          this.#availableSAH.clear();\n        }\n        async acquireAccessHandles(clearFiles = false) {\n          const files = [];\n          for await (const [name, h] of this.#dhOpaque) {\n            if (\"file\" === h.kind) {\n              files.push([name, h]);\n            }\n          }\n          return Promise.all(\n            files.map(async ([name, h]) => {\n              try {\n                const ah = await h.createSyncAccessHandle();\n                this.#mapSAHToName.set(ah, name);\n                if (clearFiles) {\n                  ah.truncate(HEADER_OFFSET_DATA);\n                  this.setAssociatedPath(ah, \"\", 0);\n                } else {\n                  const path = this.getAssociatedPath(ah);\n                  if (path) {\n                    this.#mapFilenameToSAH.set(path, ah);\n                  } else {\n                    this.#availableSAH.add(ah);\n                  }\n                }\n              } catch (e) {\n                this.storeErr(e);\n                this.releaseAccessHandles();\n                throw e;\n              }\n            })\n          );\n        }\n        getAssociatedPath(sah) {\n          sah.read(this.#apBody, { at: 0 });\n          const flags = this.#dvBody.getUint32(HEADER_OFFSET_FLAGS);\n          if (this.#apBody[0] && (flags & capi.SQLITE_OPEN_DELETEONCLOSE || (flags & PERSISTENT_FILE_TYPES) === 0)) {\n            warn(\n              `Removing file with unexpected flags ${flags.toString(16)}`,\n              this.#apBody\n            );\n            this.setAssociatedPath(sah, \"\", 0);\n            return \"\";\n          }\n          const fileDigest = new Uint32Array(HEADER_DIGEST_SIZE / 4);\n          sah.read(fileDigest, { at: HEADER_OFFSET_DIGEST });\n          const compDigest = this.computeDigest(this.#apBody, flags);\n          if (fileDigest.every((v2, i) => v2 === compDigest[i])) {\n            const pathBytes = this.#apBody.findIndex((v2) => 0 === v2);\n            if (0 === pathBytes) {\n              sah.truncate(HEADER_OFFSET_DATA);\n            }\n            return pathBytes ? textDecoder.decode(this.#apBody.subarray(0, pathBytes)) : \"\";\n          } else {\n            warn(\"Disassociating file with bad digest.\");\n            this.setAssociatedPath(sah, \"\", 0);\n            return \"\";\n          }\n        }\n        setAssociatedPath(sah, path, flags) {\n          const enc = textEncoder.encodeInto(path, this.#apBody);\n          if (HEADER_MAX_PATH_SIZE <= enc.written + 1) {\n            toss(\"Path too long:\", path);\n          }\n          if (path && flags) {\n            flags |= FLAG_COMPUTE_DIGEST_V2;\n          }\n          this.#apBody.fill(0, enc.written, HEADER_MAX_PATH_SIZE);\n          this.#dvBody.setUint32(HEADER_OFFSET_FLAGS, flags);\n          const digest = this.computeDigest(this.#apBody, flags);\n          sah.write(this.#apBody, { at: 0 });\n          sah.write(digest, { at: HEADER_OFFSET_DIGEST });\n          sah.flush();\n          if (path) {\n            this.#mapFilenameToSAH.set(path, sah);\n            this.#availableSAH.delete(sah);\n          } else {\n            sah.truncate(HEADER_OFFSET_DATA);\n            this.#availableSAH.add(sah);\n          }\n        }\n        computeDigest(byteArray, fileFlags) {\n          if (fileFlags & FLAG_COMPUTE_DIGEST_V2) {\n            let h1 = 3735928559;\n            let h2 = 1103547991;\n            for (const v2 of byteArray) {\n              h1 = Math.imul(h1 ^ v2, 2654435761);\n              h2 = Math.imul(h2 ^ v2, 104729);\n            }\n            return new Uint32Array([h1 >>> 0, h2 >>> 0]);\n          } else {\n            return new Uint32Array([0, 0]);\n          }\n        }\n        async reset(clearFiles) {\n          await this.isReady;\n          let h = await navigator.storage.getDirectory();\n          let prev, prevName;\n          for (const d of this.vfsDir.split(\"/\")) {\n            if (d) {\n              prev = h;\n              h = await h.getDirectoryHandle(d, { create: true });\n            }\n          }\n          this.#dhVfsRoot = h;\n          this.#dhVfsParent = prev;\n          this.#dhOpaque = await this.#dhVfsRoot.getDirectoryHandle(\n            OPAQUE_DIR_NAME,\n            { create: true }\n          );\n          this.releaseAccessHandles();\n          return this.acquireAccessHandles(clearFiles);\n        }\n        getPath(arg) {\n          if (wasm.isPtr(arg)) arg = wasm.cstrToJs(arg);\n          return (arg instanceof URL ? arg : new URL(arg, \"file://localhost/\")).pathname;\n        }\n        deletePath(path) {\n          const sah = this.#mapFilenameToSAH.get(path);\n          if (sah) {\n            this.#mapFilenameToSAH.delete(path);\n            this.setAssociatedPath(sah, \"\", 0);\n          }\n          return !!sah;\n        }\n        storeErr(e, code) {\n          if (e) {\n            e.sqlite3Rc = code || capi.SQLITE_IOERR;\n            this.error(e);\n          }\n          this.$error = e;\n          return code;\n        }\n        popErr() {\n          const rc = this.$error;\n          this.$error = void 0;\n          return rc;\n        }\n        nextAvailableSAH() {\n          const [rc] = this.#availableSAH.keys();\n          return rc;\n        }\n        getOFileForS3File(pFile) {\n          return this.#mapS3FileToOFile_.get(pFile);\n        }\n        mapS3FileToOFile(pFile, file) {\n          if (file) {\n            this.#mapS3FileToOFile_.set(pFile, file);\n            setPoolForPFile(pFile, this);\n          } else {\n            this.#mapS3FileToOFile_.delete(pFile);\n            setPoolForPFile(pFile, false);\n          }\n        }\n        hasFilename(name) {\n          return this.#mapFilenameToSAH.has(name);\n        }\n        getSAHForPath(path) {\n          return this.#mapFilenameToSAH.get(path);\n        }\n        async removeVfs() {\n          if (!this.#cVfs.pointer || !this.#dhOpaque) return false;\n          capi.sqlite3_vfs_unregister(this.#cVfs.pointer);\n          this.#cVfs.dispose();\n          delete initPromises[this.vfsName];\n          try {\n            this.releaseAccessHandles();\n            await this.#dhVfsRoot.removeEntry(OPAQUE_DIR_NAME, {\n              recursive: true\n            });\n            this.#dhOpaque = void 0;\n            await this.#dhVfsParent.removeEntry(this.#dhVfsRoot.name, {\n              recursive: true\n            });\n            this.#dhVfsRoot = this.#dhVfsParent = void 0;\n          } catch (e) {\n            sqlite32.config.error(\n              this.vfsName,\n              \"removeVfs() failed with no recovery strategy:\",\n              e\n            );\n          }\n          return true;\n        }\n        pauseVfs() {\n          if (this.#mapS3FileToOFile_.size > 0) {\n            sqlite32.SQLite3Error.toss(\n              capi.SQLITE_MISUSE,\n              \"Cannot pause VFS\",\n              this.vfsName,\n              \"because it has opened files.\"\n            );\n          }\n          if (this.#mapSAHToName.size > 0) {\n            capi.sqlite3_vfs_unregister(this.vfsName);\n            this.releaseAccessHandles();\n          }\n          return this;\n        }\n        isPaused() {\n          return 0 === this.#mapSAHToName.size;\n        }\n        async unpauseVfs() {\n          if (0 === this.#mapSAHToName.size) {\n            return this.acquireAccessHandles(false).then(\n              () => capi.sqlite3_vfs_register(this.#cVfs, 0),\n              this\n            );\n          }\n          return this;\n        }\n        exportFile(name) {\n          const sah = this.#mapFilenameToSAH.get(name) || toss(\"File not found:\", name);\n          const n = sah.getSize() - HEADER_OFFSET_DATA;\n          const b = new Uint8Array(n > 0 ? n : 0);\n          if (n > 0) {\n            const nRead = sah.read(b, { at: HEADER_OFFSET_DATA });\n            if (nRead != n) {\n              toss(\"Expected to read \" + n + \" bytes but read \" + nRead + \".\");\n            }\n          }\n          return b;\n        }\n        async importDbChunked(name, callback) {\n          const sah = this.#mapFilenameToSAH.get(name) || this.nextAvailableSAH() || toss(\"No available handles to import to.\");\n          sah.truncate(0);\n          let nWrote = 0, chunk, checkedHeader = false, err2 = false;\n          try {\n            while (void 0 !== (chunk = await callback())) {\n              if (chunk instanceof ArrayBuffer) chunk = new Uint8Array(chunk);\n              if (!checkedHeader && 0 === nWrote && chunk.byteLength >= 15) {\n                util.affirmDbHeader(chunk);\n                checkedHeader = true;\n              }\n              sah.write(chunk, { at: HEADER_OFFSET_DATA + nWrote });\n              nWrote += chunk.byteLength;\n            }\n            if (nWrote < 512 || 0 !== nWrote % 512) {\n              toss(\n                \"Input size\",\n                nWrote,\n                \"is not correct for an SQLite database.\"\n              );\n            }\n            if (!checkedHeader) {\n              const header = new Uint8Array(20);\n              sah.read(header, { at: 0 });\n              util.affirmDbHeader(header);\n            }\n            sah.write(new Uint8Array([1, 1]), {\n              at: HEADER_OFFSET_DATA + 18\n            });\n          } catch (e) {\n            this.setAssociatedPath(sah, \"\", 0);\n            throw e;\n          }\n          this.setAssociatedPath(sah, name, capi.SQLITE_OPEN_MAIN_DB);\n          return nWrote;\n        }\n        importDb(name, bytes) {\n          if (bytes instanceof ArrayBuffer) bytes = new Uint8Array(bytes);\n          else if (bytes instanceof Function)\n            return this.importDbChunked(name, bytes);\n          const sah = this.#mapFilenameToSAH.get(name) || this.nextAvailableSAH() || toss(\"No available handles to import to.\");\n          const n = bytes.byteLength;\n          if (n < 512 || n % 512 != 0) {\n            toss(\"Byte array size is invalid for an SQLite db.\");\n          }\n          const header = \"SQLite format 3\";\n          for (let i = 0; i < header.length; ++i) {\n            if (header.charCodeAt(i) !== bytes[i]) {\n              toss(\"Input does not contain an SQLite database header.\");\n            }\n          }\n          const nWrote = sah.write(bytes, { at: HEADER_OFFSET_DATA });\n          if (nWrote != n) {\n            this.setAssociatedPath(sah, \"\", 0);\n            toss(\"Expected to write \" + n + \" bytes but wrote \" + nWrote + \".\");\n          } else {\n            sah.write(new Uint8Array([1, 1]), { at: HEADER_OFFSET_DATA + 18 });\n            this.setAssociatedPath(sah, name, capi.SQLITE_OPEN_MAIN_DB);\n          }\n          return nWrote;\n        }\n      }\n      class OpfsSAHPoolUtil {\n        #p;\n        constructor(sahPool) {\n          this.#p = sahPool;\n          this.vfsName = sahPool.vfsName;\n        }\n        async addCapacity(n) {\n          return this.#p.addCapacity(n);\n        }\n        async reduceCapacity(n) {\n          return this.#p.reduceCapacity(n);\n        }\n        getCapacity() {\n          return this.#p.getCapacity(this.#p);\n        }\n        getFileCount() {\n          return this.#p.getFileCount();\n        }\n        getFileNames() {\n          return this.#p.getFileNames();\n        }\n        async reserveMinimumCapacity(min) {\n          const c = this.#p.getCapacity();\n          return c < min ? this.#p.addCapacity(min - c) : c;\n        }\n        exportFile(name) {\n          return this.#p.exportFile(name);\n        }\n        importDb(name, bytes) {\n          return this.#p.importDb(name, bytes);\n        }\n        async wipeFiles() {\n          return this.#p.reset(true);\n        }\n        unlink(filename) {\n          return this.#p.deletePath(filename);\n        }\n        async removeVfs() {\n          return this.#p.removeVfs();\n        }\n        pauseVfs() {\n          this.#p.pauseVfs();\n          return this;\n        }\n        async unpauseVfs() {\n          return this.#p.unpauseVfs().then(() => this);\n        }\n        isPaused() {\n          return this.#p.isPaused();\n        }\n      }\n      const apiVersionCheck = async () => {\n        const dh = await navigator.storage.getDirectory();\n        const fn = \".opfs-sahpool-sync-check-\" + getRandomName();\n        const fh = await dh.getFileHandle(fn, { create: true });\n        const ah = await fh.createSyncAccessHandle();\n        const close = ah.close();\n        await close;\n        await dh.removeEntry(fn);\n        if (close?.then) {\n          toss(\n            \"The local OPFS API is too old for opfs-sahpool:\",\n            \"it has an async FileSystemSyncAccessHandle.close() method.\"\n          );\n        }\n        return true;\n      };\n      sqlite32.installOpfsSAHPoolVfs = async function(options = /* @__PURE__ */ Object.create(null)) {\n        options = Object.assign(\n          /* @__PURE__ */ Object.create(null),\n          optionDefaults,\n          options || {}\n        );\n        const vfsName = options.name;\n        if (options.$testThrowPhase1) {\n          throw options.$testThrowPhase1;\n        }\n        if (initPromises[vfsName]) {\n          try {\n            const p = await initPromises[vfsName];\n            return p;\n          } catch (e) {\n            if (options.forceReinitIfPreviouslyFailed) {\n              delete initPromises[vfsName];\n            } else {\n              throw e;\n            }\n          }\n        }\n        if (!globalThis.FileSystemHandle || !globalThis.FileSystemDirectoryHandle || !globalThis.FileSystemFileHandle || !globalThis.FileSystemFileHandle.prototype.createSyncAccessHandle || !navigator?.storage?.getDirectory) {\n          return initPromises[vfsName] = Promise.reject(\n            new Error(\"Missing required OPFS APIs.\")\n          );\n        }\n        return initPromises[vfsName] = apiVersionCheck().then(async function() {\n          if (options.$testThrowPhase2) {\n            throw options.$testThrowPhase2;\n          }\n          const thePool = new OpfsSAHPool(options);\n          return thePool.isReady.then(async () => {\n            const poolUtil = new OpfsSAHPoolUtil(thePool);\n            if (sqlite32.oo1) {\n              const oo1 = sqlite32.oo1;\n              const theVfs = thePool.getVfs();\n              const OpfsSAHPoolDb = function(...args) {\n                const opt = oo1.DB.dbCtorHelper.normalizeArgs(...args);\n                opt.vfs = theVfs.$zName;\n                oo1.DB.dbCtorHelper.call(this, opt);\n              };\n              OpfsSAHPoolDb.prototype = Object.create(oo1.DB.prototype);\n              poolUtil.OpfsSAHPoolDb = OpfsSAHPoolDb;\n            }\n            thePool.log(\"VFS initialized.\");\n            return poolUtil;\n          }).catch(async (e) => {\n            await thePool.removeVfs().catch(() => {\n            });\n            throw e;\n          });\n        }).catch((err2) => {\n          return initPromises[vfsName] = Promise.reject(err2);\n        });\n      };\n    });\n    \"use strict\";\n    if (\"undefined\" === typeof EmscriptenModule) {\n      console.warn(\n        \"This is not running in the context of Module.runSQLite3PostLoadInit()\"\n      );\n      throw new Error(\n        \"sqlite3-api-cleanup.js expects to be running in the context of its Emscripten module loader.\"\n      );\n    }\n    try {\n      const bootstrapConfig = Object.assign(\n        /* @__PURE__ */ Object.create(null),\n        globalThis.sqlite3ApiBootstrap.defaultConfig,\n        globalThis.sqlite3ApiConfig || {},\n        {\n          memory: \"undefined\" !== typeof wasmMemory ? wasmMemory : EmscriptenModule[\"wasmMemory\"],\n          exports: \"undefined\" !== typeof wasmExports ? wasmExports : Object.prototype.hasOwnProperty.call(\n            EmscriptenModule,\n            \"wasmExports\"\n          ) ? EmscriptenModule[\"wasmExports\"] : EmscriptenModule[\"asm\"]\n        }\n      );\n      bootstrapConfig.wasmPtrIR = \"number\" === typeof bootstrapConfig.exports.sqlite3_libversion() ? \"i32\" : \"i64\";\n      const sIMS = sqlite3InitScriptInfo;\n      sIMS.debugModule(\"Bootstrapping lib config\", sIMS);\n      const p = globalThis.sqlite3ApiBootstrap(bootstrapConfig);\n      delete globalThis.sqlite3ApiBootstrap;\n      return p;\n    } catch (e) {\n      console.error(\"sqlite3ApiBootstrap() error:\", e);\n      throw e;\n    }\n    throw new Error(\"Maintenance required: this line should never be reached\");\n  };\n  if (runtimeInitialized) {\n    moduleRtn = Module;\n  } else {\n    moduleRtn = new Promise((resolve, reject) => {\n      readyPromiseResolve = resolve;\n      readyPromiseReject = reject;\n    });\n  }\n  return moduleRtn;\n}\nvar toExportForESM = function() {\n  const originalInit = sqlite3InitModule;\n  if (!originalInit) {\n    throw new Error(\n      \"Expecting globalThis.sqlite3InitModule to be defined by the Emscripten build.\"\n    );\n  }\n  const sIMS = globalThis.sqlite3InitModuleState = Object.assign(\n    /* @__PURE__ */ Object.create(null),\n    {\n      moduleScript: globalThis?.document?.currentScript,\n      isWorker: \"undefined\" !== typeof WorkerGlobalScope,\n      location: globalThis.location,\n      urlParams: globalThis?.location?.href ? new URL(globalThis.location.href).searchParams : new URLSearchParams(),\n      wasmFilename: \"sqlite3.wasm\"\n    }\n  );\n  sIMS.debugModule = sIMS.urlParams.has(\"sqlite3.debugModule\") ? (...args) => console.warn(\"sqlite3.debugModule:\", ...args) : () => {\n  };\n  if (sIMS.urlParams.has(\"sqlite3.dir\")) {\n    sIMS.sqlite3Dir = sIMS.urlParams.get(\"sqlite3.dir\") + \"/\";\n  } else if (sIMS.moduleScript) {\n    const li = sIMS.moduleScript.src.split(\"/\");\n    li.pop();\n    sIMS.sqlite3Dir = li.join(\"/\") + \"/\";\n  }\n  const sIM = globalThis.sqlite3InitModule = function ff(...args) {\n    return originalInit(...args).then((EmscriptenModule) => {\n      sIMS.debugModule(\"sqlite3InitModule() sIMS =\", sIMS);\n      sIMS.debugModule(\n        \"sqlite3InitModule() EmscriptenModule =\",\n        EmscriptenModule\n      );\n      const s = EmscriptenModule.runSQLite3PostLoadInit(\n        sIMS,\n        EmscriptenModule,\n        !!ff.__isUnderTest\n      );\n      sIMS.debugModule(\"sqlite3InitModule() sqlite3 =\", s);\n      return s;\n    }).catch((e) => {\n      console.error(\"Exception loading sqlite3 module:\", e);\n      throw e;\n    });\n  };\n  sIM.ready = originalInit.ready;\n  if (sIMS.moduleScript) {\n    let src = sIMS.moduleScript.src.split(\"/\");\n    src.pop();\n    sIMS.scriptDir = src.join(\"/\") + \"/\";\n  }\n  sIMS.debugModule(\"extern-post-js.c-pp.js sqlite3InitModuleState =\", sIMS);\n  return sIM;\n}();\nsqlite3InitModule = toExportForESM;\nvar sqlite3_default = sqlite3InitModule;\n\n// node_modules/@sqlite.org/sqlite-wasm/sqlite-wasm/jswasm/sqlite3-worker1-promiser.mjs\nglobalThis.sqlite3Worker1Promiser = function callee(config = callee.defaultConfig) {\n  if (1 === arguments.length && \"function\" === typeof arguments[0]) {\n    const f = config;\n    config = Object.assign(/* @__PURE__ */ Object.create(null), callee.defaultConfig);\n    config.onready = f;\n  } else {\n    config = Object.assign(/* @__PURE__ */ Object.create(null), callee.defaultConfig, config);\n  }\n  const handlerMap = /* @__PURE__ */ Object.create(null);\n  const noop = function() {\n  };\n  const err = config.onerror || noop;\n  const debug = config.debug || noop;\n  const idTypeMap = config.generateMessageId ? void 0 : /* @__PURE__ */ Object.create(null);\n  const genMsgId = config.generateMessageId || function(msg) {\n    return msg.type + \"#\" + (idTypeMap[msg.type] = (idTypeMap[msg.type] || 0) + 1);\n  };\n  const toss = (...args) => {\n    throw new Error(args.join(\" \"));\n  };\n  if (!config.worker) config.worker = callee.defaultConfig.worker;\n  if (\"function\" === typeof config.worker) config.worker = config.worker();\n  let dbId;\n  let promiserFunc;\n  config.worker.onmessage = function(ev) {\n    ev = ev.data;\n    debug(\"worker1.onmessage\", ev);\n    let msgHandler = handlerMap[ev.messageId];\n    if (!msgHandler) {\n      if (ev && \"sqlite3-api\" === ev.type && \"worker1-ready\" === ev.result) {\n        if (config.onready) config.onready(promiserFunc);\n        return;\n      }\n      msgHandler = handlerMap[ev.type];\n      if (msgHandler && msgHandler.onrow) {\n        msgHandler.onrow(ev);\n        return;\n      }\n      if (config.onunhandled) config.onunhandled(arguments[0]);\n      else err(\"sqlite3Worker1Promiser() unhandled worker message:\", ev);\n      return;\n    }\n    delete handlerMap[ev.messageId];\n    switch (ev.type) {\n      case \"error\":\n        msgHandler.reject(ev);\n        return;\n      case \"open\":\n        if (!dbId) dbId = ev.dbId;\n        break;\n      case \"close\":\n        if (ev.dbId === dbId) dbId = void 0;\n        break;\n      default:\n        break;\n    }\n    try {\n      msgHandler.resolve(ev);\n    } catch (e) {\n      msgHandler.reject(e);\n    }\n  };\n  return promiserFunc = function() {\n    let msg;\n    if (1 === arguments.length) {\n      msg = arguments[0];\n    } else if (2 === arguments.length) {\n      msg = /* @__PURE__ */ Object.create(null);\n      msg.type = arguments[0];\n      msg.args = arguments[1];\n      msg.dbId = msg.args.dbId;\n    } else {\n      toss(\"Invalid arguments for sqlite3Worker1Promiser()-created factory.\");\n    }\n    if (!msg.dbId && msg.type !== \"open\") msg.dbId = dbId;\n    msg.messageId = genMsgId(msg);\n    msg.departureTime = performance.now();\n    const proxy = /* @__PURE__ */ Object.create(null);\n    proxy.message = msg;\n    let rowCallbackId;\n    if (\"exec\" === msg.type && msg.args) {\n      if (\"function\" === typeof msg.args.callback) {\n        rowCallbackId = msg.messageId + \":row\";\n        proxy.onrow = msg.args.callback;\n        msg.args.callback = rowCallbackId;\n        handlerMap[rowCallbackId] = proxy;\n      } else if (\"string\" === typeof msg.args.callback) {\n        toss(\n          \"exec callback may not be a string when using the Promise interface.\"\n        );\n      }\n    }\n    let p = new Promise(function(resolve, reject) {\n      proxy.resolve = resolve;\n      proxy.reject = reject;\n      handlerMap[msg.messageId] = proxy;\n      debug(\n        \"Posting\",\n        msg.type,\n        \"message to Worker dbId=\" + (dbId || \"default\") + \":\",\n        msg\n      );\n      config.worker.postMessage(msg);\n    });\n    if (rowCallbackId) p = p.finally(() => delete handlerMap[rowCallbackId]);\n    return p;\n  };\n};\nglobalThis.sqlite3Worker1Promiser.defaultConfig = {\n  worker: function() {\n    return new Worker(new URL(\"sqlite3-worker1.js\", import.meta.url));\n  },\n  onerror: (...args) => console.error(\"worker1 promiser error\", ...args)\n};\nglobalThis.sqlite3Worker1Promiser.v2 = function callee2(config = callee2.defaultConfig) {\n  let oldFunc;\n  if (\"function\" == typeof config) {\n    oldFunc = config;\n    config = {};\n  } else if (\"function\" === typeof config?.onready) {\n    oldFunc = config.onready;\n    delete config.onready;\n  }\n  const promiseProxy = /* @__PURE__ */ Object.create(null);\n  config = Object.assign(config || /* @__PURE__ */ Object.create(null), {\n    onready: async function(func) {\n      try {\n        if (oldFunc) await oldFunc(func);\n        promiseProxy.resolve(func);\n      } catch (e) {\n        promiseProxy.reject(e);\n      }\n    }\n  });\n  const p = new Promise(function(resolve, reject) {\n    promiseProxy.resolve = resolve;\n    promiseProxy.reject = reject;\n  });\n  try {\n    this.original(config);\n  } catch (e) {\n    promiseProxy.reject(e);\n  }\n  return p;\n}.bind({\n  original: sqlite3Worker1Promiser\n});\nglobalThis.sqlite3Worker1Promiser.v2.defaultConfig = globalThis.sqlite3Worker1Promiser.defaultConfig;\nvar sqlite3_worker1_promiser_default = sqlite3Worker1Promiser.v2;\n\n// node_modules/@sqlite.org/sqlite-wasm/index.mjs\nvar sqlite3Worker1Promiser2 = globalThis.sqlite3Worker1Promiser;\nvar sqlite_wasm_default = sqlite3_default;\n\n// worker/index.ts\nvar OPFS_VFS = \"opfs\";\nvar sqlite3 = null;\nvar databases = /* @__PURE__ */ new Map();\nvar lastProcessedSql = /* @__PURE__ */ new Map();\nvar lastAffectedRows = /* @__PURE__ */ new Map();\nasync function initSqlite() {\n  console.log(\"[Worker] Initializing SQLite WASM module...\");\n  const module = await sqlite_wasm_default({\n    print: console.log,\n    printErr: console.error\n  });\n  sqlite3 = module;\n  console.log(\"[Worker] SQLite WASM module initialized successfully\");\n  console.log(\"[Worker] OPFS directory:\", sqlite3?.capi.sqlite3_wasmfs_opfs_dir?.() || \"opfs\");\n}\nfunction createDb(dbName) {\n  console.log(`[Worker] Creating database: ${dbName}`);\n  if (!sqlite3) {\n    throw new Error(\"SQLite not initialized\");\n  }\n  if (databases.has(dbName)) {\n    throw new Error(`Database ${dbName} already exists`);\n  }\n  const db = new sqlite3.oo1.OpfsDb(`${OPFS_VFS}/${dbName}.db`);\n  databases.set(dbName, db);\n  initializeSchema(db);\n  console.log(`[Worker] Database ${dbName} created successfully`);\n  return db;\n}\nfunction exportDatabase(db) {\n  const statements = [];\n  const tablesResult = execute(db, \"SELECT name, sql FROM sqlite_master WHERE type='table' AND name NOT LIKE '_syncable_%' AND name NOT LIKE 'sqlite_%'\");\n  for (const table of tablesResult.rows) {\n    const tableName = table.name;\n    const createSql = table.sql;\n    if (createSql) {\n      statements.push(createSql + \";\");\n    }\n    const rowsResult = execute(db, `SELECT * FROM ${tableName}`);\n    for (const row of rowsResult.rows) {\n      const rowObj = row;\n      const columns = Object.keys(rowObj);\n      const values = columns.map((col) => {\n        const v2 = rowObj[col];\n        if (v2 === null) return \"NULL\";\n        if (typeof v2 === \"string\") return `'${String(v2).replace(/'/g, \"''\")}'`;\n        return String(v2);\n      });\n      statements.push(`INSERT INTO ${tableName} (${columns.join(\", \")}) VALUES (${values.join(\", \")});`);\n    }\n  }\n  const sql = statements.join(\"\\n\");\n  return new TextEncoder().encode(sql);\n}\nfunction importDatabase(db, data) {\n  if (data.length === 0) {\n    throw new Error(\"Byte array size 0 is invalid for an SQLite3 db.\");\n  }\n  const sql = new TextDecoder().decode(data);\n  const statements = sql.split(\";\").map((s) => s.trim()).filter((s) => s.length > 0);\n  for (const stmt of statements) {\n    try {\n      if (stmt.toUpperCase().startsWith(\"CREATE TABLE\")) {\n        const match = stmt.match(/CREATE\\s+TABLE\\s+(?:IF\\s+NOT\\s+EXISTS\\s+)?[\"`]?(\\w+)[\"`]?/i);\n        if (match) {\n          const tableName = match[1];\n          const exists = execute(db, `SELECT name FROM sqlite_master WHERE type='table' AND name='${tableName}'`);\n          if (exists.rows.length > 0) {\n            continue;\n          }\n        }\n        db.exec(stmt + \";\");\n      } else if (stmt.toUpperCase().startsWith(\"INSERT\")) {\n        const modified = stmt.replace(/^INSERT\\s+INTO/i, \"INSERT OR REPLACE INTO\");\n        db.exec(modified + \";\");\n      } else {\n        db.exec(stmt + \";\");\n      }\n    } catch (e) {\n      console.warn(\"Import statement failed:\", stmt, e);\n    }\n  }\n}\nfunction initializeSchema(db) {\n  db.exec(`\n    CREATE TABLE IF NOT EXISTS _syncable_metadata (\n      key TEXT PRIMARY KEY,\n      value TEXT\n    )\n  `);\n}\nfunction execute(db, sql, params) {\n  const stmt = db.prepare(sql);\n  if (params && params.length > 0) {\n    stmt.bind(params);\n  }\n  const rows = [];\n  const columns = [];\n  while (stmt.step()) {\n    const numColumns = stmt.columnCount;\n    const row = {};\n    for (let i = 0; i < numColumns; i++) {\n      const columnName = stmt.getColumnName(i);\n      row[columnName] = stmt.get(i);\n    }\n    rows.push(row);\n    if (columns.length === 0) {\n      for (let i = 0; i < numColumns; i++) {\n        columns.push(stmt.getColumnName(i));\n      }\n    }\n  }\n  stmt.finalize();\n  return { rows, columns };\n}\nfunction injectColumns(sql) {\n  const createTableMatch = sql.match(/CREATE\\s+TABLE\\s+(?:IF\\s+NOT\\s+EXISTS\\s+)?[\"`]?(\\w+)[\"`]?\\s*\\(([^)]+)\\)/i);\n  if (!createTableMatch) {\n    return { sql, hasUserColumns: false };\n  }\n  const fullMatch = createTableMatch[0];\n  const tableName = createTableMatch[1];\n  const columnsStr = createTableMatch[2].trim();\n  const columns = columnsStr.split(\",\").map((c) => c.trim());\n  let hasId = false;\n  let hasUpdatedAt = false;\n  let hasDeleted = false;\n  for (const c of columns) {\n    const lowerC = c.toLowerCase();\n    if (/^\\s*[\"`]?id[\"`]?\\s+/.test(c) || lowerC.includes(\"primary key\")) {\n      hasId = true;\n    }\n    if (lowerC.includes(\"updated_at\")) {\n      hasUpdatedAt = true;\n    }\n    if (lowerC.includes(\"deleted\")) {\n      hasDeleted = true;\n    }\n  }\n  const hasUserColumns = hasId || hasUpdatedAt || hasDeleted;\n  if (hasUserColumns) {\n    return { sql, hasUserColumns: true };\n  }\n  const cleanColumns = columns.map((c) => c.replace(/\\s+/g, \" \").trim()).join(\", \");\n  const systemColumns = \"id TEXT PRIMARY KEY, updated_at INTEGER NOT NULL, deleted INTEGER NOT NULL DEFAULT 0\";\n  const isIfNotExists = /CREATE\\s+TABLE\\s+IF\\s+NOT\\s+EXISTS/i.test(sql);\n  const ifNotExistsStr = isIfNotExists ? \"IF NOT EXISTS \" : \"\";\n  const newSql = `CREATE TABLE ${ifNotExistsStr}${tableName} (${cleanColumns}, ${systemColumns})`;\n  return { sql: newSql, hasUserColumns: false };\n}\nvar SYSTEM_COLUMNS = /* @__PURE__ */ new Set([\"id\", \"updated_at\", \"deleted\"]);\nfunction isSystemColumn(col) {\n  const cleanCol = col.replace(/[\"`]/g, \"\").trim().toLowerCase();\n  return SYSTEM_COLUMNS.has(cleanCol);\n}\nfunction rewriteInsert(sql, tableName, params) {\n  const insertMatch = sql.match(/INSERT\\s+INTO\\s+[\"`]?(\\w+)[\"`]?\\s*\\(([^)]+)\\)\\s*VALUES\\s*\\(([^)]+)\\)/i);\n  if (!insertMatch) {\n    return { sql, params: params || [], rowId: \"\" };\n  }\n  const originalColumns = insertMatch[2].split(\",\").map((c) => c.trim());\n  const valuesStr = insertMatch[3].split(\",\").map((c) => c.trim());\n  const userColumns = [];\n  const userValues = [];\n  const userParams = [];\n  let paramIndex = 0;\n  for (let i = 0; i < originalColumns.length; i++) {\n    const col = originalColumns[i];\n    const val = valuesStr[i];\n    const isPlaceholder = val === \"?\";\n    if (!isSystemColumn(col)) {\n      userColumns.push(col);\n      if (isPlaceholder) {\n        userValues.push(\"?\");\n        if (params && paramIndex < params.length) {\n          userParams.push(params[paramIndex]);\n        }\n      } else {\n        userValues.push(val);\n      }\n    }\n    if (isPlaceholder) {\n      paramIndex++;\n    }\n  }\n  const uuid = crypto.randomUUID();\n  const timestamp = Date.now();\n  const newColumns = [...userColumns, \"id\", \"updated_at\", \"deleted\"].join(\", \");\n  const allValues = [...userValues, \"?\", \"?\", \"?\"].join(\", \");\n  const newSql = `INSERT INTO ${tableName} (${newColumns}) VALUES (${allValues})`;\n  const newParams = [...userParams, uuid, timestamp, 0];\n  return { sql: newSql, params: newParams, rowId: uuid };\n}\nfunction rewriteUpdate(sql, tableName, params) {\n  const updateMatch = sql.match(/UPDATE\\s+[\"`]?(\\w+)[\"`]?\\s+SET\\s+(.+?)(?:\\s+WHERE\\s+(.+))?$/i);\n  if (!updateMatch) {\n    return { sql, params: params || [] };\n  }\n  const setClause = updateMatch[2].trim();\n  const whereClause = updateMatch[3] || \"\";\n  const timestamp = Date.now();\n  const setParts = setClause.split(\",\").map((part) => part.trim());\n  const filteredParts = [];\n  const setParams = [];\n  const whereParams = [];\n  let paramIndex = 0;\n  for (const part of setParts) {\n    const eqIndex = part.indexOf(\"=\");\n    if (eqIndex === -1) continue;\n    const col = part.substring(0, eqIndex).trim();\n    const val = part.substring(eqIndex + 1).trim();\n    const isPlaceholder = val === \"?\";\n    if (!isSystemColumn(col)) {\n      filteredParts.push(part);\n      if (isPlaceholder && params) {\n        setParams.push(params[paramIndex]);\n      }\n    }\n    if (isPlaceholder) {\n      paramIndex++;\n    }\n  }\n  if (whereClause && params) {\n    const wherePlaceholders = (whereClause.match(/\\?/g) || []).length;\n    for (let i = 0; i < wherePlaceholders && paramIndex < params.length; i++) {\n      whereParams.push(params[paramIndex]);\n      paramIndex++;\n    }\n  }\n  const newSetClause = [...filteredParts, `updated_at = ?`].join(\", \");\n  const finalParams = [...setParams, timestamp, ...whereParams];\n  const newSql = `UPDATE ${tableName} SET ${newSetClause}${whereClause ? ` WHERE ${whereClause}` : \"\"}`;\n  return { sql: newSql, params: finalParams };\n}\nfunction rewriteDelete(sql, tableName, params) {\n  const deleteMatch = sql.match(/DELETE\\s+FROM\\s+[\"`]?(\\w+)[\"`]?\\s*(?:WHERE\\s+(.+))?/i);\n  if (!deleteMatch) {\n    return { sql, params: params || [] };\n  }\n  const timestamp = Date.now();\n  const whereClause = deleteMatch[2] || \"\";\n  const newSql = `UPDATE ${tableName} SET deleted = 1, updated_at = ?${whereClause ? ` WHERE ${whereClause}` : \"\"}`;\n  const newParams = [timestamp, ...params || []];\n  return { sql: newSql, params: newParams };\n}\nfunction rewriteQuery(sql) {\n  if (sql.trim().toUpperCase().startsWith(\"DELETE\")) {\n    return sql;\n  }\n  if (!/\\bFROM\\b/i.test(sql)) {\n    return sql;\n  }\n  const hasWhere = /\\bWHERE\\b/i.test(sql);\n  if (hasWhere) {\n    return sql.replace(/\\bWHERE\\b/i, \"WHERE deleted = 0 AND\");\n  } else {\n    const insertPoint = sql.search(/\\b(ORDER\\s+BY|GROUP\\s+BY|LIMIT|HAVING|$)/i);\n    if (insertPoint > 0) {\n      return sql.slice(0, insertPoint) + \" WHERE deleted = 0 \" + sql.slice(insertPoint);\n    }\n    return sql + \" WHERE deleted = 0\";\n  }\n}\nfunction processSql(sql, params) {\n  const upperSql = sql.toUpperCase().trim();\n  if (upperSql.startsWith(\"INSERT\")) {\n    const insertMatch = sql.match(/INSERT\\s+INTO\\s+[\"`]?(\\w+)[\"`]?/i);\n    if (insertMatch) {\n      const result = rewriteInsert(sql, insertMatch[1], params);\n      return {\n        sql: result.sql,\n        params: result.params,\n        table: insertMatch[1],\n        rowId: result.rowId,\n        isMutation: true\n      };\n    }\n  }\n  if (upperSql.startsWith(\"UPDATE\")) {\n    const updateMatch = sql.match(/UPDATE\\s+[\"`]?(\\w+)[\"`]?/i);\n    if (updateMatch) {\n      const result = rewriteUpdate(sql, updateMatch[1], params);\n      return {\n        sql: result.sql,\n        params: result.params,\n        table: updateMatch[1],\n        isMutation: true\n      };\n    }\n  }\n  if (upperSql.startsWith(\"DELETE\")) {\n    const deleteMatch = sql.match(/DELETE\\s+FROM\\s+[\"`]?(\\w+)[\"`]?/i);\n    if (deleteMatch) {\n      const result = rewriteDelete(sql, deleteMatch[1], params);\n      return {\n        sql: result.sql,\n        params: result.params,\n        table: deleteMatch[1],\n        isMutation: true\n      };\n    }\n  }\n  return { sql: rewriteQuery(sql), params: params || [], isMutation: false };\n}\nasync function mergeDatabasesAsync(localDb, remoteData, sqlite3Module) {\n  const tempDb = new sqlite3Module.oo1.DB(\":memory:\");\n  try {\n    const remoteDb = new sqlite3Module.oo1.DB(\":memory:\");\n    const sql = new TextDecoder().decode(remoteData);\n    remoteDb.exec(sql);\n    const localTables = execute(localDb, \"SELECT name FROM sqlite_master WHERE type='table' AND name NOT LIKE '_syncable_%'\").rows.map((r) => r.name);\n    const remoteTables = execute(remoteDb, \"SELECT name FROM sqlite_master WHERE type='table' AND name NOT LIKE '_syncable_%'\").rows.map((r) => r.name);\n    const allTables = /* @__PURE__ */ new Set([...localTables, ...remoteTables]);\n    for (const tableName of allTables) {\n      await mergeTable(localDb, remoteDb, tableName);\n    }\n    remoteDb.close();\n  } finally {\n    tempDb.close();\n  }\n}\nasync function mergeTable(localDb, remoteDb, tableName) {\n  const localRowsResult = execute(localDb, `SELECT * FROM ${tableName}`);\n  const remoteRowsResult = execute(remoteDb, `SELECT * FROM ${tableName}`);\n  const rowsById = /* @__PURE__ */ new Map();\n  for (const row of localRowsResult.rows) {\n    const id = row.id;\n    if (id) {\n      rowsById.set(id, { source: \"local\", row });\n    }\n  }\n  for (const row of remoteRowsResult.rows) {\n    const id = row.id;\n    if (!id) continue;\n    const existing = rowsById.get(id);\n    const remoteTimestamp = row.updated_at || 0;\n    if (!existing) {\n      rowsById.set(id, { source: \"remote\", row });\n    } else {\n      const localTimestamp = existing.row.updated_at || 0;\n      if (remoteTimestamp > localTimestamp) {\n        rowsById.set(id, { source: \"remote\", row });\n      }\n    }\n  }\n  const columns = localRowsResult.columns.filter(\n    (c) => c !== \"id\" && c !== \"updated_at\" && c !== \"deleted\"\n  );\n  for (const [id, entry] of rowsById) {\n    const row = entry.row;\n    const isDeleted = row.deleted === 1 || row.deleted === true;\n    if (isDeleted) {\n      continue;\n    }\n    const timestamp = row.updated_at || Date.now();\n    const existingRowResult = execute(localDb, `SELECT id FROM ${tableName} WHERE id = ?`, [id]);\n    const userColumns = columns;\n    const userValues = userColumns.map((c) => {\n      const v2 = row[c];\n      if (typeof v2 === \"string\") return `'${String(v2).replace(/'/g, \"''\")}'`;\n      if (v2 === null) return \"NULL\";\n      return String(v2);\n    });\n    if (existingRowResult.rows.length > 0) {\n      const updateColumns = userColumns.map((c) => `${c} = '${String(row[c] || \"\").replace(/'/g, \"''\")}'`).join(\", \");\n      localDb.exec(`UPDATE ${tableName} SET ${updateColumns}, updated_at = ${timestamp} WHERE id = '${id}'`);\n    } else {\n      const allColumns = [\"id\", ...userColumns, \"updated_at\", \"deleted\"];\n      const allValues = [`'${id}'`, ...userValues, String(timestamp), \"0\"];\n      localDb.exec(`INSERT INTO ${tableName} (${allColumns.join(\", \")}) VALUES (${allValues.join(\", \")})`);\n    }\n  }\n}\nasync function handleRequest(request) {\n  const { id, type, dbName, args } = request;\n  try {\n    let result;\n    switch (type) {\n      case \"init\": {\n        await initSqlite();\n        result = { opfsDir: sqlite3?.capi.sqlite3_wasmfs_opfs_dir?.() || \"opfs\" };\n        break;\n      }\n      case \"createDb\": {\n        createDb(dbName);\n        result = { success: true };\n        break;\n      }\n      case \"deleteDb\": {\n        const db = databases.get(dbName);\n        if (db) {\n          db.close();\n          databases.delete(dbName);\n        }\n        result = { success: true };\n        break;\n      }\n      case \"exec\": {\n        const db = databases.get(dbName);\n        if (!db) throw new Error(`Database ${dbName} not found`);\n        const sql = args[0];\n        const params = args[1];\n        const injectResult = injectColumns(sql);\n        if (!injectResult.hasUserColumns && injectResult.sql !== sql) {\n          db.exec(injectResult.sql);\n          lastProcessedSql.set(dbName, injectResult.sql);\n          lastAffectedRows.set(dbName, []);\n          result = { rows: [], columns: [], affectedRows: [] };\n        } else {\n          const processed = processSql(sql, params);\n          let loggedSql = processed.sql;\n          if (processed.params.length > 0) {\n            let paramIdx = 0;\n            loggedSql = processed.sql.replace(/\\?/g, () => {\n              const val = processed.params[paramIdx++];\n              return JSON.stringify(val);\n            });\n          }\n          console.log(`[SQL] ${loggedSql}`);\n          lastProcessedSql.set(dbName, processed.sql);\n          if (processed.isMutation && processed.table) {\n            let affectedIds = [];\n            if (processed.rowId) {\n              affectedIds = [processed.rowId];\n            } else {\n              const whereMatch = sql.match(/WHERE\\s+(.+)$/i);\n              if (whereMatch) {\n                const selectSql = `SELECT id FROM ${processed.table} WHERE ${whereMatch[1]}`;\n                try {\n                  const idsResult = execute(db, selectSql, params);\n                  affectedIds = idsResult.rows.map((r) => r.id).filter(Boolean);\n                } catch (e) {\n                }\n              }\n            }\n            const execResult = execute(db, processed.sql, processed.params);\n            const affectedRows = affectedIds.map((id2) => ({ id: id2, table: processed.table }));\n            lastAffectedRows.set(dbName, affectedRows);\n            result = { ...execResult, affectedRows };\n          } else {\n            lastAffectedRows.set(dbName, []);\n            result = execute(db, processed.sql, processed.params);\n          }\n        }\n        break;\n      }\n      case \"export\": {\n        const db = databases.get(dbName);\n        if (!db) throw new Error(`Database ${dbName} not found`);\n        result = Array.from(exportDatabase(db));\n        break;\n      }\n      case \"exportBinary\": {\n        const db = databases.get(dbName);\n        if (!db) throw new Error(`Database ${dbName} not found`);\n        const binaryData = sqlite3.capi.sqlite3_js_db_export(db.pointer);\n        result = Array.from(binaryData);\n        break;\n      }\n      case \"import\": {\n        const db = databases.get(dbName);\n        if (!db) throw new Error(`Database ${dbName} not found`);\n        const data = new Uint8Array(args[0]);\n        await importDatabase(db, data);\n        result = { success: true };\n        break;\n      }\n      case \"importBinary\": {\n        const db = databases.get(dbName);\n        if (!db) throw new Error(`Database ${dbName} not found`);\n        const data = new Uint8Array(args[0]);\n        const pData = sqlite3.wasm.allocFromTypedArray(data);\n        try {\n          sqlite3.capi.sqlite3_deserialize(db.pointer, \"main\", pData, data.length, data.length, 0);\n        } finally {\n          sqlite3.wasm.dealloc(pData);\n        }\n        result = { success: true };\n        break;\n      }\n      case \"close\": {\n        const db = databases.get(dbName);\n        if (db) {\n          db.close();\n          databases.delete(dbName);\n        }\n        result = { success: true };\n        break;\n      }\n      case \"getTables\": {\n        const db = databases.get(dbName);\n        if (!db) throw new Error(`Database ${dbName} not found`);\n        const resultSet = execute(db, \"SELECT name FROM sqlite_master WHERE type='table' AND name NOT LIKE '_syncable_%'\");\n        result = { tables: resultSet.rows };\n        break;\n      }\n      case \"getTableData\": {\n        const db = databases.get(dbName);\n        if (!db) throw new Error(`Database ${dbName} not found`);\n        const tableName = args[0];\n        const resultSet = execute(db, `SELECT * FROM ${tableName} WHERE deleted = 0`);\n        result = { rows: resultSet.rows, columns: resultSet.columns };\n        break;\n      }\n      case \"merge\": {\n        const db = databases.get(dbName);\n        if (!db) throw new Error(`Database ${dbName} not found`);\n        const remoteData = new Uint8Array(args[0]);\n        await mergeDatabasesAsync(db, remoteData, sqlite3);\n        result = { success: true };\n        break;\n      }\n      case \"execRaw\": {\n        const db = databases.get(dbName);\n        if (!db) throw new Error(`Database ${dbName} not found`);\n        let sql = args[0];\n        if (sql.toUpperCase().trim().startsWith(\"INSERT INTO\")) {\n          sql = sql.replace(/^INSERT\\s+INTO/i, \"INSERT OR REPLACE INTO\");\n        }\n        db.exec(sql);\n        result = { success: true };\n        break;\n      }\n      case \"getLastProcessedSql\": {\n        result = lastProcessedSql.get(dbName) || \"\";\n        break;\n      }\n      default:\n        throw new Error(`Unknown request type: ${type}`);\n    }\n    return { id, type, success: true, result };\n  } catch (error) {\n    return { id, type, success: false, error: String(error) };\n  }\n}\nself.onmessage = async (event) => {\n  const request = event.data;\n  const response = await handleRequest(request);\n  self.postMessage(response);\n};\nself.onerror = (error) => {\n  console.error(\"Worker error:\", error);\n};\n";
//# sourceMappingURL=worker-string.d.ts.map